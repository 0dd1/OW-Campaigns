// export MacMillan , Burlak , ru_sci , Powell , Stevens , truck1 , truck2 ; export blast_was_seen , lab_destroyed , time_out , entered_contaminated_area , original_stevens , blast_time , technology_taken , keep_base_finished ; export you , americans ; export Masha ; export time_to_complete , ru_artefact ; function prepare_units ; var veh , JMM_car , Bur_car , JMM_load , Bur_load ; begin
   0: LD_INT 0
   2: PPUSH
   3: PPUSH
   4: PPUSH
   5: PPUSH
   6: PPUSH
   7: PPUSH
// uc_nation := nation_american ;
   8: LD_ADDR_OWVAR 21
  12: PUSH
  13: LD_INT 1
  15: ST_TO_ADDR
// uc_side := you ;
  16: LD_ADDR_OWVAR 20
  20: PUSH
  21: LD_EXP 16
  25: ST_TO_ADDR
// MacMillan := CreateCharacter ( MacMillan ) ;
  26: LD_ADDR_EXP 1
  30: PUSH
  31: LD_STRING MacMillan
  33: PPUSH
  34: CALL_OW 34
  38: ST_TO_ADDR
// SetClass ( MacMillan , class_engineer ) ;
  39: LD_EXP 1
  43: PPUSH
  44: LD_INT 2
  46: PPUSH
  47: CALL_OW 336
// Burlak := CreateCharacter ( Burlak ) ;
  51: LD_ADDR_EXP 2
  55: PUSH
  56: LD_STRING Burlak
  58: PPUSH
  59: CALL_OW 34
  63: ST_TO_ADDR
// SetClass ( Burlak , class_mechanic ) ;
  64: LD_EXP 2
  68: PPUSH
  69: LD_INT 3
  71: PPUSH
  72: CALL_OW 336
// uc_nation := nation_russian ;
  76: LD_ADDR_OWVAR 21
  80: PUSH
  81: LD_INT 3
  83: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
  84: LD_INT 1
  86: PPUSH
  87: LD_INT 8
  89: PPUSH
  90: CALL_OW 384
// ru_sci := CreateHuman ;
  94: LD_ADDR_EXP 3
  98: PUSH
  99: CALL_OW 44
 103: ST_TO_ADDR
// uc_nation := nation_american ;
 104: LD_ADDR_OWVAR 21
 108: PUSH
 109: LD_INT 1
 111: ST_TO_ADDR
// uc_side := americans ;
 112: LD_ADDR_OWVAR 20
 116: PUSH
 117: LD_EXP 17
 121: ST_TO_ADDR
// Powell := CreateCharacter ( Powell ) ;
 122: LD_ADDR_EXP 4
 126: PUSH
 127: LD_STRING Powell
 129: PPUSH
 130: CALL_OW 34
 134: ST_TO_ADDR
// if TestCharacters ( Stevens ) and CheckCharacterSet ( Stevens ) then
 135: LD_STRING Stevens
 137: PPUSH
 138: CALL_OW 28
 142: PUSH
 143: LD_STRING Stevens
 145: PPUSH
 146: CALL_OW 29
 150: AND
 151: IFFALSE 176
// begin Stevens := CreateCharacter ( Stevens ) ;
 153: LD_ADDR_EXP 5
 157: PUSH
 158: LD_STRING Stevens
 160: PPUSH
 161: CALL_OW 34
 165: ST_TO_ADDR
// original_stevens := true ;
 166: LD_ADDR_EXP 12
 170: PUSH
 171: LD_INT 1
 173: ST_TO_ADDR
// end else
 174: GO 212
// begin uc_nation := nation_american ;
 176: LD_ADDR_OWVAR 21
 180: PUSH
 181: LD_INT 1
 183: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
 184: LD_INT 1
 186: PPUSH
 187: LD_INT 8
 189: PPUSH
 190: CALL_OW 384
// Stevens := CreateHuman ;
 194: LD_ADDR_EXP 5
 198: PUSH
 199: CALL_OW 44
 203: ST_TO_ADDR
// original_stevens := false ;
 204: LD_ADDR_EXP 12
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// end ; uc_side = you ;
 212: LD_ADDR_OWVAR 20
 216: PUSH
 217: LD_EXP 16
 221: ST_TO_ADDR
// uc_nation := nation_american ;
 222: LD_ADDR_OWVAR 21
 226: PUSH
 227: LD_INT 1
 229: ST_TO_ADDR
// uc_direction := 5 ;
 230: LD_ADDR_OWVAR 24
 234: PUSH
 235: LD_INT 5
 237: ST_TO_ADDR
// veh := LoadVariable ( Masha , [ ] ) ;
 238: LD_ADDR_VAR 0 2
 242: PUSH
 243: LD_STRING Masha
 245: PPUSH
 246: EMPTY
 247: PPUSH
 248: CALL_OW 30
 252: ST_TO_ADDR
// if veh then
 253: LD_VAR 0 2
 257: IFFALSE 327
// begin vc_chassis := veh [ 1 ] ;
 259: LD_ADDR_OWVAR 37
 263: PUSH
 264: LD_VAR 0 2
 268: PUSH
 269: LD_INT 1
 271: ARRAY
 272: ST_TO_ADDR
// vc_engine := veh [ 2 ] ;
 273: LD_ADDR_OWVAR 39
 277: PUSH
 278: LD_VAR 0 2
 282: PUSH
 283: LD_INT 2
 285: ARRAY
 286: ST_TO_ADDR
// vc_control := veh [ 3 ] ;
 287: LD_ADDR_OWVAR 38
 291: PUSH
 292: LD_VAR 0 2
 296: PUSH
 297: LD_INT 3
 299: ARRAY
 300: ST_TO_ADDR
// vc_weapon := veh [ 4 ] ;
 301: LD_ADDR_OWVAR 40
 305: PUSH
 306: LD_VAR 0 2
 310: PUSH
 311: LD_INT 4
 313: ARRAY
 314: ST_TO_ADDR
// Masha := CreateVehicle ;
 315: LD_ADDR_EXP 18
 319: PUSH
 320: CALL_OW 45
 324: ST_TO_ADDR
// end else
 325: GO 335
// Masha := false ;
 327: LD_ADDR_EXP 18
 331: PUSH
 332: LD_INT 0
 334: ST_TO_ADDR
// JMM_car := LoadVariable ( JMM_car , [ us_medium_tracked , engine_combustion , control_manual , us_cargo_bay ] ) ;
 335: LD_ADDR_VAR 0 3
 339: PUSH
 340: LD_STRING JMM_car
 342: PPUSH
 343: LD_INT 3
 345: PUSH
 346: LD_INT 1
 348: PUSH
 349: LD_INT 1
 351: PUSH
 352: LD_INT 12
 354: PUSH
 355: EMPTY
 356: LIST
 357: LIST
 358: LIST
 359: LIST
 360: PPUSH
 361: CALL_OW 30
 365: ST_TO_ADDR
// JMM_load := LoadVariable ( JMM_car_load , 0 ) ;
 366: LD_ADDR_VAR 0 5
 370: PUSH
 371: LD_STRING JMM_car_load
 373: PPUSH
 374: LD_INT 0
 376: PPUSH
 377: CALL_OW 30
 381: ST_TO_ADDR
// if JMM_car [ 1 ] in [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] then
 382: LD_VAR 0 3
 386: PUSH
 387: LD_INT 1
 389: ARRAY
 390: PUSH
 391: LD_INT 1
 393: PUSH
 394: LD_INT 2
 396: PUSH
 397: LD_INT 3
 399: PUSH
 400: LD_INT 4
 402: PUSH
 403: LD_INT 5
 405: PUSH
 406: EMPTY
 407: LIST
 408: LIST
 409: LIST
 410: LIST
 411: LIST
 412: IN
 413: IFFALSE 425
// uc_nation := nation_american else
 415: LD_ADDR_OWVAR 21
 419: PUSH
 420: LD_INT 1
 422: ST_TO_ADDR
 423: GO 433
// uc_nation := nation_russian ;
 425: LD_ADDR_OWVAR 21
 429: PUSH
 430: LD_INT 3
 432: ST_TO_ADDR
// vc_chassis := JMM_car [ 1 ] ;
 433: LD_ADDR_OWVAR 37
 437: PUSH
 438: LD_VAR 0 3
 442: PUSH
 443: LD_INT 1
 445: ARRAY
 446: ST_TO_ADDR
// vc_engine := JMM_car [ 2 ] ;
 447: LD_ADDR_OWVAR 39
 451: PUSH
 452: LD_VAR 0 3
 456: PUSH
 457: LD_INT 2
 459: ARRAY
 460: ST_TO_ADDR
// vc_control := JMM_car [ 3 ] ;
 461: LD_ADDR_OWVAR 38
 465: PUSH
 466: LD_VAR 0 3
 470: PUSH
 471: LD_INT 3
 473: ARRAY
 474: ST_TO_ADDR
// vc_weapon := JMM_car [ 4 ] ;
 475: LD_ADDR_OWVAR 40
 479: PUSH
 480: LD_VAR 0 3
 484: PUSH
 485: LD_INT 4
 487: ARRAY
 488: ST_TO_ADDR
// truck1 := CreateVehicle ;
 489: LD_ADDR_EXP 6
 493: PUSH
 494: CALL_OW 45
 498: ST_TO_ADDR
// if Masha and ( GetWeapon ( truck1 ) = GetWeapon ( Masha ) ) then
 499: LD_EXP 18
 503: PUSH
 504: LD_EXP 6
 508: PPUSH
 509: CALL_OW 264
 513: PUSH
 514: LD_EXP 18
 518: PPUSH
 519: CALL_OW 264
 523: EQUAL
 524: AND
 525: IFFALSE 549
// begin SetMark ( truck1 , 1 ) ;
 527: LD_EXP 6
 531: PPUSH
 532: LD_INT 1
 534: PPUSH
 535: CALL_OW 242
// Masha := truck1 ;
 539: LD_ADDR_EXP 18
 543: PUSH
 544: LD_EXP 6
 548: ST_TO_ADDR
// end ; if JMM_load > 0 then
 549: LD_VAR 0 5
 553: PUSH
 554: LD_INT 0
 556: GREATER
 557: IFFALSE 576
// SetCargo ( truck1 , mat_oil , JMM_load ) ;
 559: LD_EXP 6
 563: PPUSH
 564: LD_INT 2
 566: PPUSH
 567: LD_VAR 0 5
 571: PPUSH
 572: CALL_OW 290
// Bur_car := LoadVariable ( Bur_car , [ ru_medium_tracked , engine_combustion , control_manual , ru_gatling_gun ] ) ;
 576: LD_ADDR_VAR 0 4
 580: PUSH
 581: LD_STRING Bur_car
 583: PPUSH
 584: LD_INT 22
 586: PUSH
 587: LD_INT 1
 589: PUSH
 590: LD_INT 1
 592: PUSH
 593: LD_INT 43
 595: PUSH
 596: EMPTY
 597: LIST
 598: LIST
 599: LIST
 600: LIST
 601: PPUSH
 602: CALL_OW 30
 606: ST_TO_ADDR
// Bur_load := LoadVariable ( Bur_car_load , 0 ) ;
 607: LD_ADDR_VAR 0 6
 611: PUSH
 612: LD_STRING Bur_car_load
 614: PPUSH
 615: LD_INT 0
 617: PPUSH
 618: CALL_OW 30
 622: ST_TO_ADDR
// if Bur_car [ 1 ] in [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] then
 623: LD_VAR 0 4
 627: PUSH
 628: LD_INT 1
 630: ARRAY
 631: PUSH
 632: LD_INT 21
 634: PUSH
 635: LD_INT 22
 637: PUSH
 638: LD_INT 23
 640: PUSH
 641: LD_INT 24
 643: PUSH
 644: EMPTY
 645: LIST
 646: LIST
 647: LIST
 648: LIST
 649: IN
 650: IFFALSE 662
// uc_nation := nation_russian else
 652: LD_ADDR_OWVAR 21
 656: PUSH
 657: LD_INT 3
 659: ST_TO_ADDR
 660: GO 670
// uc_nation := nation_american ;
 662: LD_ADDR_OWVAR 21
 666: PUSH
 667: LD_INT 1
 669: ST_TO_ADDR
// vc_chassis := Bur_car [ 1 ] ;
 670: LD_ADDR_OWVAR 37
 674: PUSH
 675: LD_VAR 0 4
 679: PUSH
 680: LD_INT 1
 682: ARRAY
 683: ST_TO_ADDR
// vc_engine := Bur_car [ 2 ] ;
 684: LD_ADDR_OWVAR 39
 688: PUSH
 689: LD_VAR 0 4
 693: PUSH
 694: LD_INT 2
 696: ARRAY
 697: ST_TO_ADDR
// vc_control := Bur_car [ 3 ] ;
 698: LD_ADDR_OWVAR 38
 702: PUSH
 703: LD_VAR 0 4
 707: PUSH
 708: LD_INT 3
 710: ARRAY
 711: ST_TO_ADDR
// vc_weapon := Bur_car [ 4 ] ;
 712: LD_ADDR_OWVAR 40
 716: PUSH
 717: LD_VAR 0 4
 721: PUSH
 722: LD_INT 4
 724: ARRAY
 725: ST_TO_ADDR
// truck2 := CreateVehicle ;
 726: LD_ADDR_EXP 7
 730: PUSH
 731: CALL_OW 45
 735: ST_TO_ADDR
// if Masha and ( GetWeapon ( truck2 ) = GetWeapon ( Masha ) ) then
 736: LD_EXP 18
 740: PUSH
 741: LD_EXP 7
 745: PPUSH
 746: CALL_OW 264
 750: PUSH
 751: LD_EXP 18
 755: PPUSH
 756: CALL_OW 264
 760: EQUAL
 761: AND
 762: IFFALSE 786
// begin SetMark ( truck2 , 1 ) ;
 764: LD_EXP 7
 768: PPUSH
 769: LD_INT 1
 771: PPUSH
 772: CALL_OW 242
// Masha := truck1 ;
 776: LD_ADDR_EXP 18
 780: PUSH
 781: LD_EXP 6
 785: ST_TO_ADDR
// end ; if Bur_load > 0 then
 786: LD_VAR 0 6
 790: PUSH
 791: LD_INT 0
 793: GREATER
 794: IFFALSE 813
// SetCargo ( truck2 , mat_oil , Bur_load ) ;
 796: LD_EXP 7
 800: PPUSH
 801: LD_INT 2
 803: PPUSH
 804: LD_VAR 0 6
 808: PPUSH
 809: CALL_OW 290
// PlaceHumanInUnit ( MacMillan , truck1 ) ;
 813: LD_EXP 1
 817: PPUSH
 818: LD_EXP 6
 822: PPUSH
 823: CALL_OW 52
// PlaceHumanInUnit ( Burlak , truck2 ) ;
 827: LD_EXP 2
 831: PPUSH
 832: LD_EXP 7
 836: PPUSH
 837: CALL_OW 52
// PlaceUnitXY ( truck1 , 200 , 86 , false ) ;
 841: LD_EXP 6
 845: PPUSH
 846: LD_INT 200
 848: PPUSH
 849: LD_INT 86
 851: PPUSH
 852: LD_INT 0
 854: PPUSH
 855: CALL_OW 48
// PlaceUnitXY ( truck2 , 202 , 90 , false ) ;
 859: LD_EXP 7
 863: PPUSH
 864: LD_INT 202
 866: PPUSH
 867: LD_INT 90
 869: PPUSH
 870: LD_INT 0
 872: PPUSH
 873: CALL_OW 48
// ComFree ( [ MacMillan , Burlak ] ) ;
 877: LD_EXP 1
 881: PUSH
 882: LD_EXP 2
 886: PUSH
 887: EMPTY
 888: LIST
 889: LIST
 890: PPUSH
 891: CALL_OW 139
// end ;
 895: LD_VAR 0 1
 899: RET
// function prepare_sides ; begin
 900: LD_INT 0
 902: PPUSH
// you = 7 ;
 903: LD_ADDR_EXP 16
 907: PUSH
 908: LD_INT 7
 910: ST_TO_ADDR
// americans = 1 ;
 911: LD_ADDR_EXP 17
 915: PUSH
 916: LD_INT 1
 918: ST_TO_ADDR
// SetAttitude ( you , americans , att_enemy , true ) ;
 919: LD_EXP 16
 923: PPUSH
 924: LD_EXP 17
 928: PPUSH
 929: LD_INT 2
 931: PPUSH
 932: LD_INT 1
 934: PPUSH
 935: CALL_OW 80
// blast_was_seen := false ;
 939: LD_ADDR_EXP 8
 943: PUSH
 944: LD_INT 0
 946: ST_TO_ADDR
// time_out := false ;
 947: LD_ADDR_EXP 10
 951: PUSH
 952: LD_INT 0
 954: ST_TO_ADDR
// entered_contaminated_area := false ;
 955: LD_ADDR_EXP 11
 959: PUSH
 960: LD_INT 0
 962: ST_TO_ADDR
// blast_countdown := false ;
 963: LD_ADDR_EXP 27
 967: PUSH
 968: LD_INT 0
 970: ST_TO_ADDR
// lab_destroyed := false ;
 971: LD_ADDR_EXP 9
 975: PUSH
 976: LD_INT 0
 978: ST_TO_ADDR
// technology_taken := false ;
 979: LD_ADDR_EXP 14
 983: PUSH
 984: LD_INT 0
 986: ST_TO_ADDR
// time_to_complete := [ 15 15$0 , 10 10$0 , 8 8$0 ] [ difficulty ] ;
 987: LD_ADDR_EXP 19
 991: PUSH
 992: LD_INT 31500
 994: PUSH
 995: LD_INT 21000
 997: PUSH
 998: LD_INT 16800
1000: PUSH
1001: EMPTY
1002: LIST
1003: LIST
1004: LIST
1005: PUSH
1006: LD_OWVAR 67
1010: ARRAY
1011: ST_TO_ADDR
// ru_artefact := 4 ;
1012: LD_ADDR_EXP 20
1016: PUSH
1017: LD_INT 4
1019: ST_TO_ADDR
// blast_done := false ;
1020: LD_ADDR_EXP 28
1024: PUSH
1025: LD_INT 0
1027: ST_TO_ADDR
// query_started := false ;
1028: LD_ADDR_EXP 29
1032: PUSH
1033: LD_INT 0
1035: ST_TO_ADDR
// dokecano := false ;
1036: LD_ADDR_EXP 33
1040: PUSH
1041: LD_INT 0
1043: ST_TO_ADDR
// art_picked := false ;
1044: LD_ADDR_EXP 31
1048: PUSH
1049: LD_INT 0
1051: ST_TO_ADDR
// art_cargo := false ;
1052: LD_ADDR_EXP 32
1056: PUSH
1057: LD_INT 0
1059: ST_TO_ADDR
// disable ( 1 ) ;
1060: LD_INT 1
1062: DISABLE_MARKED
// disable ( 2 ) ;
1063: LD_INT 2
1065: DISABLE_MARKED
// disable ( 3 ) ;
1066: LD_INT 3
1068: DISABLE_MARKED
// disable ( 4 ) ;
1069: LD_INT 4
1071: DISABLE_MARKED
// disable ( 5 ) ;
1072: LD_INT 5
1074: DISABLE_MARKED
// disable ( 6 ) ;
1075: LD_INT 6
1077: DISABLE_MARKED
// disable ( 7 ) ;
1078: LD_INT 7
1080: DISABLE_MARKED
// disable ( 8 ) ;
1081: LD_INT 8
1083: DISABLE_MARKED
// disable ( 9 ) ;
1084: LD_INT 9
1086: DISABLE_MARKED
// disable ( 10 ) ;
1087: LD_INT 10
1089: DISABLE_MARKED
// end ;
1090: LD_VAR 0 1
1094: RET
// starting begin prepare_sides ;
1095: CALL 900 0 0
// prepare_units ;
1099: CALL 0 0 0
// prepare_us_side ;
1103: CALL 3069 0 0
// starting_scene ;
1107: CALL 4584 0 0
// end ;
1111: END
// export function konec_mise ; var un , JMM_car , Bur_car ; begin
1112: LD_INT 0
1114: PPUSH
1115: PPUSH
1116: PPUSH
1117: PPUSH
// AddMedal ( Explosion , blast_was_seen ) ;
1118: LD_STRING Explosion
1120: PPUSH
1121: LD_EXP 8
1125: PPUSH
1126: CALL_OW 101
// AddMedal ( BioHazard , entered_contaminated_area ) ;
1130: LD_STRING BioHazard
1132: PPUSH
1133: LD_EXP 11
1137: PPUSH
1138: CALL_OW 101
// AddMedal ( Speed , ( TICK - blast_time ) < time_to_complete ) ;
1142: LD_STRING Speed
1144: PPUSH
1145: LD_OWVAR 1
1149: PUSH
1150: LD_EXP 13
1154: MINUS
1155: PUSH
1156: LD_EXP 19
1160: LESS
1161: PPUSH
1162: CALL_OW 101
// SA_EndMission ( 4 , 3 , blast_was_seen > 0 , entered_contaminated_area > 0 , ( TICK - blast_time ) < time_to_complete ) ;
1166: LD_INT 4
1168: PPUSH
1169: LD_INT 3
1171: PPUSH
1172: LD_EXP 8
1176: PUSH
1177: LD_INT 0
1179: GREATER
1180: PPUSH
1181: LD_EXP 11
1185: PUSH
1186: LD_INT 0
1188: GREATER
1189: PPUSH
1190: LD_OWVAR 1
1194: PUSH
1195: LD_EXP 13
1199: MINUS
1200: PUSH
1201: LD_EXP 19
1205: LESS
1206: PPUSH
1207: CALL 7705 0 5
// GiveMedals ( Main ) ;
1211: LD_STRING Main
1213: PPUSH
1214: CALL_OW 102
// RewardPeople ( [ Burlak , MacMillan ] ) ;
1218: LD_EXP 2
1222: PUSH
1223: LD_EXP 1
1227: PUSH
1228: EMPTY
1229: LIST
1230: LIST
1231: PPUSH
1232: CALL_OW 43
// SaveCharacters ( MacMillan , JMM ) ;
1236: LD_EXP 1
1240: PPUSH
1241: LD_STRING JMM
1243: PPUSH
1244: CALL_OW 38
// SaveCharacters ( Burlak , Burlak ) ;
1248: LD_EXP 2
1252: PPUSH
1253: LD_STRING Burlak
1255: PPUSH
1256: CALL_OW 38
// un := IsInUnit ( MacMillan ) ;
1260: LD_ADDR_VAR 0 2
1264: PUSH
1265: LD_EXP 1
1269: PPUSH
1270: CALL_OW 310
1274: ST_TO_ADDR
// if un then
1275: LD_VAR 0 2
1279: IFFALSE 1346
// begin JMM_car := [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
1281: LD_ADDR_VAR 0 3
1285: PUSH
1286: LD_VAR 0 2
1290: PPUSH
1291: CALL_OW 265
1295: PUSH
1296: LD_VAR 0 2
1300: PPUSH
1301: CALL_OW 262
1305: PUSH
1306: LD_VAR 0 2
1310: PPUSH
1311: CALL_OW 263
1315: PUSH
1316: LD_VAR 0 2
1320: PPUSH
1321: CALL_OW 264
1325: PUSH
1326: EMPTY
1327: LIST
1328: LIST
1329: LIST
1330: LIST
1331: ST_TO_ADDR
// SaveVariable ( JMM_car , JMM_car ) ;
1332: LD_VAR 0 3
1336: PPUSH
1337: LD_STRING JMM_car
1339: PPUSH
1340: CALL_OW 39
// end else
1344: GO 1353
// DeleteVariable ( JMM_car ) ;
1346: LD_STRING JMM_car
1348: PPUSH
1349: CALL_OW 41
// un := IsInUnit ( Burlak ) ;
1353: LD_ADDR_VAR 0 2
1357: PUSH
1358: LD_EXP 2
1362: PPUSH
1363: CALL_OW 310
1367: ST_TO_ADDR
// if un then
1368: LD_VAR 0 2
1372: IFFALSE 1439
// begin Bur_car := [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
1374: LD_ADDR_VAR 0 4
1378: PUSH
1379: LD_VAR 0 2
1383: PPUSH
1384: CALL_OW 265
1388: PUSH
1389: LD_VAR 0 2
1393: PPUSH
1394: CALL_OW 262
1398: PUSH
1399: LD_VAR 0 2
1403: PPUSH
1404: CALL_OW 263
1408: PUSH
1409: LD_VAR 0 2
1413: PPUSH
1414: CALL_OW 264
1418: PUSH
1419: EMPTY
1420: LIST
1421: LIST
1422: LIST
1423: LIST
1424: ST_TO_ADDR
// SaveVariable ( Bur_car , Bur_car ) ;
1425: LD_VAR 0 4
1429: PPUSH
1430: LD_STRING Bur_car
1432: PPUSH
1433: CALL_OW 39
// end else
1437: GO 1446
// DeleteVariable ( Bur_car ) ;
1439: LD_STRING Bur_car
1441: PPUSH
1442: CALL_OW 41
// if not IsOK ( Masha ) then
1446: LD_EXP 18
1450: PPUSH
1451: CALL_OW 302
1455: NOT
1456: IFFALSE 1465
// DeleteVariable ( Masha ) ;
1458: LD_STRING Masha
1460: PPUSH
1461: CALL_OW 41
// YouWin ;
1465: CALL_OW 103
// end ;
1469: LD_VAR 0 1
1473: RET
// export function Mission_Failed ( style ) ; begin
1474: LD_INT 0
1476: PPUSH
// case style of 1 :
1477: LD_VAR 0 1
1481: PUSH
1482: LD_INT 1
1484: DOUBLE
1485: EQUAL
1486: IFTRUE 1490
1488: GO 1500
1490: POP
// YouLost ( Burlak ) ; 2 :
1491: LD_STRING Burlak
1493: PPUSH
1494: CALL_OW 104
1498: GO 1591
1500: LD_INT 2
1502: DOUBLE
1503: EQUAL
1504: IFTRUE 1508
1506: GO 1518
1508: POP
// YouLost ( JMM ) ; 3 :
1509: LD_STRING JMM
1511: PPUSH
1512: CALL_OW 104
1516: GO 1591
1518: LD_INT 3
1520: DOUBLE
1521: EQUAL
1522: IFTRUE 1526
1524: GO 1536
1526: POP
// YouLost ( Time ) ; 4 :
1527: LD_STRING Time
1529: PPUSH
1530: CALL_OW 104
1534: GO 1591
1536: LD_INT 4
1538: DOUBLE
1539: EQUAL
1540: IFTRUE 1544
1542: GO 1554
1544: POP
// YouLost ( Artefact ) ; 5 :
1545: LD_STRING Artefact
1547: PPUSH
1548: CALL_OW 104
1552: GO 1591
1554: LD_INT 5
1556: DOUBLE
1557: EQUAL
1558: IFTRUE 1562
1560: GO 1572
1562: POP
// YouLost ( Lab ) ; 6 :
1563: LD_STRING Lab
1565: PPUSH
1566: CALL_OW 104
1570: GO 1591
1572: LD_INT 6
1574: DOUBLE
1575: EQUAL
1576: IFTRUE 1580
1578: GO 1590
1580: POP
// YouLost ( Cargo ) ; end ;
1581: LD_STRING Cargo
1583: PPUSH
1584: CALL_OW 104
1588: GO 1591
1590: POP
// end ; end_of_file
1591: LD_VAR 0 2
1595: RET
// export us_sol , us_sci , us_mech , us_all_units ; export us_patrol_1 , us_patrol_2 ; export blast_countdown ; every 0 0$1 marked 2 do var i , x , y , cesta ;
1596: GO 1598
1598: DISABLE
1599: LD_INT 0
1601: PPUSH
1602: PPUSH
1603: PPUSH
1604: PPUSH
// begin if difficulty < 3 then
1605: LD_OWVAR 67
1609: PUSH
1610: LD_INT 3
1612: LESS
1613: IFFALSE 1752
// cesta := [ 101 , 39 , 124 , 31 , 123 , 7 , 158 , 21 , 168 , 40 , 168 , 65 , 167 , 90 , 146 , 83 , 146 , 83 , 167 , 90 , 168 , 65 , 168 , 40 , 158 , 21 , 123 , 7 , 124 , 31 , 101 , 39 ] else
1615: LD_ADDR_VAR 0 4
1619: PUSH
1620: LD_INT 101
1622: PUSH
1623: LD_INT 39
1625: PUSH
1626: LD_INT 124
1628: PUSH
1629: LD_INT 31
1631: PUSH
1632: LD_INT 123
1634: PUSH
1635: LD_INT 7
1637: PUSH
1638: LD_INT 158
1640: PUSH
1641: LD_INT 21
1643: PUSH
1644: LD_INT 168
1646: PUSH
1647: LD_INT 40
1649: PUSH
1650: LD_INT 168
1652: PUSH
1653: LD_INT 65
1655: PUSH
1656: LD_INT 167
1658: PUSH
1659: LD_INT 90
1661: PUSH
1662: LD_INT 146
1664: PUSH
1665: LD_INT 83
1667: PUSH
1668: LD_INT 146
1670: PUSH
1671: LD_INT 83
1673: PUSH
1674: LD_INT 167
1676: PUSH
1677: LD_INT 90
1679: PUSH
1680: LD_INT 168
1682: PUSH
1683: LD_INT 65
1685: PUSH
1686: LD_INT 168
1688: PUSH
1689: LD_INT 40
1691: PUSH
1692: LD_INT 158
1694: PUSH
1695: LD_INT 21
1697: PUSH
1698: LD_INT 123
1700: PUSH
1701: LD_INT 7
1703: PUSH
1704: LD_INT 124
1706: PUSH
1707: LD_INT 31
1709: PUSH
1710: LD_INT 101
1712: PUSH
1713: LD_INT 39
1715: PUSH
1716: EMPTY
1717: LIST
1718: LIST
1719: LIST
1720: LIST
1721: LIST
1722: LIST
1723: LIST
1724: LIST
1725: LIST
1726: LIST
1727: LIST
1728: LIST
1729: LIST
1730: LIST
1731: LIST
1732: LIST
1733: LIST
1734: LIST
1735: LIST
1736: LIST
1737: LIST
1738: LIST
1739: LIST
1740: LIST
1741: LIST
1742: LIST
1743: LIST
1744: LIST
1745: LIST
1746: LIST
1747: LIST
1748: LIST
1749: ST_TO_ADDR
1750: GO 1823
// cesta := [ 101 , 39 , 124 , 31 , 123 , 7 , 135 , 7 , 135 , 7 , 123 , 7 , 124 , 31 , 101 , 39 ] ;
1752: LD_ADDR_VAR 0 4
1756: PUSH
1757: LD_INT 101
1759: PUSH
1760: LD_INT 39
1762: PUSH
1763: LD_INT 124
1765: PUSH
1766: LD_INT 31
1768: PUSH
1769: LD_INT 123
1771: PUSH
1772: LD_INT 7
1774: PUSH
1775: LD_INT 135
1777: PUSH
1778: LD_INT 7
1780: PUSH
1781: LD_INT 135
1783: PUSH
1784: LD_INT 7
1786: PUSH
1787: LD_INT 123
1789: PUSH
1790: LD_INT 7
1792: PUSH
1793: LD_INT 124
1795: PUSH
1796: LD_INT 31
1798: PUSH
1799: LD_INT 101
1801: PUSH
1802: LD_INT 39
1804: PUSH
1805: EMPTY
1806: LIST
1807: LIST
1808: LIST
1809: LIST
1810: LIST
1811: LIST
1812: LIST
1813: LIST
1814: LIST
1815: LIST
1816: LIST
1817: LIST
1818: LIST
1819: LIST
1820: LIST
1821: LIST
1822: ST_TO_ADDR
// repeat for i = 1 to ( cesta div 2 ) do
1823: LD_ADDR_VAR 0 1
1827: PUSH
1828: DOUBLE
1829: LD_INT 1
1831: DEC
1832: ST_TO_ADDR
1833: LD_VAR 0 4
1837: PUSH
1838: LD_INT 2
1840: DIV
1841: PUSH
1842: FOR_TO
1843: IFFALSE 1967
// begin x := cesta [ ( i * 2 ) - 1 ] ;
1845: LD_ADDR_VAR 0 2
1849: PUSH
1850: LD_VAR 0 4
1854: PUSH
1855: LD_VAR 0 1
1859: PUSH
1860: LD_INT 2
1862: MUL
1863: PUSH
1864: LD_INT 1
1866: MINUS
1867: ARRAY
1868: ST_TO_ADDR
// y := cesta [ ( i * 2 ) ] ;
1869: LD_ADDR_VAR 0 3
1873: PUSH
1874: LD_VAR 0 4
1878: PUSH
1879: LD_VAR 0 1
1883: PUSH
1884: LD_INT 2
1886: MUL
1887: ARRAY
1888: ST_TO_ADDR
// ComAgressiveMove ( us_patrol_1 , x , y ) ;
1889: LD_EXP 25
1893: PPUSH
1894: LD_VAR 0 2
1898: PPUSH
1899: LD_VAR 0 3
1903: PPUSH
1904: CALL_OW 114
// repeat wait ( 0 0$3 ) ;
1908: LD_INT 105
1910: PPUSH
1911: CALL_OW 67
// y := true ;
1915: LD_ADDR_VAR 0 3
1919: PUSH
1920: LD_INT 1
1922: ST_TO_ADDR
// for x in us_patrol_1 do
1923: LD_ADDR_VAR 0 2
1927: PUSH
1928: LD_EXP 25
1932: PUSH
1933: FOR_IN
1934: IFFALSE 1957
// if IsBusy ( x ) then
1936: LD_VAR 0 2
1940: PPUSH
1941: CALL_OW 315
1945: IFFALSE 1955
// y := false ;
1947: LD_ADDR_VAR 0 3
1951: PUSH
1952: LD_INT 0
1954: ST_TO_ADDR
1955: GO 1933
1957: POP
1958: POP
// until y ;
1959: LD_VAR 0 3
1963: IFFALSE 1908
// end ;
1965: GO 1842
1967: POP
1968: POP
// until ( not us_patrol_1 ) or ( blast_countdown ) ;
1969: LD_EXP 25
1973: NOT
1974: PUSH
1975: LD_EXP 27
1979: OR
1980: IFFALSE 1823
// if us_patrol_1 then
1982: LD_EXP 25
1986: IFFALSE 2026
// begin ComAgressiveMove ( us_patrol_1 , 56 , 77 ) ;
1988: LD_EXP 25
1992: PPUSH
1993: LD_INT 56
1995: PPUSH
1996: LD_INT 77
1998: PPUSH
1999: CALL_OW 114
// us_sol := us_sol ^ us_patrol_1 ;
2003: LD_ADDR_EXP 21
2007: PUSH
2008: LD_EXP 21
2012: PUSH
2013: LD_EXP 25
2017: ADD
2018: ST_TO_ADDR
// us_patrol_1 := [ ] ;
2019: LD_ADDR_EXP 25
2023: PUSH
2024: EMPTY
2025: ST_TO_ADDR
// end ; end ;
2026: PPOPN 4
2028: END
// every 0 0$1 marked 3 do var i , x , y , cesta ;
2029: GO 2031
2031: DISABLE
2032: LD_INT 0
2034: PPUSH
2035: PPUSH
2036: PPUSH
2037: PPUSH
// begin cesta := [ 135 , 7 , 158 , 21 , 168 , 40 , 168 , 65 , 167 , 90 , 146 , 83 , 146 , 83 , 167 , 90 , 168 , 65 , 168 , 40 , 158 , 21 , 135 , 7 ] ;
2038: LD_ADDR_VAR 0 4
2042: PUSH
2043: LD_INT 135
2045: PUSH
2046: LD_INT 7
2048: PUSH
2049: LD_INT 158
2051: PUSH
2052: LD_INT 21
2054: PUSH
2055: LD_INT 168
2057: PUSH
2058: LD_INT 40
2060: PUSH
2061: LD_INT 168
2063: PUSH
2064: LD_INT 65
2066: PUSH
2067: LD_INT 167
2069: PUSH
2070: LD_INT 90
2072: PUSH
2073: LD_INT 146
2075: PUSH
2076: LD_INT 83
2078: PUSH
2079: LD_INT 146
2081: PUSH
2082: LD_INT 83
2084: PUSH
2085: LD_INT 167
2087: PUSH
2088: LD_INT 90
2090: PUSH
2091: LD_INT 168
2093: PUSH
2094: LD_INT 65
2096: PUSH
2097: LD_INT 168
2099: PUSH
2100: LD_INT 40
2102: PUSH
2103: LD_INT 158
2105: PUSH
2106: LD_INT 21
2108: PUSH
2109: LD_INT 135
2111: PUSH
2112: LD_INT 7
2114: PUSH
2115: EMPTY
2116: LIST
2117: LIST
2118: LIST
2119: LIST
2120: LIST
2121: LIST
2122: LIST
2123: LIST
2124: LIST
2125: LIST
2126: LIST
2127: LIST
2128: LIST
2129: LIST
2130: LIST
2131: LIST
2132: LIST
2133: LIST
2134: LIST
2135: LIST
2136: LIST
2137: LIST
2138: LIST
2139: LIST
2140: ST_TO_ADDR
// repeat for i = 1 to ( cesta div 2 ) do
2141: LD_ADDR_VAR 0 1
2145: PUSH
2146: DOUBLE
2147: LD_INT 1
2149: DEC
2150: ST_TO_ADDR
2151: LD_VAR 0 4
2155: PUSH
2156: LD_INT 2
2158: DIV
2159: PUSH
2160: FOR_TO
2161: IFFALSE 2285
// begin x := cesta [ ( i * 2 ) - 1 ] ;
2163: LD_ADDR_VAR 0 2
2167: PUSH
2168: LD_VAR 0 4
2172: PUSH
2173: LD_VAR 0 1
2177: PUSH
2178: LD_INT 2
2180: MUL
2181: PUSH
2182: LD_INT 1
2184: MINUS
2185: ARRAY
2186: ST_TO_ADDR
// y := cesta [ ( i * 2 ) ] ;
2187: LD_ADDR_VAR 0 3
2191: PUSH
2192: LD_VAR 0 4
2196: PUSH
2197: LD_VAR 0 1
2201: PUSH
2202: LD_INT 2
2204: MUL
2205: ARRAY
2206: ST_TO_ADDR
// ComAgressiveMove ( us_patrol_2 , x , y ) ;
2207: LD_EXP 26
2211: PPUSH
2212: LD_VAR 0 2
2216: PPUSH
2217: LD_VAR 0 3
2221: PPUSH
2222: CALL_OW 114
// repeat wait ( 0 0$3 ) ;
2226: LD_INT 105
2228: PPUSH
2229: CALL_OW 67
// y := true ;
2233: LD_ADDR_VAR 0 3
2237: PUSH
2238: LD_INT 1
2240: ST_TO_ADDR
// for x in us_patrol_2 do
2241: LD_ADDR_VAR 0 2
2245: PUSH
2246: LD_EXP 26
2250: PUSH
2251: FOR_IN
2252: IFFALSE 2275
// if IsBusy ( x ) then
2254: LD_VAR 0 2
2258: PPUSH
2259: CALL_OW 315
2263: IFFALSE 2273
// y := false ;
2265: LD_ADDR_VAR 0 3
2269: PUSH
2270: LD_INT 0
2272: ST_TO_ADDR
2273: GO 2251
2275: POP
2276: POP
// until y ;
2277: LD_VAR 0 3
2281: IFFALSE 2226
// end ;
2283: GO 2160
2285: POP
2286: POP
// until ( not us_patrol_2 ) or ( blast_countdown ) ;
2287: LD_EXP 26
2291: NOT
2292: PUSH
2293: LD_EXP 27
2297: OR
2298: IFFALSE 2141
// if us_patrol_2 then
2300: LD_EXP 26
2304: IFFALSE 2344
// begin ComAgressiveMove ( us_patrol_2 , 56 , 77 ) ;
2306: LD_EXP 26
2310: PPUSH
2311: LD_INT 56
2313: PPUSH
2314: LD_INT 77
2316: PPUSH
2317: CALL_OW 114
// us_sol := us_sol ^ us_patrol_2 ;
2321: LD_ADDR_EXP 21
2325: PUSH
2326: LD_EXP 21
2330: PUSH
2331: LD_EXP 26
2335: ADD
2336: ST_TO_ADDR
// us_patrol_2 := [ ] ;
2337: LD_ADDR_EXP 26
2341: PUSH
2342: EMPTY
2343: ST_TO_ADDR
// end ; end ;
2344: PPOPN 4
2346: END
// function prepare_us_patrol ; var i , un , done , sol_lev ; begin
2347: LD_INT 0
2349: PPUSH
2350: PPUSH
2351: PPUSH
2352: PPUSH
2353: PPUSH
// done := 0 ;
2354: LD_ADDR_VAR 0 4
2358: PUSH
2359: LD_INT 0
2361: ST_TO_ADDR
// sol_lev := [ 4 , 5 , 8 ] [ difficulty ] ;
2362: LD_ADDR_VAR 0 5
2366: PUSH
2367: LD_INT 4
2369: PUSH
2370: LD_INT 5
2372: PUSH
2373: LD_INT 8
2375: PUSH
2376: EMPTY
2377: LIST
2378: LIST
2379: LIST
2380: PUSH
2381: LD_OWVAR 67
2385: ARRAY
2386: ST_TO_ADDR
// us_patrol_1 := [ ] ;
2387: LD_ADDR_EXP 25
2391: PUSH
2392: EMPTY
2393: ST_TO_ADDR
// us_patrol_2 := [ ] ;
2394: LD_ADDR_EXP 26
2398: PUSH
2399: EMPTY
2400: ST_TO_ADDR
// uc_nation := nation_american ;
2401: LD_ADDR_OWVAR 21
2405: PUSH
2406: LD_INT 1
2408: ST_TO_ADDR
// uc_side := americans ;
2409: LD_ADDR_OWVAR 20
2413: PUSH
2414: LD_EXP 17
2418: ST_TO_ADDR
// for i = 1 to ( difficulty + 1 ) do
2419: LD_ADDR_VAR 0 2
2423: PUSH
2424: DOUBLE
2425: LD_INT 1
2427: DEC
2428: ST_TO_ADDR
2429: LD_OWVAR 67
2433: PUSH
2434: LD_INT 1
2436: PLUS
2437: PUSH
2438: FOR_TO
2439: IFFALSE 2587
// begin done := done + 1 ;
2441: LD_ADDR_VAR 0 4
2445: PUSH
2446: LD_VAR 0 4
2450: PUSH
2451: LD_INT 1
2453: PLUS
2454: ST_TO_ADDR
// PrepareSoldier ( 0 , sol_lev + Rand ( 0 , 2 ) ) ;
2455: LD_INT 0
2457: PPUSH
2458: LD_VAR 0 5
2462: PUSH
2463: LD_INT 0
2465: PPUSH
2466: LD_INT 2
2468: PPUSH
2469: CALL_OW 12
2473: PLUS
2474: PPUSH
2475: CALL_OW 381
// un := CreateHuman ;
2479: LD_ADDR_VAR 0 3
2483: PUSH
2484: CALL_OW 44
2488: ST_TO_ADDR
// if ( difficulty = 3 ) and ( done > 2 ) then
2489: LD_OWVAR 67
2493: PUSH
2494: LD_INT 3
2496: EQUAL
2497: PUSH
2498: LD_VAR 0 4
2502: PUSH
2503: LD_INT 2
2505: GREATER
2506: AND
2507: IFFALSE 2548
// begin us_patrol_2 := us_patrol_2 ^ un ;
2509: LD_ADDR_EXP 26
2513: PUSH
2514: LD_EXP 26
2518: PUSH
2519: LD_VAR 0 3
2523: ADD
2524: ST_TO_ADDR
// PlaceUnitXYR ( un , 158 , 21 , 2 , false ) ;
2525: LD_VAR 0 3
2529: PPUSH
2530: LD_INT 158
2532: PPUSH
2533: LD_INT 21
2535: PPUSH
2536: LD_INT 2
2538: PPUSH
2539: LD_INT 0
2541: PPUSH
2542: CALL_OW 50
// end else
2546: GO 2585
// begin us_patrol_1 := us_patrol_1 ^ un ;
2548: LD_ADDR_EXP 25
2552: PUSH
2553: LD_EXP 25
2557: PUSH
2558: LD_VAR 0 3
2562: ADD
2563: ST_TO_ADDR
// PlaceUnitXYR ( un , 101 , 39 , 2 , false ) ;
2564: LD_VAR 0 3
2568: PPUSH
2569: LD_INT 101
2571: PPUSH
2572: LD_INT 39
2574: PPUSH
2575: LD_INT 2
2577: PPUSH
2578: LD_INT 0
2580: PPUSH
2581: CALL_OW 50
// end ; end ;
2585: GO 2438
2587: POP
2588: POP
// enable ( 2 ) ;
2589: LD_INT 2
2591: ENABLE_MARKED
// if difficulty = 3 then
2592: LD_OWVAR 67
2596: PUSH
2597: LD_INT 3
2599: EQUAL
2600: IFFALSE 2605
// enable ( 3 ) ;
2602: LD_INT 3
2604: ENABLE_MARKED
// end ;
2605: LD_VAR 0 1
2609: RET
// function prepare_us_base ; var i , un , b_list ; begin
2610: LD_INT 0
2612: PPUSH
2613: PPUSH
2614: PPUSH
2615: PPUSH
// us_sol := [ ] ;
2616: LD_ADDR_EXP 21
2620: PUSH
2621: EMPTY
2622: ST_TO_ADDR
// us_sci := [ ] ;
2623: LD_ADDR_EXP 22
2627: PUSH
2628: EMPTY
2629: ST_TO_ADDR
// uc_nation := nation_american ;
2630: LD_ADDR_OWVAR 21
2634: PUSH
2635: LD_INT 1
2637: ST_TO_ADDR
// uc_side := americans ;
2638: LD_ADDR_OWVAR 20
2642: PUSH
2643: LD_EXP 17
2647: ST_TO_ADDR
// for i = 1 to ( difficulty + 3 ) do
2648: LD_ADDR_VAR 0 2
2652: PUSH
2653: DOUBLE
2654: LD_INT 1
2656: DEC
2657: ST_TO_ADDR
2658: LD_OWVAR 67
2662: PUSH
2663: LD_INT 3
2665: PLUS
2666: PUSH
2667: FOR_TO
2668: IFFALSE 2746
// begin PrepareSoldier ( 0 , [ 3 , 6 , 9 ] [ difficulty ] ) ;
2670: LD_INT 0
2672: PPUSH
2673: LD_INT 3
2675: PUSH
2676: LD_INT 6
2678: PUSH
2679: LD_INT 9
2681: PUSH
2682: EMPTY
2683: LIST
2684: LIST
2685: LIST
2686: PUSH
2687: LD_OWVAR 67
2691: ARRAY
2692: PPUSH
2693: CALL_OW 381
// un := CreateHuman ;
2697: LD_ADDR_VAR 0 3
2701: PUSH
2702: CALL_OW 44
2706: ST_TO_ADDR
// us_sol := us_sol ^ un ;
2707: LD_ADDR_EXP 21
2711: PUSH
2712: LD_EXP 21
2716: PUSH
2717: LD_VAR 0 3
2721: ADD
2722: ST_TO_ADDR
// PlaceUnitXYR ( un , 55 , 75 , 4 , false ) ;
2723: LD_VAR 0 3
2727: PPUSH
2728: LD_INT 55
2730: PPUSH
2731: LD_INT 75
2733: PPUSH
2734: LD_INT 4
2736: PPUSH
2737: LD_INT 0
2739: PPUSH
2740: CALL_OW 50
// end ;
2744: GO 2667
2746: POP
2747: POP
// for i := 1 to 4 do
2748: LD_ADDR_VAR 0 2
2752: PUSH
2753: DOUBLE
2754: LD_INT 1
2756: DEC
2757: ST_TO_ADDR
2758: LD_INT 4
2760: PUSH
2761: FOR_TO
2762: IFFALSE 2829
// begin PrepareScientist ( sex_male , 6 + Rand ( 0 , 3 ) ) ;
2764: LD_INT 1
2766: PPUSH
2767: LD_INT 6
2769: PUSH
2770: LD_INT 0
2772: PPUSH
2773: LD_INT 3
2775: PPUSH
2776: CALL_OW 12
2780: PLUS
2781: PPUSH
2782: CALL_OW 384
// un := CreateHuman ;
2786: LD_ADDR_VAR 0 3
2790: PUSH
2791: CALL_OW 44
2795: ST_TO_ADDR
// us_sci := us_sci ^ un ;
2796: LD_ADDR_EXP 22
2800: PUSH
2801: LD_EXP 22
2805: PUSH
2806: LD_VAR 0 3
2810: ADD
2811: ST_TO_ADDR
// PlaceUnitArea ( un , us_base , false ) ;
2812: LD_VAR 0 3
2816: PPUSH
2817: LD_INT 1
2819: PPUSH
2820: LD_INT 0
2822: PPUSH
2823: CALL_OW 49
// end ;
2827: GO 2761
2829: POP
2830: POP
// PrepareMechanic ( 0 , [ 4 , 6 , 9 ] [ difficulty ] ) ;
2831: LD_INT 0
2833: PPUSH
2834: LD_INT 4
2836: PUSH
2837: LD_INT 6
2839: PUSH
2840: LD_INT 9
2842: PUSH
2843: EMPTY
2844: LIST
2845: LIST
2846: LIST
2847: PUSH
2848: LD_OWVAR 67
2852: ARRAY
2853: PPUSH
2854: CALL_OW 383
// us_mech := CreateHuman ;
2858: LD_ADDR_EXP 23
2862: PUSH
2863: CALL_OW 44
2867: ST_TO_ADDR
// PlaceUnitArea ( us_mech , am_repair , false ) ;
2868: LD_EXP 23
2872: PPUSH
2873: LD_INT 11
2875: PPUSH
2876: LD_INT 0
2878: PPUSH
2879: CALL_OW 49
// ComEnterUnit ( us_mech , crane ) ;
2883: LD_EXP 23
2887: PPUSH
2888: LD_INT 15
2890: PPUSH
2891: CALL_OW 120
// if Stevens then
2895: LD_EXP 5
2899: IFFALSE 2932
// begin PlaceUnitArea ( Stevens , us_base , false ) ;
2901: LD_EXP 5
2905: PPUSH
2906: LD_INT 1
2908: PPUSH
2909: LD_INT 0
2911: PPUSH
2912: CALL_OW 49
// us_sci := us_sci ^ Stevens ;
2916: LD_ADDR_EXP 22
2920: PUSH
2921: LD_EXP 22
2925: PUSH
2926: LD_EXP 5
2930: ADD
2931: ST_TO_ADDR
// end ; ComEnterUnit ( us_sci , us_lab ) ;
2932: LD_EXP 22
2936: PPUSH
2937: LD_INT 1
2939: PPUSH
2940: CALL_OW 120
// b_list := FilterAllUnits ( [ [ f_side , americans ] , [ f_btype , b_bunker ] ] ) ;
2944: LD_ADDR_VAR 0 4
2948: PUSH
2949: LD_INT 22
2951: PUSH
2952: LD_EXP 17
2956: PUSH
2957: EMPTY
2958: LIST
2959: LIST
2960: PUSH
2961: LD_INT 30
2963: PUSH
2964: LD_INT 32
2966: PUSH
2967: EMPTY
2968: LIST
2969: LIST
2970: PUSH
2971: EMPTY
2972: LIST
2973: LIST
2974: PPUSH
2975: CALL_OW 69
2979: ST_TO_ADDR
// for i = 1 to b_list do
2980: LD_ADDR_VAR 0 2
2984: PUSH
2985: DOUBLE
2986: LD_INT 1
2988: DEC
2989: ST_TO_ADDR
2990: LD_VAR 0 4
2994: PUSH
2995: FOR_TO
2996: IFFALSE 3026
// ComEnterUnit ( us_sol [ i ] , b_list [ i ] ) ;
2998: LD_EXP 21
3002: PUSH
3003: LD_VAR 0 2
3007: ARRAY
3008: PPUSH
3009: LD_VAR 0 4
3013: PUSH
3014: LD_VAR 0 2
3018: ARRAY
3019: PPUSH
3020: CALL_OW 120
3024: GO 2995
3026: POP
3027: POP
// us_all_units := FilterAllUnits ( [ [ f_side , americans ] , [ f_type , unit_human ] ] ) ;
3028: LD_ADDR_EXP 24
3032: PUSH
3033: LD_INT 22
3035: PUSH
3036: LD_EXP 17
3040: PUSH
3041: EMPTY
3042: LIST
3043: LIST
3044: PUSH
3045: LD_INT 21
3047: PUSH
3048: LD_INT 1
3050: PUSH
3051: EMPTY
3052: LIST
3053: LIST
3054: PUSH
3055: EMPTY
3056: LIST
3057: LIST
3058: PPUSH
3059: CALL_OW 69
3063: ST_TO_ADDR
// end ;
3064: LD_VAR 0 1
3068: RET
// export function prepare_us_side ; begin
3069: LD_INT 0
3071: PPUSH
// prepare_us_base ;
3072: CALL 2610 0 0
// prepare_us_patrol ;
3076: CALL 2347 0 0
// end ;
3080: LD_VAR 0 1
3084: RET
// every 0 0$1 trigger IsInArea ( truck1 , half_line ) or IsInArea ( truck2 , half_line ) do
3085: LD_EXP 6
3089: PPUSH
3090: LD_INT 5
3092: PPUSH
3093: CALL_OW 308
3097: PUSH
3098: LD_EXP 7
3102: PPUSH
3103: LD_INT 5
3105: PPUSH
3106: CALL_OW 308
3110: OR
3111: IFFALSE 3119
3113: GO 3115
3115: DISABLE
// begin enable ( 1 ) ;
3116: LD_INT 1
3118: ENABLE_MARKED
// end ;
3119: END
// every 0 0$1 trigger FilterUnitsInArea ( us_hunt , [ [ f_side , you ] ] ) marked 1 do var list ;
3120: LD_INT 3
3122: PPUSH
3123: LD_INT 22
3125: PUSH
3126: LD_EXP 16
3130: PUSH
3131: EMPTY
3132: LIST
3133: LIST
3134: PUSH
3135: EMPTY
3136: LIST
3137: PPUSH
3138: CALL_OW 70
3142: IFFALSE 3237
3144: GO 3146
3146: DISABLE
3147: LD_INT 0
3149: PPUSH
// begin list := FilterUnitsInArea ( us_hunt , [ [ f_side , you ] ] ) ;
3150: LD_ADDR_VAR 0 1
3154: PUSH
3155: LD_INT 3
3157: PPUSH
3158: LD_INT 22
3160: PUSH
3161: LD_EXP 16
3165: PUSH
3166: EMPTY
3167: LIST
3168: LIST
3169: PUSH
3170: EMPTY
3171: LIST
3172: PPUSH
3173: CALL_OW 70
3177: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3178: LD_INT 35
3180: PPUSH
3181: CALL_OW 67
// until not FilterUnitsInArea ( us_hunt , [ [ f_side , you ] ] ) ;
3185: LD_INT 3
3187: PPUSH
3188: LD_INT 22
3190: PUSH
3191: LD_EXP 16
3195: PUSH
3196: EMPTY
3197: LIST
3198: LIST
3199: PUSH
3200: EMPTY
3201: LIST
3202: PPUSH
3203: CALL_OW 70
3207: NOT
3208: IFFALSE 3178
// if list then
3210: LD_VAR 0 1
3214: IFFALSE 3229
// American_Hunt ( list [ 1 ] ) ;
3216: LD_VAR 0 1
3220: PUSH
3221: LD_INT 1
3223: ARRAY
3224: PPUSH
3225: CALL 3240 0 1
// if not query_started then
3229: LD_EXP 29
3233: NOT
3234: IFFALSE 3237
// enable ;
3236: ENABLE
// end ;
3237: PPOPN 1
3239: END
// function American_Hunt ( un ) ; var i , b_list ; begin
3240: LD_INT 0
3242: PPUSH
3243: PPUSH
3244: PPUSH
// ComExitBuilding ( us_sol ) ;
3245: LD_EXP 21
3249: PPUSH
3250: CALL_OW 122
// Wait ( 0 0$0.5 ) ;
3254: LD_INT 18
3256: PPUSH
3257: CALL_OW 67
// repeat ComAgressiveMove ( us_sol , GetX ( un ) , GetY ( un ) ) ;
3261: LD_EXP 21
3265: PPUSH
3266: LD_VAR 0 1
3270: PPUSH
3271: CALL_OW 250
3275: PPUSH
3276: LD_VAR 0 1
3280: PPUSH
3281: CALL_OW 251
3285: PPUSH
3286: CALL_OW 114
// wait ( 0 0$1 ) ;
3290: LD_INT 35
3292: PPUSH
3293: CALL_OW 67
// until not See ( americans , un ) or query_started ;
3297: LD_EXP 17
3301: PPUSH
3302: LD_VAR 0 1
3306: PPUSH
3307: CALL_OW 292
3311: NOT
3312: PUSH
3313: LD_EXP 29
3317: OR
3318: IFFALSE 3261
// b_list := FilterAllUnits ( [ [ f_side , americans ] , [ f_btype , b_bunker ] ] ) ;
3320: LD_ADDR_VAR 0 4
3324: PUSH
3325: LD_INT 22
3327: PUSH
3328: LD_EXP 17
3332: PUSH
3333: EMPTY
3334: LIST
3335: LIST
3336: PUSH
3337: LD_INT 30
3339: PUSH
3340: LD_INT 32
3342: PUSH
3343: EMPTY
3344: LIST
3345: LIST
3346: PUSH
3347: EMPTY
3348: LIST
3349: LIST
3350: PPUSH
3351: CALL_OW 69
3355: ST_TO_ADDR
// for i = 1 to us_sol do
3356: LD_ADDR_VAR 0 3
3360: PUSH
3361: DOUBLE
3362: LD_INT 1
3364: DEC
3365: ST_TO_ADDR
3366: LD_EXP 21
3370: PUSH
3371: FOR_TO
3372: IFFALSE 3438
// if i <= ( 0 + b_list ) then
3374: LD_VAR 0 3
3378: PUSH
3379: LD_INT 0
3381: PUSH
3382: LD_VAR 0 4
3386: PLUS
3387: LESSEQUAL
3388: IFFALSE 3418
// ComEnterUnit ( us_sol [ i ] , b_list [ i ] ) else
3390: LD_EXP 21
3394: PUSH
3395: LD_VAR 0 3
3399: ARRAY
3400: PPUSH
3401: LD_VAR 0 4
3405: PUSH
3406: LD_VAR 0 3
3410: ARRAY
3411: PPUSH
3412: CALL_OW 120
3416: GO 3436
// ComMoveToArea ( us_sol [ i ] , parking ) ;
3418: LD_EXP 21
3422: PUSH
3423: LD_VAR 0 3
3427: ARRAY
3428: PPUSH
3429: LD_INT 10
3431: PPUSH
3432: CALL_OW 113
3436: GO 3371
3438: POP
3439: POP
// wait ( 0 0$5 ) ;
3440: LD_INT 175
3442: PPUSH
3443: CALL_OW 67
// end ;
3447: LD_VAR 0 2
3451: RET
// every 0 0$5 marked 7 do var difficulty_time ;
3452: GO 3454
3454: DISABLE
3455: LD_INT 0
3457: PPUSH
// begin difficulty_time := [ 25 25$0 , 15 15$0 , 10 10$0 ] [ difficulty ] ;
3458: LD_ADDR_VAR 0 1
3462: PUSH
3463: LD_INT 52500
3465: PUSH
3466: LD_INT 31500
3468: PUSH
3469: LD_INT 21000
3471: PUSH
3472: EMPTY
3473: LIST
3474: LIST
3475: LIST
3476: PUSH
3477: LD_OWVAR 67
3481: ARRAY
3482: ST_TO_ADDR
// Wait ( difficulty_time ) ;
3483: LD_VAR 0 1
3487: PPUSH
3488: CALL_OW 67
// americans_leaving ;
3492: CALL 3507 0 0
// end ;
3496: PPOPN 1
3498: END
// every 0 0$1 marked 10 do
3499: GO 3501
3501: DISABLE
// begin americans_leaving ;
3502: CALL 3507 0 0
// end ;
3506: END
// function americans_leaving ; var un , list , i , max , vehicles ; begin
3507: LD_INT 0
3509: PPUSH
3510: PPUSH
3511: PPUSH
3512: PPUSH
3513: PPUSH
3514: PPUSH
// keep_base_finished := true ;
3515: LD_ADDR_EXP 15
3519: PUSH
3520: LD_INT 1
3522: ST_TO_ADDR
// ComExitBuilding ( us_sol ) ;
3523: LD_EXP 21
3527: PPUSH
3528: CALL_OW 122
// ComExitBuilding ( us_sci ) ;
3532: LD_EXP 22
3536: PPUSH
3537: CALL_OW 122
// wait ( 0 0$1 ) ;
3541: LD_INT 35
3543: PPUSH
3544: CALL_OW 67
// list := FilterAllUnits ( [ [ f_side , americans ] , [ f_type , unit_human ] ] ) ;
3548: LD_ADDR_VAR 0 3
3552: PUSH
3553: LD_INT 22
3555: PUSH
3556: LD_EXP 17
3560: PUSH
3561: EMPTY
3562: LIST
3563: LIST
3564: PUSH
3565: LD_INT 21
3567: PUSH
3568: LD_INT 1
3570: PUSH
3571: EMPTY
3572: LIST
3573: LIST
3574: PUSH
3575: EMPTY
3576: LIST
3577: LIST
3578: PPUSH
3579: CALL_OW 69
3583: ST_TO_ADDR
// ComMoveToArea ( list , leave_area ) ;
3584: LD_VAR 0 3
3588: PPUSH
3589: LD_INT 8
3591: PPUSH
3592: CALL_OW 113
// vehicles := FilterUnitsInArea ( us_base , [ [ f_side , americans ] , [ f_type , unit_vehicle ] , [ f_not , [ f_occupied ] ] ] ) ;
3596: LD_ADDR_VAR 0 6
3600: PUSH
3601: LD_INT 1
3603: PPUSH
3604: LD_INT 22
3606: PUSH
3607: LD_EXP 17
3611: PUSH
3612: EMPTY
3613: LIST
3614: LIST
3615: PUSH
3616: LD_INT 21
3618: PUSH
3619: LD_INT 2
3621: PUSH
3622: EMPTY
3623: LIST
3624: LIST
3625: PUSH
3626: LD_INT 3
3628: PUSH
3629: LD_INT 59
3631: PUSH
3632: EMPTY
3633: LIST
3634: PUSH
3635: EMPTY
3636: LIST
3637: LIST
3638: PUSH
3639: EMPTY
3640: LIST
3641: LIST
3642: LIST
3643: PPUSH
3644: CALL_OW 70
3648: ST_TO_ADDR
// if ( 0 + vehicles ) < list then
3649: LD_INT 0
3651: PUSH
3652: LD_VAR 0 6
3656: PLUS
3657: PUSH
3658: LD_VAR 0 3
3662: LESS
3663: IFFALSE 3681
// max := 0 + vehicles else
3665: LD_ADDR_VAR 0 5
3669: PUSH
3670: LD_INT 0
3672: PUSH
3673: LD_VAR 0 6
3677: PLUS
3678: ST_TO_ADDR
3679: GO 3695
// max := 0 + list ;
3681: LD_ADDR_VAR 0 5
3685: PUSH
3686: LD_INT 0
3688: PUSH
3689: LD_VAR 0 3
3693: PLUS
3694: ST_TO_ADDR
// if vehicles and list then
3695: LD_VAR 0 6
3699: PUSH
3700: LD_VAR 0 3
3704: AND
3705: IFFALSE 3773
// for i = 1 to max do
3707: LD_ADDR_VAR 0 4
3711: PUSH
3712: DOUBLE
3713: LD_INT 1
3715: DEC
3716: ST_TO_ADDR
3717: LD_VAR 0 5
3721: PUSH
3722: FOR_TO
3723: IFFALSE 3771
// begin ComEnterUnit ( list [ i ] , vehicles [ i ] ) ;
3725: LD_VAR 0 3
3729: PUSH
3730: LD_VAR 0 4
3734: ARRAY
3735: PPUSH
3736: LD_VAR 0 6
3740: PUSH
3741: LD_VAR 0 4
3745: ARRAY
3746: PPUSH
3747: CALL_OW 120
// AddComMoveToArea ( list [ i ] , leave_area ) ;
3751: LD_VAR 0 3
3755: PUSH
3756: LD_VAR 0 4
3760: ARRAY
3761: PPUSH
3762: LD_INT 8
3764: PPUSH
3765: CALL_OW 173
// end ;
3769: GO 3722
3771: POP
3772: POP
// time_out := true ;
3773: LD_ADDR_EXP 10
3777: PUSH
3778: LD_INT 1
3780: ST_TO_ADDR
// enable ( 9 ) ;
3781: LD_INT 9
3783: ENABLE_MARKED
// repeat list := FilterAllUnits ( [ [ f_side , americans ] , [ f_type , unit_human ] , [ f_placed ] , [ f_ok ] ] ) ;
3784: LD_ADDR_VAR 0 3
3788: PUSH
3789: LD_INT 22
3791: PUSH
3792: LD_EXP 17
3796: PUSH
3797: EMPTY
3798: LIST
3799: LIST
3800: PUSH
3801: LD_INT 21
3803: PUSH
3804: LD_INT 1
3806: PUSH
3807: EMPTY
3808: LIST
3809: LIST
3810: PUSH
3811: LD_INT 52
3813: PUSH
3814: EMPTY
3815: LIST
3816: PUSH
3817: LD_INT 50
3819: PUSH
3820: EMPTY
3821: LIST
3822: PUSH
3823: EMPTY
3824: LIST
3825: LIST
3826: LIST
3827: LIST
3828: PPUSH
3829: CALL_OW 69
3833: ST_TO_ADDR
// for un in list do
3834: LD_ADDR_VAR 0 2
3838: PUSH
3839: LD_VAR 0 3
3843: PUSH
3844: FOR_IN
3845: IFFALSE 3873
// if not HasTask ( un ) then
3847: LD_VAR 0 2
3851: PPUSH
3852: CALL_OW 314
3856: NOT
3857: IFFALSE 3871
// ComMoveToArea ( un , leave_area ) ;
3859: LD_VAR 0 2
3863: PPUSH
3864: LD_INT 8
3866: PPUSH
3867: CALL_OW 113
3871: GO 3844
3873: POP
3874: POP
// wait ( 0 0$1 ) ;
3875: LD_INT 35
3877: PPUSH
3878: CALL_OW 67
// until not list ;
3882: LD_VAR 0 3
3886: NOT
3887: IFFALSE 3784
// if not query_started then
3889: LD_EXP 29
3893: NOT
3894: IFFALSE 3903
// Mission_Failed ( 3 ) ;
3896: LD_INT 3
3898: PPUSH
3899: CALL 1474 0 1
// end ;
3903: LD_VAR 0 1
3907: RET
// every 0 0$1 trigger FilterUnitsInArea ( leave_area , [ [ f_side , americans ] ] ) marked 9 do var list , un , max ;
3908: LD_INT 8
3910: PPUSH
3911: LD_INT 22
3913: PUSH
3914: LD_EXP 17
3918: PUSH
3919: EMPTY
3920: LIST
3921: LIST
3922: PUSH
3923: EMPTY
3924: LIST
3925: PPUSH
3926: CALL_OW 70
3930: IFFALSE 4053
3932: GO 3934
3934: DISABLE
3935: LD_INT 0
3937: PPUSH
3938: PPUSH
3939: PPUSH
// begin list := FilterUnitsInArea ( leave_area , [ [ f_side , americans ] ] ) ;
3940: LD_ADDR_VAR 0 1
3944: PUSH
3945: LD_INT 8
3947: PPUSH
3948: LD_INT 22
3950: PUSH
3951: LD_EXP 17
3955: PUSH
3956: EMPTY
3957: LIST
3958: LIST
3959: PUSH
3960: EMPTY
3961: LIST
3962: PPUSH
3963: CALL_OW 70
3967: ST_TO_ADDR
// for un in list do
3968: LD_ADDR_VAR 0 2
3972: PUSH
3973: LD_VAR 0 1
3977: PUSH
3978: FOR_IN
3979: IFFALSE 4050
// begin if un in us_sci then
3981: LD_VAR 0 2
3985: PUSH
3986: LD_EXP 22
3990: IN
3991: IFFALSE 4009
// us_sci := us_sci diff un ;
3993: LD_ADDR_EXP 22
3997: PUSH
3998: LD_EXP 22
4002: PUSH
4003: LD_VAR 0 2
4007: DIFF
4008: ST_TO_ADDR
// max := IsInUnit ( un ) ;
4009: LD_ADDR_VAR 0 3
4013: PUSH
4014: LD_VAR 0 2
4018: PPUSH
4019: CALL_OW 310
4023: ST_TO_ADDR
// RemoveUnit ( un ) ;
4024: LD_VAR 0 2
4028: PPUSH
4029: CALL_OW 64
// if max then
4033: LD_VAR 0 3
4037: IFFALSE 4048
// RemoveUnit ( max ) ;
4039: LD_VAR 0 3
4043: PPUSH
4044: CALL_OW 64
// end ;
4048: GO 3978
4050: POP
4051: POP
// enable ;
4052: ENABLE
// end ; end_of_file
4053: PPOPN 3
4055: END
// on UnitDestroyed ( un ) do begin if GetSide ( un ) = americans then
4056: LD_VAR 0 1
4060: PPUSH
4061: CALL_OW 255
4065: PUSH
4066: LD_EXP 17
4070: EQUAL
4071: IFFALSE 4164
// begin us_patrol_1 := us_patrol_1 diff un ;
4073: LD_ADDR_EXP 25
4077: PUSH
4078: LD_EXP 25
4082: PUSH
4083: LD_VAR 0 1
4087: DIFF
4088: ST_TO_ADDR
// us_patrol_2 := us_patrol_2 diff un ;
4089: LD_ADDR_EXP 26
4093: PUSH
4094: LD_EXP 26
4098: PUSH
4099: LD_VAR 0 1
4103: DIFF
4104: ST_TO_ADDR
// us_sci := us_sci diff un ;
4105: LD_ADDR_EXP 22
4109: PUSH
4110: LD_EXP 22
4114: PUSH
4115: LD_VAR 0 1
4119: DIFF
4120: ST_TO_ADDR
// us_sol := us_sol diff un ;
4121: LD_ADDR_EXP 21
4125: PUSH
4126: LD_EXP 21
4130: PUSH
4131: LD_VAR 0 1
4135: DIFF
4136: ST_TO_ADDR
// if ( not us_sci ) and lab_destroyed and ( not technology_taken ) then
4137: LD_EXP 22
4141: NOT
4142: PUSH
4143: LD_EXP 9
4147: AND
4148: PUSH
4149: LD_EXP 14
4153: NOT
4154: AND
4155: IFFALSE 4164
// Mission_Failed ( 5 ) ;
4157: LD_INT 5
4159: PPUSH
4160: CALL 1474 0 1
// end ; if un = Burlak then
4164: LD_VAR 0 1
4168: PUSH
4169: LD_EXP 2
4173: EQUAL
4174: IFFALSE 4183
// Mission_Failed ( 1 ) ;
4176: LD_INT 1
4178: PPUSH
4179: CALL 1474 0 1
// if un = MacMillan then
4183: LD_VAR 0 1
4187: PUSH
4188: LD_EXP 1
4192: EQUAL
4193: IFFALSE 4202
// Mission_Failed ( 2 ) ;
4195: LD_INT 2
4197: PPUSH
4198: CALL 1474 0 1
// if ( un = us_lab ) then
4202: LD_VAR 0 1
4206: PUSH
4207: LD_INT 1
4209: EQUAL
4210: IFFALSE 4251
// begin lab_destroyed := true ;
4212: LD_ADDR_EXP 9
4216: PUSH
4217: LD_INT 1
4219: ST_TO_ADDR
// if not ( us_sci or technology_taken ) then
4220: LD_EXP 22
4224: PUSH
4225: LD_EXP 14
4229: OR
4230: NOT
4231: IFFALSE 4240
// Mission_Failed ( 5 ) ;
4233: LD_INT 5
4235: PPUSH
4236: CALL 1474 0 1
// if not query_started then
4240: LD_EXP 29
4244: NOT
4245: IFFALSE 4251
// query_kill ;
4247: CALL 6059 0 0
// end ; if ( GetSide ( un ) = you ) and ( GetType ( un ) = unit_vehicle ) and ( GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay ] ) then
4251: LD_VAR 0 1
4255: PPUSH
4256: CALL_OW 255
4260: PUSH
4261: LD_EXP 16
4265: EQUAL
4266: PUSH
4267: LD_VAR 0 1
4271: PPUSH
4272: CALL_OW 247
4276: PUSH
4277: LD_INT 2
4279: EQUAL
4280: AND
4281: PUSH
4282: LD_VAR 0 1
4286: PPUSH
4287: CALL_OW 264
4291: PUSH
4292: LD_INT 12
4294: PUSH
4295: LD_INT 51
4297: PUSH
4298: EMPTY
4299: LIST
4300: LIST
4301: IN
4302: AND
4303: IFFALSE 4312
// Mission_Failed ( 6 ) ;
4305: LD_INT 6
4307: PPUSH
4308: CALL 1474 0 1
// end ;
4312: PPOPN 1
4314: END
// on UnitGoesToRed ( un ) do begin if un in [ Burlak , MacMillan ] and not FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_building ] , [ f_btype , b_lab ] ] ) then
4315: LD_VAR 0 1
4319: PUSH
4320: LD_EXP 2
4324: PUSH
4325: LD_EXP 1
4329: PUSH
4330: EMPTY
4331: LIST
4332: LIST
4333: IN
4334: PUSH
4335: LD_INT 22
4337: PUSH
4338: LD_EXP 16
4342: PUSH
4343: EMPTY
4344: LIST
4345: LIST
4346: PUSH
4347: LD_INT 21
4349: PUSH
4350: LD_INT 3
4352: PUSH
4353: EMPTY
4354: LIST
4355: LIST
4356: PUSH
4357: LD_INT 30
4359: PUSH
4360: LD_INT 6
4362: PUSH
4363: EMPTY
4364: LIST
4365: LIST
4366: PUSH
4367: EMPTY
4368: LIST
4369: LIST
4370: LIST
4371: PPUSH
4372: CALL_OW 69
4376: NOT
4377: AND
4378: IFFALSE 4418
// begin if un = Burlak then
4380: LD_VAR 0 1
4384: PUSH
4385: LD_EXP 2
4389: EQUAL
4390: IFFALSE 4399
// Mission_Failed ( 1 ) ;
4392: LD_INT 1
4394: PPUSH
4395: CALL 1474 0 1
// if un = MacMillan then
4399: LD_VAR 0 1
4403: PUSH
4404: LD_EXP 1
4408: EQUAL
4409: IFFALSE 4418
// Mission_Failed ( 2 ) ;
4411: LD_INT 2
4413: PPUSH
4414: CALL 1474 0 1
// end ; if ( un = us_lab ) and ( not query_started ) then
4418: LD_VAR 0 1
4422: PUSH
4423: LD_INT 1
4425: EQUAL
4426: PUSH
4427: LD_EXP 29
4431: NOT
4432: AND
4433: IFFALSE 4439
// query_kill ;
4435: CALL 6059 0 0
// end ;
4439: PPOPN 1
4441: END
// on BuildingCaptured ( building , orig_side , engeneer ) do begin if ( building = us_depot ) and ( not query_started ) and ( not time_out ) then
4442: LD_VAR 0 1
4446: PUSH
4447: LD_INT 5
4449: EQUAL
4450: PUSH
4451: LD_EXP 29
4455: NOT
4456: AND
4457: PUSH
4458: LD_EXP 10
4462: NOT
4463: AND
4464: IFFALSE 4470
// query_kill ;
4466: CALL 6059 0 0
// if ( building = us_lab ) then
4470: LD_VAR 0 1
4474: PUSH
4475: LD_INT 1
4477: EQUAL
4478: IFFALSE 4492
// begin technology_taken := true ;
4480: LD_ADDR_EXP 14
4484: PUSH
4485: LD_INT 1
4487: ST_TO_ADDR
// konecny_rozhovor ;
4488: CALL 6984 0 0
// end ; end ;
4492: PPOPN 3
4494: END
// on ArtifactLoaded ( un , size ) do begin if not art_picked then
4495: LD_EXP 31
4499: NOT
4500: IFFALSE 4514
// begin art_picked := true ;
4502: LD_ADDR_EXP 31
4506: PUSH
4507: LD_INT 1
4509: ST_TO_ADDR
// Artefact_Picked ;
4510: CALL 5155 0 0
// end ; art_cargo := un ;
4514: LD_ADDR_EXP 32
4518: PUSH
4519: LD_VAR 0 1
4523: ST_TO_ADDR
// end ;
4524: PPOPN 2
4526: END
// on ArtifactUnloaded ( un , size ) do begin art_cargo := false ;
4527: LD_ADDR_EXP 32
4531: PUSH
4532: LD_INT 0
4534: ST_TO_ADDR
// end ; end_of_file
4535: PPOPN 2
4537: END
// every 0 0$2 do var un , animal_out ;
4538: GO 4540
4540: DISABLE
4541: LD_INT 0
4543: PPUSH
4544: PPUSH
// begin animal_out := FilterAllUnits ( [ [ f_nation , nation_nature ] ] ) ;
4545: LD_ADDR_VAR 0 2
4549: PUSH
4550: LD_INT 23
4552: PUSH
4553: LD_INT 0
4555: PUSH
4556: EMPTY
4557: LIST
4558: LIST
4559: PUSH
4560: EMPTY
4561: LIST
4562: PPUSH
4563: CALL_OW 69
4567: ST_TO_ADDR
// ComMoveToArea ( animal_out , nature ) ;
4568: LD_VAR 0 2
4572: PPUSH
4573: LD_INT 2
4575: PPUSH
4576: CALL_OW 113
// enable ;
4580: ENABLE
// end ; end_of_file
4581: PPOPN 2
4583: END
// export blast_done , query_started , contamine , art_picked , art_cargo ; export dokecano ; export function starting_scene ; begin
4584: LD_INT 0
4586: PPUSH
// RevealFogArea ( you , artefact_fog ) ;
4587: LD_EXP 16
4591: PPUSH
4592: LD_INT 4
4594: PPUSH
4595: CALL_OW 332
// CenterNowOnUnits ( [ truck1 , truck2 ] ) ;
4599: LD_EXP 6
4603: PUSH
4604: LD_EXP 7
4608: PUSH
4609: EMPTY
4610: LIST
4611: LIST
4612: PPUSH
4613: CALL_OW 87
// IngameOn ;
4617: CALL_OW 8
// ComMoveXY ( MacMillan , 192 , 82 ) ;
4621: LD_EXP 1
4625: PPUSH
4626: LD_INT 192
4628: PPUSH
4629: LD_INT 82
4631: PPUSH
4632: CALL_OW 111
// ComMoveXY ( Burlak , 193 , 86 ) ;
4636: LD_EXP 2
4640: PPUSH
4641: LD_INT 193
4643: PPUSH
4644: LD_INT 86
4646: PPUSH
4647: CALL_OW 111
// AddComExitVehicle ( [ MacMillan , Burlak ] ) ;
4651: LD_EXP 1
4655: PUSH
4656: LD_EXP 2
4660: PUSH
4661: EMPTY
4662: LIST
4663: LIST
4664: PPUSH
4665: CALL_OW 181
// wait ( 0 0$5 ) ;
4669: LD_INT 175
4671: PPUSH
4672: CALL_OW 67
// IngameOff ;
4676: CALL_OW 9
// DialogueOn ;
4680: CALL_OW 6
// interface_hidden := true ;
4684: LD_ADDR_OWVAR 54
4688: PUSH
4689: LD_INT 1
4691: ST_TO_ADDR
// Say ( Burlak , D2-Bur-1 ) ;
4692: LD_EXP 2
4696: PPUSH
4697: LD_STRING D2-Bur-1
4699: PPUSH
4700: CALL_OW 88
// Say ( MacMillan , D2-JMM-1 ) ;
4704: LD_EXP 1
4708: PPUSH
4709: LD_STRING D2-JMM-1
4711: PPUSH
4712: CALL_OW 88
// Say ( Burlak , D2-Bur-2 ) ;
4716: LD_EXP 2
4720: PPUSH
4721: LD_STRING D2-Bur-2
4723: PPUSH
4724: CALL_OW 88
// SaveForQuickRestart ;
4728: CALL_OW 22
// wait ( 10 ) ;
4732: LD_INT 10
4734: PPUSH
4735: CALL_OW 67
// ChangeMissionObjectives ( MPickup ) ;
4739: LD_STRING MPickup
4741: PPUSH
4742: CALL_OW 337
// interface_hidden := false ;
4746: LD_ADDR_OWVAR 54
4750: PUSH
4751: LD_INT 0
4753: ST_TO_ADDR
// DialogueOff ;
4754: CALL_OW 7
// ComFree ( [ MacMillan , Burlak ] ) ;
4758: LD_EXP 1
4762: PUSH
4763: LD_EXP 2
4767: PUSH
4768: EMPTY
4769: LIST
4770: LIST
4771: PPUSH
4772: CALL_OW 139
// end ;
4776: LD_VAR 0 1
4780: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_see , you ] , [ f_side , americans ] , [ f_type , unit_human ] ] ) do
4781: LD_INT 101
4783: PUSH
4784: LD_EXP 16
4788: PUSH
4789: EMPTY
4790: LIST
4791: LIST
4792: PUSH
4793: LD_INT 22
4795: PUSH
4796: LD_EXP 17
4800: PUSH
4801: EMPTY
4802: LIST
4803: LIST
4804: PUSH
4805: LD_INT 21
4807: PUSH
4808: LD_INT 1
4810: PUSH
4811: EMPTY
4812: LIST
4813: LIST
4814: PUSH
4815: EMPTY
4816: LIST
4817: LIST
4818: LIST
4819: PPUSH
4820: CALL_OW 69
4824: IFFALSE 4928
4826: GO 4828
4828: DISABLE
// begin if blast_done then
4829: LD_EXP 28
4833: IFFALSE 4837
// exit ;
4835: GO 4928
// repeat wait ( 0 0$1 ) ;
4837: LD_INT 35
4839: PPUSH
4840: CALL_OW 67
// until not FilterAllUnits ( [ [ f_see , you ] , [ f_side , americans ] , [ f_type , unit_human ] , [ f_ok ] ] ) ;
4844: LD_INT 101
4846: PUSH
4847: LD_EXP 16
4851: PUSH
4852: EMPTY
4853: LIST
4854: LIST
4855: PUSH
4856: LD_INT 22
4858: PUSH
4859: LD_EXP 17
4863: PUSH
4864: EMPTY
4865: LIST
4866: LIST
4867: PUSH
4868: LD_INT 21
4870: PUSH
4871: LD_INT 1
4873: PUSH
4874: EMPTY
4875: LIST
4876: LIST
4877: PUSH
4878: LD_INT 50
4880: PUSH
4881: EMPTY
4882: LIST
4883: PUSH
4884: EMPTY
4885: LIST
4886: LIST
4887: LIST
4888: LIST
4889: PPUSH
4890: CALL_OW 69
4894: NOT
4895: IFFALSE 4837
// wait ( 0 0$2 ) ;
4897: LD_INT 70
4899: PPUSH
4900: CALL_OW 67
// Say ( Burlak , D3-Bur-1 ) ;
4904: LD_EXP 2
4908: PPUSH
4909: LD_STRING D3-Bur-1
4911: PPUSH
4912: CALL_OW 88
// Say ( MacMillan , D3-JMM-1 ) ;
4916: LD_EXP 1
4920: PPUSH
4921: LD_STRING D3-JMM-1
4923: PPUSH
4924: CALL_OW 88
// end ;
4928: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_see , you ] , [ f_type , unit_building ] ] ) do
4929: LD_INT 101
4931: PUSH
4932: LD_EXP 16
4936: PUSH
4937: EMPTY
4938: LIST
4939: LIST
4940: PUSH
4941: LD_INT 21
4943: PUSH
4944: LD_INT 3
4946: PUSH
4947: EMPTY
4948: LIST
4949: LIST
4950: PUSH
4951: EMPTY
4952: LIST
4953: LIST
4954: PPUSH
4955: CALL_OW 69
4959: IFFALSE 5154
4961: GO 4963
4963: DISABLE
// begin wait ( 0 0$2 ) ;
4964: LD_INT 70
4966: PPUSH
4967: CALL_OW 67
// DialogueOn ;
4971: CALL_OW 6
// interface_hidden := true ;
4975: LD_ADDR_OWVAR 54
4979: PUSH
4980: LD_INT 1
4982: ST_TO_ADDR
// Say ( MacMillan , D3a-JMM-1 ) ;
4983: LD_EXP 1
4987: PPUSH
4988: LD_STRING D3a-JMM-1
4990: PPUSH
4991: CALL_OW 88
// Say ( Burlak , D3a-Bur-1 ) ;
4995: LD_EXP 2
4999: PPUSH
5000: LD_STRING D3a-Bur-1
5002: PPUSH
5003: CALL_OW 88
// Say ( Burlak , D3a-Bur-1a ) ;
5007: LD_EXP 2
5011: PPUSH
5012: LD_STRING D3a-Bur-1a
5014: PPUSH
5015: CALL_OW 88
// SayRadio ( ru_sci , D3a-RSci1-1 ) ;
5019: LD_EXP 3
5023: PPUSH
5024: LD_STRING D3a-RSci1-1
5026: PPUSH
5027: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-1 ) ;
5031: LD_EXP 5
5035: PPUSH
5036: LD_STRING D3a-Huck-1
5038: PPUSH
5039: CALL_OW 94
// SayRadio ( Powell , D3a-Pow-1 ) ;
5043: LD_EXP 4
5047: PPUSH
5048: LD_STRING D3a-Pow-1
5050: PPUSH
5051: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-2 ) ;
5055: LD_EXP 5
5059: PPUSH
5060: LD_STRING D3a-Huck-2
5062: PPUSH
5063: CALL_OW 94
// SayRadio ( Powell , D3a-Pow-2 ) ;
5067: LD_EXP 4
5071: PPUSH
5072: LD_STRING D3a-Pow-2
5074: PPUSH
5075: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-3 ) ;
5079: LD_EXP 5
5083: PPUSH
5084: LD_STRING D3a-Huck-3
5086: PPUSH
5087: CALL_OW 94
// Say ( MacMillan , D3a-JMM-3 ) ;
5091: LD_EXP 1
5095: PPUSH
5096: LD_STRING D3a-JMM-3
5098: PPUSH
5099: CALL_OW 88
// SayRadio ( ru_sci , D3a-RSci1-3 ) ;
5103: LD_EXP 3
5107: PPUSH
5108: LD_STRING D3a-RSci1-3
5110: PPUSH
5111: CALL_OW 94
// Say ( MacMillan , D3a-JMM-4 ) ;
5115: LD_EXP 1
5119: PPUSH
5120: LD_STRING D3a-JMM-4
5122: PPUSH
5123: CALL_OW 88
// Say ( Burlak , D3a-Bur-4 ) ;
5127: LD_EXP 2
5131: PPUSH
5132: LD_STRING D3a-Bur-4
5134: PPUSH
5135: CALL_OW 88
// interface_hidden := false ;
5139: LD_ADDR_OWVAR 54
5143: PUSH
5144: LD_INT 0
5146: ST_TO_ADDR
// DialogueOff ;
5147: CALL_OW 7
// enable ( 4 ) ;
5151: LD_INT 4
5153: ENABLE_MARKED
// end ;
5154: END
// export function Artefact_Picked ; begin
5155: LD_INT 0
5157: PPUSH
// wait ( 5 ) ;
5158: LD_INT 5
5160: PPUSH
5161: CALL_OW 67
// DialogueOn ;
5165: CALL_OW 6
// interface_hidden := true ;
5169: LD_ADDR_OWVAR 54
5173: PUSH
5174: LD_INT 1
5176: ST_TO_ADDR
// Say ( MacMillan , D4-JMM-1 ) ;
5177: LD_EXP 1
5181: PPUSH
5182: LD_STRING D4-JMM-1
5184: PPUSH
5185: CALL_OW 88
// Say ( Burlak , D4-Bur-1 ) ;
5189: LD_EXP 2
5193: PPUSH
5194: LD_STRING D4-Bur-1
5196: PPUSH
5197: CALL_OW 88
// ChangeMissionObjectives ( MReturn ) ;
5201: LD_STRING MReturn
5203: PPUSH
5204: CALL_OW 337
// interface_hidden := false ;
5208: LD_ADDR_OWVAR 54
5212: PUSH
5213: LD_INT 0
5215: ST_TO_ADDR
// DialogueOff ;
5216: CALL_OW 7
// end ;
5220: LD_VAR 0 1
5224: RET
// every 0 0$1 marked 4 do var blast_time ;
5225: GO 5227
5227: DISABLE
5228: LD_INT 0
5230: PPUSH
// begin blast_countdown := true ;
5231: LD_ADDR_EXP 27
5235: PUSH
5236: LD_INT 1
5238: ST_TO_ADDR
// blast_time := TICK + ( [ 6 6$0 , 3 3$0 , 1 1$0 ] [ difficulty ] ) ;
5239: LD_ADDR_VAR 0 1
5243: PUSH
5244: LD_OWVAR 1
5248: PUSH
5249: LD_INT 12600
5251: PUSH
5252: LD_INT 6300
5254: PUSH
5255: LD_INT 2100
5257: PUSH
5258: EMPTY
5259: LIST
5260: LIST
5261: LIST
5262: PUSH
5263: LD_OWVAR 67
5267: ARRAY
5268: PLUS
5269: ST_TO_ADDR
// repeat wait ( 0 0$3 ) ;
5270: LD_INT 105
5272: PPUSH
5273: CALL_OW 67
// until ( TICK > blast_time ) or IsInArea ( truck1 , half_line ) or IsInArea ( truck2 , half_line ) or IsInArea ( truck1 , leave_blast ) or IsInArea ( truck2 , leave_blast ) ;
5277: LD_OWVAR 1
5281: PUSH
5282: LD_VAR 0 1
5286: GREATER
5287: PUSH
5288: LD_EXP 6
5292: PPUSH
5293: LD_INT 5
5295: PPUSH
5296: CALL_OW 308
5300: OR
5301: PUSH
5302: LD_EXP 7
5306: PPUSH
5307: LD_INT 5
5309: PPUSH
5310: CALL_OW 308
5314: OR
5315: PUSH
5316: LD_EXP 6
5320: PPUSH
5321: LD_INT 9
5323: PPUSH
5324: CALL_OW 308
5328: OR
5329: PUSH
5330: LD_EXP 7
5334: PPUSH
5335: LD_INT 9
5337: PPUSH
5338: CALL_OW 308
5342: OR
5343: IFFALSE 5270
// blast_time := tick ;
5345: LD_ADDR_VAR 0 1
5349: PUSH
5350: LD_OWVAR 1
5354: ST_TO_ADDR
// DialogueOn ;
5355: CALL_OW 6
// interface_hidden := true ;
5359: LD_ADDR_OWVAR 54
5363: PUSH
5364: LD_INT 1
5366: ST_TO_ADDR
// CenterOnXY ( 103 , 52 ) ;
5367: LD_INT 103
5369: PPUSH
5370: LD_INT 52
5372: PPUSH
5373: CALL_OW 84
// wait ( 0 0$3 ) ;
5377: LD_INT 105
5379: PPUSH
5380: CALL_OW 67
// PrepareSiberiteRocket ;
5384: CALL_OW 357
// SendSiberiteRocket ( 103 , 52 ) ;
5388: LD_INT 103
5390: PPUSH
5391: LD_INT 52
5393: PPUSH
5394: CALL_OW 429
// interface_hidden := false ;
5398: LD_ADDR_OWVAR 54
5402: PUSH
5403: LD_INT 0
5405: ST_TO_ADDR
// DialogueOff ;
5406: CALL_OW 7
// blast_done := true ;
5410: LD_ADDR_EXP 28
5414: PUSH
5415: LD_INT 1
5417: ST_TO_ADDR
// contamine := TICK + 6000 ;
5418: LD_ADDR_EXP 30
5422: PUSH
5423: LD_OWVAR 1
5427: PUSH
5428: LD_INT 6000
5430: PLUS
5431: ST_TO_ADDR
// wait ( 0 0$4 ) ;
5432: LD_INT 140
5434: PPUSH
5435: CALL_OW 67
// if not IsLive ( Burlak ) then
5439: LD_EXP 2
5443: PPUSH
5444: CALL_OW 300
5448: NOT
5449: IFFALSE 5458
// Mission_Failed ( 1 ) ;
5451: LD_INT 1
5453: PPUSH
5454: CALL 1474 0 1
// if not IsLive ( MacMillan ) then
5458: LD_EXP 1
5462: PPUSH
5463: CALL_OW 300
5467: NOT
5468: IFFALSE 5477
// Mission_Failed ( 2 ) ;
5470: LD_INT 2
5472: PPUSH
5473: CALL 1474 0 1
// if not ( FindArtifact ( 4 ) or art_cargo ) then
5477: LD_INT 4
5479: PPUSH
5480: CALL_OW 469
5484: PUSH
5485: LD_EXP 32
5489: OR
5490: NOT
5491: IFFALSE 5500
// Mission_Failed ( 4 ) ;
5493: LD_INT 4
5495: PPUSH
5496: CALL 1474 0 1
// after_the_blast ;
5500: CALL 5513 0 0
// enable ( 5 ) ;
5504: LD_INT 5
5506: ENABLE_MARKED
// enable ( 7 ) ;
5507: LD_INT 7
5509: ENABLE_MARKED
// end ;
5510: PPOPN 1
5512: END
// function after_the_blast ; begin
5513: LD_INT 0
5515: PPUSH
// blast_was_seen := true ;
5516: LD_ADDR_EXP 8
5520: PUSH
5521: LD_INT 1
5523: ST_TO_ADDR
// DialogueOn ;
5524: CALL_OW 6
// interface_hidden := true ;
5528: LD_ADDR_OWVAR 54
5532: PUSH
5533: LD_INT 1
5535: ST_TO_ADDR
// Say ( MacMillan , D6a-JMM-1 ) ;
5536: LD_EXP 1
5540: PPUSH
5541: LD_STRING D6a-JMM-1
5543: PPUSH
5544: CALL_OW 88
// Say ( Burlak , D6a-Bur-1 ) ;
5548: LD_EXP 2
5552: PPUSH
5553: LD_STRING D6a-Bur-1
5555: PPUSH
5556: CALL_OW 88
// enable ( 8 ) ;
5560: LD_INT 8
5562: ENABLE_MARKED
// Say ( Burlak , D6c-Bur-1 ) ;
5563: LD_EXP 2
5567: PPUSH
5568: LD_STRING D6c-Bur-1
5570: PPUSH
5571: CALL_OW 88
// Say ( MacMillan , D6c-JMM-1 ) ;
5575: LD_EXP 1
5579: PPUSH
5580: LD_STRING D6c-JMM-1
5582: PPUSH
5583: CALL_OW 88
// ChangeMissionObjectives ( MBase ) ;
5587: LD_STRING MBase
5589: PPUSH
5590: CALL_OW 337
// interface_hidden := false ;
5594: LD_ADDR_OWVAR 54
5598: PUSH
5599: LD_INT 0
5601: ST_TO_ADDR
// DialogueOff ;
5602: CALL_OW 7
// enable ( 6 ) ;
5606: LD_INT 6
5608: ENABLE_MARKED
// end ;
5609: LD_VAR 0 1
5613: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , you ] , [ f_distxy , 103 , 52 , 27 ] ] ) marked 8 do
5614: LD_INT 22
5616: PUSH
5617: LD_EXP 16
5621: PUSH
5622: EMPTY
5623: LIST
5624: LIST
5625: PUSH
5626: LD_INT 92
5628: PUSH
5629: LD_INT 103
5631: PUSH
5632: LD_INT 52
5634: PUSH
5635: LD_INT 27
5637: PUSH
5638: EMPTY
5639: LIST
5640: LIST
5641: LIST
5642: LIST
5643: PUSH
5644: EMPTY
5645: LIST
5646: LIST
5647: PPUSH
5648: CALL_OW 69
5652: IFFALSE 5723
5654: GO 5656
5656: DISABLE
// begin CenterOnUnits ( [ MacMillan , Burlak ] ) ;
5657: LD_EXP 1
5661: PUSH
5662: LD_EXP 2
5666: PUSH
5667: EMPTY
5668: LIST
5669: LIST
5670: PPUSH
5671: CALL_OW 85
// DialogueOn ;
5675: CALL_OW 6
// interface_hidden := true ;
5679: LD_ADDR_OWVAR 54
5683: PUSH
5684: LD_INT 1
5686: ST_TO_ADDR
// Say ( MacMillan , D6b-JMM-1 ) ;
5687: LD_EXP 1
5691: PPUSH
5692: LD_STRING D6b-JMM-1
5694: PPUSH
5695: CALL_OW 88
// Say ( Burlak , D6b-Bur-1 ) ;
5699: LD_EXP 2
5703: PPUSH
5704: LD_STRING D6b-Bur-1
5706: PPUSH
5707: CALL_OW 88
// interface_hidden := false ;
5711: LD_ADDR_OWVAR 54
5715: PUSH
5716: LD_INT 0
5718: ST_TO_ADDR
// DialogueOff ;
5719: CALL_OW 7
// end ;
5723: END
// every 0 0$1 trigger IsInArea ( MacMillan , blast_area ) and ( contamine > TICK ) marked 6 do
5724: LD_EXP 1
5728: PPUSH
5729: LD_INT 6
5731: PPUSH
5732: CALL_OW 308
5736: PUSH
5737: LD_EXP 30
5741: PUSH
5742: LD_OWVAR 1
5746: GREATER
5747: AND
5748: IFFALSE 5806
5750: GO 5752
5752: DISABLE
// begin CenterOnUnits ( MacMillan ) ;
5753: LD_EXP 1
5757: PPUSH
5758: CALL_OW 85
// DialogueOn ;
5762: CALL_OW 6
// interface_hidden := true ;
5766: LD_ADDR_OWVAR 54
5770: PUSH
5771: LD_INT 1
5773: ST_TO_ADDR
// Say ( MacMillan , D7-JMM-1 ) ;
5774: LD_EXP 1
5778: PPUSH
5779: LD_STRING D7-JMM-1
5781: PPUSH
5782: CALL_OW 88
// interface_hidden := false ;
5786: LD_ADDR_OWVAR 54
5790: PUSH
5791: LD_INT 0
5793: ST_TO_ADDR
// DialogueOff ;
5794: CALL_OW 7
// entered_contaminated_area := true ;
5798: LD_ADDR_EXP 11
5802: PUSH
5803: LD_INT 1
5805: ST_TO_ADDR
// end ;
5806: END
// every 0 0$1 trigger IsInArea ( Burlak , blast_area ) and ( contamine > TICK ) marked 6 do
5807: LD_EXP 2
5811: PPUSH
5812: LD_INT 6
5814: PPUSH
5815: CALL_OW 308
5819: PUSH
5820: LD_EXP 30
5824: PUSH
5825: LD_OWVAR 1
5829: GREATER
5830: AND
5831: IFFALSE 5889
5833: GO 5835
5835: DISABLE
// begin CenterOnUnits ( Burlak ) ;
5836: LD_EXP 2
5840: PPUSH
5841: CALL_OW 85
// DialogueOn ;
5845: CALL_OW 6
// interface_hidden := true ;
5849: LD_ADDR_OWVAR 54
5853: PUSH
5854: LD_INT 1
5856: ST_TO_ADDR
// Say ( Burlak , D7-Bur-1 ) ;
5857: LD_EXP 2
5861: PPUSH
5862: LD_STRING D7-Bur-1
5864: PPUSH
5865: CALL_OW 88
// interface_hidden := false ;
5869: LD_ADDR_OWVAR 54
5873: PUSH
5874: LD_INT 0
5876: ST_TO_ADDR
// DialogueOff ;
5877: CALL_OW 7
// entered_contaminated_area := true ;
5881: LD_ADDR_EXP 11
5885: PUSH
5886: LD_INT 1
5888: ST_TO_ADDR
// end ;
5889: END
// every 0 0$10 marked 5 do var time_limit , warning_time ;
5890: GO 5892
5892: DISABLE
5893: LD_INT 0
5895: PPUSH
5896: PPUSH
// begin time_limit := [ 5 5$0 , 4 4$0 , 3 3$0 ] ;
5897: LD_ADDR_VAR 0 1
5901: PUSH
5902: LD_INT 10500
5904: PUSH
5905: LD_INT 8400
5907: PUSH
5908: LD_INT 6300
5910: PUSH
5911: EMPTY
5912: LIST
5913: LIST
5914: LIST
5915: ST_TO_ADDR
// warning_time := TICK + time_limit [ difficulty ] ;
5916: LD_ADDR_VAR 0 2
5920: PUSH
5921: LD_OWVAR 1
5925: PUSH
5926: LD_VAR 0 1
5930: PUSH
5931: LD_OWVAR 67
5935: ARRAY
5936: PLUS
5937: ST_TO_ADDR
// repeat wait ( 0 0$10 ) ;
5938: LD_INT 350
5940: PPUSH
5941: CALL_OW 67
// until TICK > warning_time ;
5945: LD_OWVAR 1
5949: PUSH
5950: LD_VAR 0 2
5954: GREATER
5955: IFFALSE 5938
// if ( not query_started ) or ( not technology_taken ) then
5957: LD_EXP 29
5961: NOT
5962: PUSH
5963: LD_EXP 14
5967: NOT
5968: OR
5969: IFFALSE 5983
// Say ( MacMillan , D8-JMM-1 ) ;
5971: LD_EXP 1
5975: PPUSH
5976: LD_STRING D8-JMM-1
5978: PPUSH
5979: CALL_OW 88
// end ;
5983: PPOPN 2
5985: END
// every 0 0$2 trigger See ( you , oil_2 ) do
5986: LD_EXP 16
5990: PPUSH
5991: LD_INT 9
5993: PPUSH
5994: CALL_OW 292
5998: IFFALSE 6058
6000: GO 6002
6002: DISABLE
// begin CenterOnUnits ( oil_2 ) ;
6003: LD_INT 9
6005: PPUSH
6006: CALL_OW 85
// DialogueOn ;
6010: CALL_OW 6
// interface_hidden := true ;
6014: LD_ADDR_OWVAR 54
6018: PUSH
6019: LD_INT 1
6021: ST_TO_ADDR
// Say ( Burlak , D9-Bur-1 ) ;
6022: LD_EXP 2
6026: PPUSH
6027: LD_STRING D9-Bur-1
6029: PPUSH
6030: CALL_OW 88
// Say ( MacMillan , D9-JMM-1 ) ;
6034: LD_EXP 1
6038: PPUSH
6039: LD_STRING D9-JMM-1
6041: PPUSH
6042: CALL_OW 88
// interface_hidden := false ;
6046: LD_ADDR_OWVAR 54
6050: PUSH
6051: LD_INT 0
6053: ST_TO_ADDR
// DialogueOff ;
6054: CALL_OW 7
// end ;
6058: END
// export function query_kill ; var odpoved ; begin
6059: LD_INT 0
6061: PPUSH
6062: PPUSH
// query_started := true ;
6063: LD_ADDR_EXP 29
6067: PUSH
6068: LD_INT 1
6070: ST_TO_ADDR
// if Query ( QKill ) = 1 then
6071: LD_STRING QKill
6073: PPUSH
6074: CALL_OW 97
6078: PUSH
6079: LD_INT 1
6081: EQUAL
6082: IFFALSE 6090
// query_vyjednavat else
6084: CALL 6099 0 0
6088: GO 6094
// query_pozabijet ;
6090: CALL 6606 0 0
// end ;
6094: LD_VAR 0 1
6098: RET
// function query_vyjednavat ; var un , vedci , list ; begin
6099: LD_INT 0
6101: PPUSH
6102: PPUSH
6103: PPUSH
6104: PPUSH
// SetAttitude ( you , americans , att_friend , true ) ;
6105: LD_EXP 16
6109: PPUSH
6110: LD_EXP 17
6114: PPUSH
6115: LD_INT 1
6117: PPUSH
6118: LD_INT 1
6120: PPUSH
6121: CALL_OW 80
// list := FilterAllUnits ( [ [ f_side , americans ] , [ f_type , unit_human ] ] ) ;
6125: LD_ADDR_VAR 0 4
6129: PUSH
6130: LD_INT 22
6132: PUSH
6133: LD_EXP 17
6137: PUSH
6138: EMPTY
6139: LIST
6140: LIST
6141: PUSH
6142: LD_INT 21
6144: PUSH
6145: LD_INT 1
6147: PUSH
6148: EMPTY
6149: LIST
6150: LIST
6151: PUSH
6152: EMPTY
6153: LIST
6154: LIST
6155: PPUSH
6156: CALL_OW 69
6160: ST_TO_ADDR
// for un in list do
6161: LD_ADDR_VAR 0 2
6165: PUSH
6166: LD_VAR 0 4
6170: PUSH
6171: FOR_IN
6172: IFFALSE 6253
// if not IsInUnit ( un ) then
6174: LD_VAR 0 2
6178: PPUSH
6179: CALL_OW 310
6183: NOT
6184: IFFALSE 6251
// ComMoveXY ( un , ShiftX ( GetX ( un ) , GetDir ( un ) , 1 ) , ShiftY ( GetY ( un ) , GetDir ( un ) , 1 ) ) ;
6186: LD_VAR 0 2
6190: PPUSH
6191: LD_VAR 0 2
6195: PPUSH
6196: CALL_OW 250
6200: PPUSH
6201: LD_VAR 0 2
6205: PPUSH
6206: CALL_OW 254
6210: PPUSH
6211: LD_INT 1
6213: PPUSH
6214: CALL_OW 272
6218: PPUSH
6219: LD_VAR 0 2
6223: PPUSH
6224: CALL_OW 251
6228: PPUSH
6229: LD_VAR 0 2
6233: PPUSH
6234: CALL_OW 254
6238: PPUSH
6239: LD_INT 1
6241: PPUSH
6242: CALL_OW 273
6246: PPUSH
6247: CALL_OW 111
6251: GO 6171
6253: POP
6254: POP
// Wait ( 10 ) ;
6255: LD_INT 10
6257: PPUSH
6258: CALL_OW 67
// CenterOnUnits ( [ us_lab ] ) ;
6262: LD_INT 1
6264: PUSH
6265: EMPTY
6266: LIST
6267: PPUSH
6268: CALL_OW 85
// InGameOn ;
6272: CALL_OW 8
// if GetLives ( us_lab ) > 300 then
6276: LD_INT 1
6278: PPUSH
6279: CALL_OW 256
6283: PUSH
6284: LD_INT 300
6286: GREATER
6287: IFFALSE 6298
// ComExitBuilding ( us_sci ) ;
6289: LD_EXP 22
6293: PPUSH
6294: CALL_OW 122
// Check_Heroes ;
6298: CALL 7164 0 0
// Say ( Burlak , D10a-Bur-1 ) ;
6302: LD_EXP 2
6306: PPUSH
6307: LD_STRING D10a-Bur-1
6309: PPUSH
6310: CALL_OW 88
// if original_stevens then
6314: LD_EXP 12
6318: IFFALSE 6400
// begin if GetDistUnitArea ( Burlak , us_base ) = 0 then
6320: LD_EXP 2
6324: PPUSH
6325: LD_INT 1
6327: PPUSH
6328: CALL_OW 299
6332: PUSH
6333: LD_INT 0
6335: EQUAL
6336: IFFALSE 6354
// ComMoveUnit ( Stevens , Burlak ) else
6338: LD_EXP 5
6342: PPUSH
6343: LD_EXP 2
6347: PPUSH
6348: CALL_OW 112
6352: GO 6368
// ComMoveUnit ( Stevens , MacMillan ) ;
6354: LD_EXP 5
6358: PPUSH
6359: LD_EXP 1
6363: PPUSH
6364: CALL_OW 112
// Say ( Stevens , D10a-Huck-1 ) ;
6368: LD_EXP 5
6372: PPUSH
6373: LD_STRING D10a-Huck-1
6375: PPUSH
6376: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
6380: LD_INT 35
6382: PPUSH
6383: CALL_OW 67
// until IsBusy ( Stevens ) ;
6387: LD_EXP 5
6391: PPUSH
6392: CALL_OW 315
6396: IFFALSE 6380
// end else
6398: GO 6544
// begin vedci := FilterAllUnits ( [ [ f_side , americans ] , [ f_class , class_scientistic ] ] ) ;
6400: LD_ADDR_VAR 0 3
6404: PUSH
6405: LD_INT 22
6407: PUSH
6408: LD_EXP 17
6412: PUSH
6413: EMPTY
6414: LIST
6415: LIST
6416: PUSH
6417: LD_INT 25
6419: PUSH
6420: LD_INT 4
6422: PUSH
6423: EMPTY
6424: LIST
6425: LIST
6426: PUSH
6427: EMPTY
6428: LIST
6429: LIST
6430: PPUSH
6431: CALL_OW 69
6435: ST_TO_ADDR
// if vedci then
6436: LD_VAR 0 3
6440: IFFALSE 6458
// un := vedci [ 1 ] else
6442: LD_ADDR_VAR 0 2
6446: PUSH
6447: LD_VAR 0 3
6451: PUSH
6452: LD_INT 1
6454: ARRAY
6455: ST_TO_ADDR
6456: GO 6466
// un := 0 ;
6458: LD_ADDR_VAR 0 2
6462: PUSH
6463: LD_INT 0
6465: ST_TO_ADDR
// Say ( un , D10a-Sci1-1 ) ;
6466: LD_VAR 0 2
6470: PPUSH
6471: LD_STRING D10a-Sci1-1
6473: PPUSH
6474: CALL_OW 88
// if GetDistUnitArea ( Burlak , us_base ) = 0 then
6478: LD_EXP 2
6482: PPUSH
6483: LD_INT 1
6485: PPUSH
6486: CALL_OW 299
6490: PUSH
6491: LD_INT 0
6493: EQUAL
6494: IFFALSE 6512
// ComMoveUnit ( un , Burlak ) else
6496: LD_VAR 0 2
6500: PPUSH
6501: LD_EXP 2
6505: PPUSH
6506: CALL_OW 112
6510: GO 6526
// ComMoveUnit ( un , MacMillan ) ;
6512: LD_VAR 0 2
6516: PPUSH
6517: LD_EXP 1
6521: PPUSH
6522: CALL_OW 112
// repeat wait ( 0 0$1 ) ;
6526: LD_INT 35
6528: PPUSH
6529: CALL_OW 67
// until IsBusy ( un ) ;
6533: LD_VAR 0 2
6537: PPUSH
6538: CALL_OW 315
6542: IFFALSE 6526
// end ; ComStop ( un ) ;
6544: LD_VAR 0 2
6548: PPUSH
6549: CALL_OW 141
// Say ( Burlak , D10a-Bur-2 ) ;
6553: LD_EXP 2
6557: PPUSH
6558: LD_STRING D10a-Bur-2
6560: PPUSH
6561: CALL_OW 88
// technology_taken := true ;
6565: LD_ADDR_EXP 14
6569: PUSH
6570: LD_INT 1
6572: ST_TO_ADDR
// InGameOff ;
6573: CALL_OW 9
// SetAttitude ( you , americans , att_neutral , true ) ;
6577: LD_EXP 16
6581: PPUSH
6582: LD_EXP 17
6586: PPUSH
6587: LD_INT 0
6589: PPUSH
6590: LD_INT 1
6592: PPUSH
6593: CALL_OW 80
// konecny_rozhovor ;
6597: CALL 6984 0 0
// end ;
6601: LD_VAR 0 1
6605: RET
// function query_pozabijet ; var un , list , defenders , intruders ; begin
6606: LD_INT 0
6608: PPUSH
6609: PPUSH
6610: PPUSH
6611: PPUSH
6612: PPUSH
// Check_Heroes ;
6613: CALL 7164 0 0
// DialogueOn ;
6617: CALL_OW 6
// interface_hidden := true ;
6621: LD_ADDR_OWVAR 54
6625: PUSH
6626: LD_INT 1
6628: ST_TO_ADDR
// Say ( MacMillan , D10b-JMM-1 ) ;
6629: LD_EXP 1
6633: PPUSH
6634: LD_STRING D10b-JMM-1
6636: PPUSH
6637: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , americans ] , [ f_btype , b_warehouse ] ] ) then
6641: LD_INT 22
6643: PUSH
6644: LD_EXP 17
6648: PUSH
6649: EMPTY
6650: LIST
6651: LIST
6652: PUSH
6653: LD_INT 30
6655: PUSH
6656: LD_INT 1
6658: PUSH
6659: EMPTY
6660: LIST
6661: LIST
6662: PUSH
6663: EMPTY
6664: LIST
6665: LIST
6666: PPUSH
6667: CALL_OW 69
6671: IFFALSE 6685
// Say ( Burlak , D10b-Bur-1 ) ;
6673: LD_EXP 2
6677: PPUSH
6678: LD_STRING D10b-Bur-1
6680: PPUSH
6681: CALL_OW 88
// interface_hidden := false ;
6685: LD_ADDR_OWVAR 54
6689: PUSH
6690: LD_INT 0
6692: ST_TO_ADDR
// DialogueOff ;
6693: CALL_OW 7
// enable ( 9 ) ;
6697: LD_INT 9
6699: ENABLE_MARKED
// repeat ComMoveToArea ( us_sci , leave_area ) ;
6700: LD_EXP 22
6704: PPUSH
6705: LD_INT 8
6707: PPUSH
6708: CALL_OW 113
// defenders := FilterAllUnits ( [ [ f_side , americans ] , [ f_class , class_soldier ] ] ) ;
6712: LD_ADDR_VAR 0 4
6716: PUSH
6717: LD_INT 22
6719: PUSH
6720: LD_EXP 17
6724: PUSH
6725: EMPTY
6726: LIST
6727: LIST
6728: PUSH
6729: LD_INT 25
6731: PUSH
6732: LD_INT 1
6734: PUSH
6735: EMPTY
6736: LIST
6737: LIST
6738: PUSH
6739: EMPTY
6740: LIST
6741: LIST
6742: PPUSH
6743: CALL_OW 69
6747: ST_TO_ADDR
// intruders := FilterUnitsInArea ( us_base , [ [ f_side , you ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
6748: LD_ADDR_VAR 0 5
6752: PUSH
6753: LD_INT 1
6755: PPUSH
6756: LD_INT 22
6758: PUSH
6759: LD_EXP 16
6763: PUSH
6764: EMPTY
6765: LIST
6766: LIST
6767: PUSH
6768: LD_INT 2
6770: PUSH
6771: LD_INT 21
6773: PUSH
6774: LD_INT 1
6776: PUSH
6777: EMPTY
6778: LIST
6779: LIST
6780: PUSH
6781: LD_INT 21
6783: PUSH
6784: LD_INT 2
6786: PUSH
6787: EMPTY
6788: LIST
6789: LIST
6790: PUSH
6791: EMPTY
6792: LIST
6793: LIST
6794: LIST
6795: PUSH
6796: EMPTY
6797: LIST
6798: LIST
6799: PPUSH
6800: CALL_OW 70
6804: ST_TO_ADDR
// if intruders then
6805: LD_VAR 0 5
6809: IFFALSE 6829
// ComAttackUnit ( defenders , intruders [ 1 ] ) ;
6811: LD_VAR 0 4
6815: PPUSH
6816: LD_VAR 0 5
6820: PUSH
6821: LD_INT 1
6823: ARRAY
6824: PPUSH
6825: CALL_OW 115
// wait ( 0 0$1 ) ;
6829: LD_INT 35
6831: PPUSH
6832: CALL_OW 67
// until ( not us_sci ) or lab_destroyed or ( not intruders ) ;
6836: LD_EXP 22
6840: NOT
6841: PUSH
6842: LD_EXP 9
6846: OR
6847: PUSH
6848: LD_VAR 0 5
6852: NOT
6853: OR
6854: IFFALSE 6700
// ComExitBuilding ( defenders ) ;
6856: LD_VAR 0 4
6860: PPUSH
6861: CALL_OW 122
// repeat list := FilterAllUnits ( [ [ f_see , americans ] , [ f_side , you ] ] ) ;
6865: LD_ADDR_VAR 0 3
6869: PUSH
6870: LD_INT 101
6872: PUSH
6873: LD_EXP 17
6877: PUSH
6878: EMPTY
6879: LIST
6880: LIST
6881: PUSH
6882: LD_INT 22
6884: PUSH
6885: LD_EXP 16
6889: PUSH
6890: EMPTY
6891: LIST
6892: LIST
6893: PUSH
6894: EMPTY
6895: LIST
6896: LIST
6897: PPUSH
6898: CALL_OW 69
6902: ST_TO_ADDR
// if list then
6903: LD_VAR 0 3
6907: IFFALSE 6929
// ComAttackUnit ( defenders , list [ 1 ] ) else
6909: LD_VAR 0 4
6913: PPUSH
6914: LD_VAR 0 3
6918: PUSH
6919: LD_INT 1
6921: ARRAY
6922: PPUSH
6923: CALL_OW 115
6927: GO 6954
// if GetLives ( us_lab ) > 1 then
6929: LD_INT 1
6931: PPUSH
6932: CALL_OW 256
6936: PUSH
6937: LD_INT 1
6939: GREATER
6940: IFFALSE 6954
// ComAttackUnit ( defenders , us_lab ) ;
6942: LD_VAR 0 4
6946: PPUSH
6947: LD_INT 1
6949: PPUSH
6950: CALL_OW 115
// wait ( 0 0$1 ) ;
6954: LD_INT 35
6956: PPUSH
6957: CALL_OW 67
// until lab_destroyed ;
6961: LD_EXP 9
6965: IFFALSE 6865
// ComMoveToArea ( defenders , leave_area ) ;
6967: LD_VAR 0 4
6971: PPUSH
6972: LD_INT 8
6974: PPUSH
6975: CALL_OW 113
// end ;
6979: LD_VAR 0 1
6983: RET
// export function konecny_rozhovor ; var art_ready ; begin
6984: LD_INT 0
6986: PPUSH
6987: PPUSH
// if not dokecano then
6988: LD_EXP 33
6992: NOT
6993: IFFALSE 7052
// begin dokecano := true ;
6995: LD_ADDR_EXP 33
6999: PUSH
7000: LD_INT 1
7002: ST_TO_ADDR
// DialogueOn ;
7003: CALL_OW 6
// interface_hidden := true ;
7007: LD_ADDR_OWVAR 54
7011: PUSH
7012: LD_INT 1
7014: ST_TO_ADDR
// Say ( Burlak , D11-Bur-1 ) ;
7015: LD_EXP 2
7019: PPUSH
7020: LD_STRING D11-Bur-1
7022: PPUSH
7023: CALL_OW 88
// ChangeMissionObjectives ( MEnd ) ;
7027: LD_STRING MEnd
7029: PPUSH
7030: CALL_OW 337
// enable ( 10 ) ;
7034: LD_INT 10
7036: ENABLE_MARKED
// disable ( 1 ) ;
7037: LD_INT 1
7039: DISABLE_MARKED
// interface_hidden := false ;
7040: LD_ADDR_OWVAR 54
7044: PUSH
7045: LD_INT 0
7047: ST_TO_ADDR
// DialogueOff ;
7048: CALL_OW 7
// end ; SetAreaMapShow ( exit_area , 1 ) ;
7052: LD_INT 12
7054: PPUSH
7055: LD_INT 1
7057: PPUSH
7058: CALL_OW 424
// repeat wait ( 0 0$2 ) ;
7062: LD_INT 70
7064: PPUSH
7065: CALL_OW 67
// if art_cargo and not IsInArea ( art_cargo , us_base ) then
7069: LD_EXP 32
7073: PUSH
7074: LD_EXP 32
7078: PPUSH
7079: LD_INT 1
7081: PPUSH
7082: CALL_OW 308
7086: NOT
7087: AND
7088: IFFALSE 7100
// art_ready := true else
7090: LD_ADDR_VAR 0 2
7094: PUSH
7095: LD_INT 1
7097: ST_TO_ADDR
7098: GO 7108
// art_ready := false ;
7100: LD_ADDR_VAR 0 2
7104: PUSH
7105: LD_INT 0
7107: ST_TO_ADDR
// until not ( IsInArea ( MacMillan , us_base ) or IsInArea ( Burlak , us_base ) or not art_ready ) ;
7108: LD_EXP 1
7112: PPUSH
7113: LD_INT 1
7115: PPUSH
7116: CALL_OW 308
7120: PUSH
7121: LD_EXP 2
7125: PPUSH
7126: LD_INT 1
7128: PPUSH
7129: CALL_OW 308
7133: OR
7134: PUSH
7135: LD_VAR 0 2
7139: NOT
7140: OR
7141: NOT
7142: IFFALSE 7062
// wait ( 0 0$2 ) ;
7144: LD_INT 70
7146: PPUSH
7147: CALL_OW 67
// konec_mise ;
7151: CALL 1112 0 0
// DialogueOff ;
7155: CALL_OW 7
// end ;
7159: LD_VAR 0 1
7163: RET
// function Check_Heroes ; begin
7164: LD_INT 0
7166: PPUSH
// if not IsOK ( MacMillan ) then
7167: LD_EXP 1
7171: PPUSH
7172: CALL_OW 302
7176: NOT
7177: IFFALSE 7186
// YouLost ( 2 ) ;
7179: LD_INT 2
7181: PPUSH
7182: CALL_OW 104
// if not IsOK ( Burlak ) then
7186: LD_EXP 2
7190: PPUSH
7191: CALL_OW 302
7195: NOT
7196: IFFALSE 7205
// YouLost ( 1 ) ;
7198: LD_INT 1
7200: PPUSH
7201: CALL_OW 104
// end ; end_of_file
7205: LD_VAR 0 1
7209: RET
// every 0 0$1 marked 7 do var list , un ;
7210: GO 7212
7212: DISABLE
7213: LD_INT 0
7215: PPUSH
7216: PPUSH
// begin list := FilterAllUnits ( [ [ f_side , americans ] , [ f_type , unit_building ] , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] , f_not , [ f_lives , 1000 ] ] ) ;
7217: LD_ADDR_VAR 0 1
7221: PUSH
7222: LD_INT 22
7224: PUSH
7225: LD_EXP 17
7229: PUSH
7230: EMPTY
7231: LIST
7232: LIST
7233: PUSH
7234: LD_INT 21
7236: PUSH
7237: LD_INT 3
7239: PUSH
7240: EMPTY
7241: LIST
7242: LIST
7243: PUSH
7244: LD_INT 2
7246: PUSH
7247: LD_INT 30
7249: PUSH
7250: LD_INT 33
7252: PUSH
7253: EMPTY
7254: LIST
7255: LIST
7256: PUSH
7257: LD_INT 30
7259: PUSH
7260: LD_INT 32
7262: PUSH
7263: EMPTY
7264: LIST
7265: LIST
7266: PUSH
7267: EMPTY
7268: LIST
7269: LIST
7270: LIST
7271: PUSH
7272: LD_INT 3
7274: PUSH
7275: LD_INT 24
7277: PUSH
7278: LD_INT 1000
7280: PUSH
7281: EMPTY
7282: LIST
7283: LIST
7284: PUSH
7285: EMPTY
7286: LIST
7287: LIST
7288: LIST
7289: LIST
7290: LIST
7291: PPUSH
7292: CALL_OW 69
7296: ST_TO_ADDR
// if list then
7297: LD_VAR 0 1
7301: IFFALSE 7312
// repair_base ( list ) ;
7303: LD_VAR 0 1
7307: PPUSH
7308: CALL 7323 0 1
// if not keep_base_finished then
7312: LD_EXP 15
7316: NOT
7317: IFFALSE 7320
// enable ;
7319: ENABLE
// end ;
7320: PPOPN 2
7322: END
// function repair_base ( list ) ; var un , driver ; begin
7323: LD_INT 0
7325: PPUSH
7326: PPUSH
7327: PPUSH
// repeat if keep_base_finished then
7328: LD_EXP 15
7332: IFFALSE 7336
// exit ;
7334: GO 7528
// if list then
7336: LD_VAR 0 1
7340: IFFALSE 7360
// ComRepairBuilding ( crane , list [ 1 ] ) else
7342: LD_INT 15
7344: PPUSH
7345: LD_VAR 0 1
7349: PUSH
7350: LD_INT 1
7352: ARRAY
7353: PPUSH
7354: CALL_OW 130
7358: GO 7362
// exit ;
7360: GO 7528
// if GetLives ( crane ) < 700 then
7362: LD_INT 15
7364: PPUSH
7365: CALL_OW 256
7369: PUSH
7370: LD_INT 700
7372: LESS
7373: IFFALSE 7475
// begin ComMoveToArea ( crane , am_repair ) ;
7375: LD_INT 15
7377: PPUSH
7378: LD_INT 11
7380: PPUSH
7381: CALL_OW 113
// while not IsInArea ( crane , am_repair ) do
7385: LD_INT 15
7387: PPUSH
7388: LD_INT 11
7390: PPUSH
7391: CALL_OW 308
7395: NOT
7396: IFFALSE 7407
// wait ( 0 0$1 ) ;
7398: LD_INT 35
7400: PPUSH
7401: CALL_OW 67
7405: GO 7385
// ComExitVehicle ( crane ) ;
7407: LD_INT 15
7409: PPUSH
7410: CALL_OW 121
// while IsDrivenBy ( crane ) do
7414: LD_INT 15
7416: PPUSH
7417: CALL_OW 311
7421: IFFALSE 7432
// wait ( 10 ) ;
7423: LD_INT 10
7425: PPUSH
7426: CALL_OW 67
7430: GO 7414
// ComRepairVehicle ( us_mech , crane ) ;
7432: LD_EXP 23
7436: PPUSH
7437: LD_INT 15
7439: PPUSH
7440: CALL_OW 129
// AddComEnterUnit ( us_mech , crane ) ;
7444: LD_EXP 23
7448: PPUSH
7449: LD_INT 15
7451: PPUSH
7452: CALL_OW 180
// while not IsDrivenBy ( crane ) do
7456: LD_INT 15
7458: PPUSH
7459: CALL_OW 311
7463: NOT
7464: IFFALSE 7475
// wait ( 0 0$1 ) ;
7466: LD_INT 35
7468: PPUSH
7469: CALL_OW 67
7473: GO 7456
// end ; if GetLives ( list [ 1 ] ) = 1000 then
7475: LD_VAR 0 1
7479: PUSH
7480: LD_INT 1
7482: ARRAY
7483: PPUSH
7484: CALL_OW 256
7488: PUSH
7489: LD_INT 1000
7491: EQUAL
7492: IFFALSE 7514
// list := list diff list [ 1 ] ;
7494: LD_ADDR_VAR 0 1
7498: PUSH
7499: LD_VAR 0 1
7503: PUSH
7504: LD_VAR 0 1
7508: PUSH
7509: LD_INT 1
7511: ARRAY
7512: DIFF
7513: ST_TO_ADDR
// wait ( 0 0$1 ) ;
7514: LD_INT 35
7516: PPUSH
7517: CALL_OW 67
// until not list ;
7521: LD_VAR 0 1
7525: NOT
7526: IFFALSE 7328
// end ; end_of_file
7528: LD_VAR 0 2
7532: RET
// every 0 0$2 + 0 0$0.1 do
7533: GO 7535
7535: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
7536: LD_INT 22
7538: PUSH
7539: LD_INT 7
7541: PUSH
7542: EMPTY
7543: LIST
7544: LIST
7545: PUSH
7546: LD_INT 2
7548: PUSH
7549: LD_INT 25
7551: PUSH
7552: LD_INT 12
7554: PUSH
7555: EMPTY
7556: LIST
7557: LIST
7558: PUSH
7559: LD_INT 25
7561: PUSH
7562: LD_INT 16
7564: PUSH
7565: EMPTY
7566: LIST
7567: LIST
7568: PUSH
7569: LD_INT 25
7571: PUSH
7572: LD_INT 15
7574: PUSH
7575: EMPTY
7576: LIST
7577: LIST
7578: PUSH
7579: LD_INT 25
7581: PUSH
7582: LD_INT 17
7584: PUSH
7585: EMPTY
7586: LIST
7587: LIST
7588: PUSH
7589: EMPTY
7590: LIST
7591: LIST
7592: LIST
7593: LIST
7594: LIST
7595: PUSH
7596: EMPTY
7597: LIST
7598: LIST
7599: PPUSH
7600: CALL_OW 69
7604: PUSH
7605: LD_INT 22
7607: PUSH
7608: LD_INT 7
7610: PUSH
7611: EMPTY
7612: LIST
7613: LIST
7614: PUSH
7615: LD_INT 21
7617: PUSH
7618: LD_INT 1
7620: PUSH
7621: EMPTY
7622: LIST
7623: LIST
7624: PUSH
7625: LD_INT 3
7627: PUSH
7628: LD_INT 2
7630: PUSH
7631: LD_INT 25
7633: PUSH
7634: LD_INT 12
7636: PUSH
7637: EMPTY
7638: LIST
7639: LIST
7640: PUSH
7641: LD_INT 25
7643: PUSH
7644: LD_INT 16
7646: PUSH
7647: EMPTY
7648: LIST
7649: LIST
7650: PUSH
7651: LD_INT 25
7653: PUSH
7654: LD_INT 15
7656: PUSH
7657: EMPTY
7658: LIST
7659: LIST
7660: PUSH
7661: LD_INT 25
7663: PUSH
7664: LD_INT 17
7666: PUSH
7667: EMPTY
7668: LIST
7669: LIST
7670: PUSH
7671: EMPTY
7672: LIST
7673: LIST
7674: LIST
7675: LIST
7676: LIST
7677: PUSH
7678: EMPTY
7679: LIST
7680: LIST
7681: PUSH
7682: EMPTY
7683: LIST
7684: LIST
7685: LIST
7686: PPUSH
7687: CALL_OW 69
7691: GREATER
7692: IFFALSE 7703
// begin SetAchievement ( ACH_POTA ) ;
7694: LD_STRING ACH_POTA
7696: PPUSH
7697: CALL_OW 543
// exit ;
7701: GO 7704
// end ; enable ;
7703: ENABLE
// end ; end_of_file
7704: END
// export function SA_EndMission ( campaignNumber , missionNumber , medal1 , medal2 , medal3 ) ; var achiv ; begin
7705: LD_INT 0
7707: PPUSH
7708: PPUSH
// if not missionNumber then
7709: LD_VAR 0 2
7713: NOT
7714: IFFALSE 7718
// exit ;
7716: GO 7848
// achiv := false ;
7718: LD_ADDR_VAR 0 7
7722: PUSH
7723: LD_INT 0
7725: ST_TO_ADDR
// case campaignNumber of 1 :
7726: LD_VAR 0 1
7730: PUSH
7731: LD_INT 1
7733: DOUBLE
7734: EQUAL
7735: IFTRUE 7739
7737: GO 7750
7739: POP
// achiv := ACH_GOTA ; 2 :
7740: LD_ADDR_VAR 0 7
7744: PUSH
7745: LD_STRING ACH_GOTA
7747: ST_TO_ADDR
7748: GO 7800
7750: LD_INT 2
7752: DOUBLE
7753: EQUAL
7754: IFTRUE 7758
7756: GO 7761
7758: POP
// ; 3 :
7759: GO 7800
7761: LD_INT 3
7763: DOUBLE
7764: EQUAL
7765: IFTRUE 7769
7767: GO 7780
7769: POP
// achiv := ACH_MOTSU ; 4 :
7770: LD_ADDR_VAR 0 7
7774: PUSH
7775: LD_STRING ACH_MOTSU
7777: ST_TO_ADDR
7778: GO 7800
7780: LD_INT 4
7782: DOUBLE
7783: EQUAL
7784: IFTRUE 7788
7786: GO 7799
7788: POP
// achiv := ACH_LOP ; end ;
7789: LD_ADDR_VAR 0 7
7793: PUSH
7794: LD_STRING ACH_LOP
7796: ST_TO_ADDR
7797: GO 7800
7799: POP
// if Difficulty = 3 and achiv and medal1 and medal2 and medal3 then
7800: LD_OWVAR 67
7804: PUSH
7805: LD_INT 3
7807: EQUAL
7808: PUSH
7809: LD_VAR 0 7
7813: AND
7814: PUSH
7815: LD_VAR 0 3
7819: AND
7820: PUSH
7821: LD_VAR 0 4
7825: AND
7826: PUSH
7827: LD_VAR 0 5
7831: AND
7832: IFFALSE 7848
// SetAchievementEX ( achiv , missionNumber ) ;
7834: LD_VAR 0 7
7838: PPUSH
7839: LD_VAR 0 2
7843: PPUSH
7844: CALL_OW 564
// end ;
7848: LD_VAR 0 6
7852: RET
// export function SA_BehemothConstructed ; begin
7853: LD_INT 0
7855: PPUSH
// SetAchievement ( ACH_SMC ) ;
7856: LD_STRING ACH_SMC
7858: PPUSH
7859: CALL_OW 543
// end ;
7863: LD_VAR 0 1
7867: RET

// export MacMillan , Burlak , ru_sci , Powell , Stevens , truck1 , truck2 ; export blast_was_seen , lab_destroyed , time_out , entered_contaminated_area , original_stevens , blast_time , technology_taken , keep_base_finished ; export you , americans ; export Masha ; export time_to_complete , ru_artefact ; function prepare_units ; var veh , JMM_car , Bur_car , JMM_load , Bur_load ; begin
   0: LD_INT 0
   2: PPUSH
   3: PPUSH
   4: PPUSH
   5: PPUSH
   6: PPUSH
   7: PPUSH
// uc_nation := nation_american ;
   8: LD_ADDR_OWVAR 21
  12: PUSH
  13: LD_INT 1
  15: ST_TO_ADDR
// uc_side := you ;
  16: LD_ADDR_OWVAR 20
  20: PUSH
  21: LD_EXP 16
  25: ST_TO_ADDR
// MacMillan := CreateCharacter ( MacMillan ) ;
  26: LD_ADDR_EXP 1
  30: PUSH
  31: LD_STRING MacMillan
  33: PPUSH
  34: CALL_OW 34
  38: ST_TO_ADDR
// SetClass ( MacMillan , class_engineer ) ;
  39: LD_EXP 1
  43: PPUSH
  44: LD_INT 2
  46: PPUSH
  47: CALL_OW 336
// Burlak := CreateCharacter ( Burlak ) ;
  51: LD_ADDR_EXP 2
  55: PUSH
  56: LD_STRING Burlak
  58: PPUSH
  59: CALL_OW 34
  63: ST_TO_ADDR
// SetClass ( Burlak , class_mechanic ) ;
  64: LD_EXP 2
  68: PPUSH
  69: LD_INT 3
  71: PPUSH
  72: CALL_OW 336
// uc_nation := nation_russian ;
  76: LD_ADDR_OWVAR 21
  80: PUSH
  81: LD_INT 3
  83: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
  84: LD_INT 1
  86: PPUSH
  87: LD_INT 8
  89: PPUSH
  90: CALL_OW 384
// ru_sci := CreateHuman ;
  94: LD_ADDR_EXP 3
  98: PUSH
  99: CALL_OW 44
 103: ST_TO_ADDR
// uc_nation := nation_american ;
 104: LD_ADDR_OWVAR 21
 108: PUSH
 109: LD_INT 1
 111: ST_TO_ADDR
// uc_side := americans ;
 112: LD_ADDR_OWVAR 20
 116: PUSH
 117: LD_EXP 17
 121: ST_TO_ADDR
// Powell := CreateCharacter ( Powell ) ;
 122: LD_ADDR_EXP 4
 126: PUSH
 127: LD_STRING Powell
 129: PPUSH
 130: CALL_OW 34
 134: ST_TO_ADDR
// if TestCharacters ( Stevens ) and CheckCharacterSet ( Stevens ) then
 135: LD_STRING Stevens
 137: PPUSH
 138: CALL_OW 28
 142: PUSH
 143: LD_STRING Stevens
 145: PPUSH
 146: CALL_OW 29
 150: AND
 151: IFFALSE 176
// begin Stevens := CreateCharacter ( Stevens ) ;
 153: LD_ADDR_EXP 5
 157: PUSH
 158: LD_STRING Stevens
 160: PPUSH
 161: CALL_OW 34
 165: ST_TO_ADDR
// original_stevens := true ;
 166: LD_ADDR_EXP 12
 170: PUSH
 171: LD_INT 1
 173: ST_TO_ADDR
// end else
 174: GO 212
// begin uc_nation := nation_american ;
 176: LD_ADDR_OWVAR 21
 180: PUSH
 181: LD_INT 1
 183: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
 184: LD_INT 1
 186: PPUSH
 187: LD_INT 8
 189: PPUSH
 190: CALL_OW 384
// Stevens := CreateHuman ;
 194: LD_ADDR_EXP 5
 198: PUSH
 199: CALL_OW 44
 203: ST_TO_ADDR
// original_stevens := false ;
 204: LD_ADDR_EXP 12
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// end ; uc_side = you ;
 212: LD_ADDR_OWVAR 20
 216: PUSH
 217: LD_EXP 16
 221: ST_TO_ADDR
// uc_nation := nation_american ;
 222: LD_ADDR_OWVAR 21
 226: PUSH
 227: LD_INT 1
 229: ST_TO_ADDR
// uc_direction := 5 ;
 230: LD_ADDR_OWVAR 24
 234: PUSH
 235: LD_INT 5
 237: ST_TO_ADDR
// veh := LoadVariable ( Masha , [ ] ) ;
 238: LD_ADDR_VAR 0 2
 242: PUSH
 243: LD_STRING Masha
 245: PPUSH
 246: EMPTY
 247: PPUSH
 248: CALL_OW 30
 252: ST_TO_ADDR
// if veh then
 253: LD_VAR 0 2
 257: IFFALSE 327
// begin vc_chassis := veh [ 1 ] ;
 259: LD_ADDR_OWVAR 37
 263: PUSH
 264: LD_VAR 0 2
 268: PUSH
 269: LD_INT 1
 271: ARRAY
 272: ST_TO_ADDR
// vc_engine := veh [ 2 ] ;
 273: LD_ADDR_OWVAR 39
 277: PUSH
 278: LD_VAR 0 2
 282: PUSH
 283: LD_INT 2
 285: ARRAY
 286: ST_TO_ADDR
// vc_control := veh [ 3 ] ;
 287: LD_ADDR_OWVAR 38
 291: PUSH
 292: LD_VAR 0 2
 296: PUSH
 297: LD_INT 3
 299: ARRAY
 300: ST_TO_ADDR
// vc_weapon := veh [ 4 ] ;
 301: LD_ADDR_OWVAR 40
 305: PUSH
 306: LD_VAR 0 2
 310: PUSH
 311: LD_INT 4
 313: ARRAY
 314: ST_TO_ADDR
// Masha := CreateVehicle ;
 315: LD_ADDR_EXP 18
 319: PUSH
 320: CALL_OW 45
 324: ST_TO_ADDR
// end else
 325: GO 335
// Masha := false ;
 327: LD_ADDR_EXP 18
 331: PUSH
 332: LD_INT 0
 334: ST_TO_ADDR
// JMM_car := LoadVariable ( JMM_car , [ us_medium_tracked , engine_combustion , control_manual , us_cargo_bay ] ) ;
 335: LD_ADDR_VAR 0 3
 339: PUSH
 340: LD_STRING JMM_car
 342: PPUSH
 343: LD_INT 3
 345: PUSH
 346: LD_INT 1
 348: PUSH
 349: LD_INT 1
 351: PUSH
 352: LD_INT 12
 354: PUSH
 355: EMPTY
 356: LIST
 357: LIST
 358: LIST
 359: LIST
 360: PPUSH
 361: CALL_OW 30
 365: ST_TO_ADDR
// JMM_load := LoadVariable ( JMM_car_load , 0 ) ;
 366: LD_ADDR_VAR 0 5
 370: PUSH
 371: LD_STRING JMM_car_load
 373: PPUSH
 374: LD_INT 0
 376: PPUSH
 377: CALL_OW 30
 381: ST_TO_ADDR
// if JMM_car [ 1 ] in [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] then
 382: LD_VAR 0 3
 386: PUSH
 387: LD_INT 1
 389: ARRAY
 390: PUSH
 391: LD_INT 1
 393: PUSH
 394: LD_INT 2
 396: PUSH
 397: LD_INT 3
 399: PUSH
 400: LD_INT 4
 402: PUSH
 403: LD_INT 5
 405: PUSH
 406: EMPTY
 407: LIST
 408: LIST
 409: LIST
 410: LIST
 411: LIST
 412: IN
 413: IFFALSE 425
// uc_nation := nation_american else
 415: LD_ADDR_OWVAR 21
 419: PUSH
 420: LD_INT 1
 422: ST_TO_ADDR
 423: GO 433
// uc_nation := nation_russian ;
 425: LD_ADDR_OWVAR 21
 429: PUSH
 430: LD_INT 3
 432: ST_TO_ADDR
// vc_chassis := JMM_car [ 1 ] ;
 433: LD_ADDR_OWVAR 37
 437: PUSH
 438: LD_VAR 0 3
 442: PUSH
 443: LD_INT 1
 445: ARRAY
 446: ST_TO_ADDR
// vc_engine := JMM_car [ 2 ] ;
 447: LD_ADDR_OWVAR 39
 451: PUSH
 452: LD_VAR 0 3
 456: PUSH
 457: LD_INT 2
 459: ARRAY
 460: ST_TO_ADDR
// vc_control := JMM_car [ 3 ] ;
 461: LD_ADDR_OWVAR 38
 465: PUSH
 466: LD_VAR 0 3
 470: PUSH
 471: LD_INT 3
 473: ARRAY
 474: ST_TO_ADDR
// vc_weapon := JMM_car [ 4 ] ;
 475: LD_ADDR_OWVAR 40
 479: PUSH
 480: LD_VAR 0 3
 484: PUSH
 485: LD_INT 4
 487: ARRAY
 488: ST_TO_ADDR
// truck1 := CreateVehicle ;
 489: LD_ADDR_EXP 6
 493: PUSH
 494: CALL_OW 45
 498: ST_TO_ADDR
// if Masha and ( GetWeapon ( truck1 ) = GetWeapon ( Masha ) ) then
 499: LD_EXP 18
 503: PUSH
 504: LD_EXP 6
 508: PPUSH
 509: CALL_OW 264
 513: PUSH
 514: LD_EXP 18
 518: PPUSH
 519: CALL_OW 264
 523: EQUAL
 524: AND
 525: IFFALSE 549
// begin SetMark ( truck1 , 1 ) ;
 527: LD_EXP 6
 531: PPUSH
 532: LD_INT 1
 534: PPUSH
 535: CALL_OW 242
// Masha := truck1 ;
 539: LD_ADDR_EXP 18
 543: PUSH
 544: LD_EXP 6
 548: ST_TO_ADDR
// end ; if JMM_load > 0 then
 549: LD_VAR 0 5
 553: PUSH
 554: LD_INT 0
 556: GREATER
 557: IFFALSE 576
// SetCargo ( truck1 , mat_oil , JMM_load ) ;
 559: LD_EXP 6
 563: PPUSH
 564: LD_INT 2
 566: PPUSH
 567: LD_VAR 0 5
 571: PPUSH
 572: CALL_OW 290
// Bur_car := LoadVariable ( Bur_car , [ ru_medium_tracked , engine_combustion , control_manual , ru_gatling_gun ] ) ;
 576: LD_ADDR_VAR 0 4
 580: PUSH
 581: LD_STRING Bur_car
 583: PPUSH
 584: LD_INT 22
 586: PUSH
 587: LD_INT 1
 589: PUSH
 590: LD_INT 1
 592: PUSH
 593: LD_INT 43
 595: PUSH
 596: EMPTY
 597: LIST
 598: LIST
 599: LIST
 600: LIST
 601: PPUSH
 602: CALL_OW 30
 606: ST_TO_ADDR
// Bur_load := LoadVariable ( Bur_car_load , 0 ) ;
 607: LD_ADDR_VAR 0 6
 611: PUSH
 612: LD_STRING Bur_car_load
 614: PPUSH
 615: LD_INT 0
 617: PPUSH
 618: CALL_OW 30
 622: ST_TO_ADDR
// if Bur_car [ 1 ] in [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] then
 623: LD_VAR 0 4
 627: PUSH
 628: LD_INT 1
 630: ARRAY
 631: PUSH
 632: LD_INT 21
 634: PUSH
 635: LD_INT 22
 637: PUSH
 638: LD_INT 23
 640: PUSH
 641: LD_INT 24
 643: PUSH
 644: EMPTY
 645: LIST
 646: LIST
 647: LIST
 648: LIST
 649: IN
 650: IFFALSE 662
// uc_nation := nation_russian else
 652: LD_ADDR_OWVAR 21
 656: PUSH
 657: LD_INT 3
 659: ST_TO_ADDR
 660: GO 670
// uc_nation := nation_american ;
 662: LD_ADDR_OWVAR 21
 666: PUSH
 667: LD_INT 1
 669: ST_TO_ADDR
// vc_chassis := Bur_car [ 1 ] ;
 670: LD_ADDR_OWVAR 37
 674: PUSH
 675: LD_VAR 0 4
 679: PUSH
 680: LD_INT 1
 682: ARRAY
 683: ST_TO_ADDR
// vc_engine := Bur_car [ 2 ] ;
 684: LD_ADDR_OWVAR 39
 688: PUSH
 689: LD_VAR 0 4
 693: PUSH
 694: LD_INT 2
 696: ARRAY
 697: ST_TO_ADDR
// vc_control := Bur_car [ 3 ] ;
 698: LD_ADDR_OWVAR 38
 702: PUSH
 703: LD_VAR 0 4
 707: PUSH
 708: LD_INT 3
 710: ARRAY
 711: ST_TO_ADDR
// vc_weapon := Bur_car [ 4 ] ;
 712: LD_ADDR_OWVAR 40
 716: PUSH
 717: LD_VAR 0 4
 721: PUSH
 722: LD_INT 4
 724: ARRAY
 725: ST_TO_ADDR
// truck2 := CreateVehicle ;
 726: LD_ADDR_EXP 7
 730: PUSH
 731: CALL_OW 45
 735: ST_TO_ADDR
// if Masha and ( GetWeapon ( truck2 ) = GetWeapon ( Masha ) ) then
 736: LD_EXP 18
 740: PUSH
 741: LD_EXP 7
 745: PPUSH
 746: CALL_OW 264
 750: PUSH
 751: LD_EXP 18
 755: PPUSH
 756: CALL_OW 264
 760: EQUAL
 761: AND
 762: IFFALSE 786
// begin SetMark ( truck2 , 1 ) ;
 764: LD_EXP 7
 768: PPUSH
 769: LD_INT 1
 771: PPUSH
 772: CALL_OW 242
// Masha := truck1 ;
 776: LD_ADDR_EXP 18
 780: PUSH
 781: LD_EXP 6
 785: ST_TO_ADDR
// end ; if Bur_load > 0 then
 786: LD_VAR 0 6
 790: PUSH
 791: LD_INT 0
 793: GREATER
 794: IFFALSE 813
// SetCargo ( truck2 , mat_oil , Bur_load ) ;
 796: LD_EXP 7
 800: PPUSH
 801: LD_INT 2
 803: PPUSH
 804: LD_VAR 0 6
 808: PPUSH
 809: CALL_OW 290
// PlaceHumanInUnit ( MacMillan , truck1 ) ;
 813: LD_EXP 1
 817: PPUSH
 818: LD_EXP 6
 822: PPUSH
 823: CALL_OW 52
// PlaceHumanInUnit ( Burlak , truck2 ) ;
 827: LD_EXP 2
 831: PPUSH
 832: LD_EXP 7
 836: PPUSH
 837: CALL_OW 52
// PlaceUnitXY ( truck1 , 200 , 86 , false ) ;
 841: LD_EXP 6
 845: PPUSH
 846: LD_INT 200
 848: PPUSH
 849: LD_INT 86
 851: PPUSH
 852: LD_INT 0
 854: PPUSH
 855: CALL_OW 48
// PlaceUnitXY ( truck2 , 202 , 90 , false ) ;
 859: LD_EXP 7
 863: PPUSH
 864: LD_INT 202
 866: PPUSH
 867: LD_INT 90
 869: PPUSH
 870: LD_INT 0
 872: PPUSH
 873: CALL_OW 48
// ComFree ( [ MacMillan , Burlak ] ) ;
 877: LD_EXP 1
 881: PUSH
 882: LD_EXP 2
 886: PUSH
 887: EMPTY
 888: LIST
 889: LIST
 890: PPUSH
 891: CALL_OW 139
// end ;
 895: LD_VAR 0 1
 899: RET
// function prepare_sides ; begin
 900: LD_INT 0
 902: PPUSH
// you = 7 ;
 903: LD_ADDR_EXP 16
 907: PUSH
 908: LD_INT 7
 910: ST_TO_ADDR
// americans = 1 ;
 911: LD_ADDR_EXP 17
 915: PUSH
 916: LD_INT 1
 918: ST_TO_ADDR
// SetAttitude ( you , americans , att_enemy , true ) ;
 919: LD_EXP 16
 923: PPUSH
 924: LD_EXP 17
 928: PPUSH
 929: LD_INT 2
 931: PPUSH
 932: LD_INT 1
 934: PPUSH
 935: CALL_OW 80
// blast_was_seen := false ;
 939: LD_ADDR_EXP 8
 943: PUSH
 944: LD_INT 0
 946: ST_TO_ADDR
// time_out := false ;
 947: LD_ADDR_EXP 10
 951: PUSH
 952: LD_INT 0
 954: ST_TO_ADDR
// entered_contaminated_area := false ;
 955: LD_ADDR_EXP 11
 959: PUSH
 960: LD_INT 0
 962: ST_TO_ADDR
// blast_countdown := false ;
 963: LD_ADDR_EXP 27
 967: PUSH
 968: LD_INT 0
 970: ST_TO_ADDR
// lab_destroyed := false ;
 971: LD_ADDR_EXP 9
 975: PUSH
 976: LD_INT 0
 978: ST_TO_ADDR
// technology_taken := false ;
 979: LD_ADDR_EXP 14
 983: PUSH
 984: LD_INT 0
 986: ST_TO_ADDR
// time_to_complete := [ 15 15$0 , 10 10$0 , 8 8$0 ] [ difficulty ] ;
 987: LD_ADDR_EXP 19
 991: PUSH
 992: LD_INT 31500
 994: PUSH
 995: LD_INT 21000
 997: PUSH
 998: LD_INT 16800
1000: PUSH
1001: EMPTY
1002: LIST
1003: LIST
1004: LIST
1005: PUSH
1006: LD_OWVAR 67
1010: ARRAY
1011: ST_TO_ADDR
// ru_artefact := 4 ;
1012: LD_ADDR_EXP 20
1016: PUSH
1017: LD_INT 4
1019: ST_TO_ADDR
// blast_done := false ;
1020: LD_ADDR_EXP 28
1024: PUSH
1025: LD_INT 0
1027: ST_TO_ADDR
// query_started := false ;
1028: LD_ADDR_EXP 29
1032: PUSH
1033: LD_INT 0
1035: ST_TO_ADDR
// dokecano := false ;
1036: LD_ADDR_EXP 33
1040: PUSH
1041: LD_INT 0
1043: ST_TO_ADDR
// art_picked := false ;
1044: LD_ADDR_EXP 31
1048: PUSH
1049: LD_INT 0
1051: ST_TO_ADDR
// art_cargo := false ;
1052: LD_ADDR_EXP 32
1056: PUSH
1057: LD_INT 0
1059: ST_TO_ADDR
// disable ( 1 ) ;
1060: LD_INT 1
1062: DISABLE_MARKED
// disable ( 2 ) ;
1063: LD_INT 2
1065: DISABLE_MARKED
// disable ( 3 ) ;
1066: LD_INT 3
1068: DISABLE_MARKED
// disable ( 4 ) ;
1069: LD_INT 4
1071: DISABLE_MARKED
// disable ( 5 ) ;
1072: LD_INT 5
1074: DISABLE_MARKED
// disable ( 6 ) ;
1075: LD_INT 6
1077: DISABLE_MARKED
// disable ( 7 ) ;
1078: LD_INT 7
1080: DISABLE_MARKED
// disable ( 8 ) ;
1081: LD_INT 8
1083: DISABLE_MARKED
// disable ( 9 ) ;
1084: LD_INT 9
1086: DISABLE_MARKED
// disable ( 10 ) ;
1087: LD_INT 10
1089: DISABLE_MARKED
// end ;
1090: LD_VAR 0 1
1094: RET
// starting begin prepare_sides ;
1095: CALL 900 0 0
// prepare_units ;
1099: CALL 0 0 0
// prepare_us_side ;
1103: CALL 3082 0 0
// starting_scene ;
1107: CALL 4597 0 0
// end ;
1111: END
// export function konec_mise ; var un , JMM_car , Bur_car ; begin
1112: LD_INT 0
1114: PPUSH
1115: PPUSH
1116: PPUSH
1117: PPUSH
// AddMedal ( Explosion , blast_was_seen ) ;
1118: LD_STRING Explosion
1120: PPUSH
1121: LD_EXP 8
1125: PPUSH
1126: CALL_OW 101
// AddMedal ( BioHazard , entered_contaminated_area ) ;
1130: LD_STRING BioHazard
1132: PPUSH
1133: LD_EXP 11
1137: PPUSH
1138: CALL_OW 101
// AddMedal ( Speed , ( TICK - blast_time ) < time_to_complete ) ;
1142: LD_STRING Speed
1144: PPUSH
1145: LD_OWVAR 1
1149: PUSH
1150: LD_EXP 13
1154: MINUS
1155: PUSH
1156: LD_EXP 19
1160: LESS
1161: PPUSH
1162: CALL_OW 101
// SA_EndMission ( 4 , 3 , blast_was_seen > 0 , entered_contaminated_area > 0 , ( TICK - blast_time ) < time_to_complete ) ;
1166: LD_INT 4
1168: PPUSH
1169: LD_INT 3
1171: PPUSH
1172: LD_EXP 8
1176: PUSH
1177: LD_INT 0
1179: GREATER
1180: PPUSH
1181: LD_EXP 11
1185: PUSH
1186: LD_INT 0
1188: GREATER
1189: PPUSH
1190: LD_OWVAR 1
1194: PUSH
1195: LD_EXP 13
1199: MINUS
1200: PUSH
1201: LD_EXP 19
1205: LESS
1206: PPUSH
1207: CALL 7718 0 5
// GiveMedals ( Main ) ;
1211: LD_STRING Main
1213: PPUSH
1214: CALL_OW 102
// RewardPeople ( [ Burlak , MacMillan ] ) ;
1218: LD_EXP 2
1222: PUSH
1223: LD_EXP 1
1227: PUSH
1228: EMPTY
1229: LIST
1230: LIST
1231: PPUSH
1232: CALL_OW 43
// SaveCharacters ( MacMillan , JMM ) ;
1236: LD_EXP 1
1240: PPUSH
1241: LD_STRING JMM
1243: PPUSH
1244: CALL_OW 38
// SaveCharacters ( Burlak , Burlak ) ;
1248: LD_EXP 2
1252: PPUSH
1253: LD_STRING Burlak
1255: PPUSH
1256: CALL_OW 38
// un := IsInUnit ( MacMillan ) ;
1260: LD_ADDR_VAR 0 2
1264: PUSH
1265: LD_EXP 1
1269: PPUSH
1270: CALL_OW 310
1274: ST_TO_ADDR
// if un and not un = masha then
1275: LD_VAR 0 2
1279: PUSH
1280: LD_VAR 0 2
1284: PUSH
1285: LD_EXP 18
1289: EQUAL
1290: NOT
1291: AND
1292: IFFALSE 1359
// begin JMM_car := [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
1294: LD_ADDR_VAR 0 3
1298: PUSH
1299: LD_VAR 0 2
1303: PPUSH
1304: CALL_OW 265
1308: PUSH
1309: LD_VAR 0 2
1313: PPUSH
1314: CALL_OW 262
1318: PUSH
1319: LD_VAR 0 2
1323: PPUSH
1324: CALL_OW 263
1328: PUSH
1329: LD_VAR 0 2
1333: PPUSH
1334: CALL_OW 264
1338: PUSH
1339: EMPTY
1340: LIST
1341: LIST
1342: LIST
1343: LIST
1344: ST_TO_ADDR
// SaveVariable ( JMM_car , JMM_car ) ;
1345: LD_VAR 0 3
1349: PPUSH
1350: LD_STRING JMM_car
1352: PPUSH
1353: CALL_OW 39
// end else
1357: GO 1366
// DeleteVariable ( JMM_car ) ;
1359: LD_STRING JMM_car
1361: PPUSH
1362: CALL_OW 41
// un := IsInUnit ( Burlak ) ;
1366: LD_ADDR_VAR 0 2
1370: PUSH
1371: LD_EXP 2
1375: PPUSH
1376: CALL_OW 310
1380: ST_TO_ADDR
// if un then
1381: LD_VAR 0 2
1385: IFFALSE 1452
// begin Bur_car := [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
1387: LD_ADDR_VAR 0 4
1391: PUSH
1392: LD_VAR 0 2
1396: PPUSH
1397: CALL_OW 265
1401: PUSH
1402: LD_VAR 0 2
1406: PPUSH
1407: CALL_OW 262
1411: PUSH
1412: LD_VAR 0 2
1416: PPUSH
1417: CALL_OW 263
1421: PUSH
1422: LD_VAR 0 2
1426: PPUSH
1427: CALL_OW 264
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: ST_TO_ADDR
// SaveVariable ( Bur_car , Bur_car ) ;
1438: LD_VAR 0 4
1442: PPUSH
1443: LD_STRING Bur_car
1445: PPUSH
1446: CALL_OW 39
// end else
1450: GO 1459
// DeleteVariable ( Bur_car ) ;
1452: LD_STRING Bur_car
1454: PPUSH
1455: CALL_OW 41
// if not IsOK ( Masha ) then
1459: LD_EXP 18
1463: PPUSH
1464: CALL_OW 302
1468: NOT
1469: IFFALSE 1478
// DeleteVariable ( Masha ) ;
1471: LD_STRING Masha
1473: PPUSH
1474: CALL_OW 41
// YouWin ;
1478: CALL_OW 103
// end ;
1482: LD_VAR 0 1
1486: RET
// export function Mission_Failed ( style ) ; begin
1487: LD_INT 0
1489: PPUSH
// case style of 1 :
1490: LD_VAR 0 1
1494: PUSH
1495: LD_INT 1
1497: DOUBLE
1498: EQUAL
1499: IFTRUE 1503
1501: GO 1513
1503: POP
// YouLost ( Burlak ) ; 2 :
1504: LD_STRING Burlak
1506: PPUSH
1507: CALL_OW 104
1511: GO 1604
1513: LD_INT 2
1515: DOUBLE
1516: EQUAL
1517: IFTRUE 1521
1519: GO 1531
1521: POP
// YouLost ( JMM ) ; 3 :
1522: LD_STRING JMM
1524: PPUSH
1525: CALL_OW 104
1529: GO 1604
1531: LD_INT 3
1533: DOUBLE
1534: EQUAL
1535: IFTRUE 1539
1537: GO 1549
1539: POP
// YouLost ( Time ) ; 4 :
1540: LD_STRING Time
1542: PPUSH
1543: CALL_OW 104
1547: GO 1604
1549: LD_INT 4
1551: DOUBLE
1552: EQUAL
1553: IFTRUE 1557
1555: GO 1567
1557: POP
// YouLost ( Artefact ) ; 5 :
1558: LD_STRING Artefact
1560: PPUSH
1561: CALL_OW 104
1565: GO 1604
1567: LD_INT 5
1569: DOUBLE
1570: EQUAL
1571: IFTRUE 1575
1573: GO 1585
1575: POP
// YouLost ( Lab ) ; 6 :
1576: LD_STRING Lab
1578: PPUSH
1579: CALL_OW 104
1583: GO 1604
1585: LD_INT 6
1587: DOUBLE
1588: EQUAL
1589: IFTRUE 1593
1591: GO 1603
1593: POP
// YouLost ( Cargo ) ; end ;
1594: LD_STRING Cargo
1596: PPUSH
1597: CALL_OW 104
1601: GO 1604
1603: POP
// end ; end_of_file
1604: LD_VAR 0 2
1608: RET
// export us_sol , us_sci , us_mech , us_all_units ; export us_patrol_1 , us_patrol_2 ; export blast_countdown ; every 0 0$1 marked 2 do var i , x , y , cesta ;
1609: GO 1611
1611: DISABLE
1612: LD_INT 0
1614: PPUSH
1615: PPUSH
1616: PPUSH
1617: PPUSH
// begin if difficulty < 3 then
1618: LD_OWVAR 67
1622: PUSH
1623: LD_INT 3
1625: LESS
1626: IFFALSE 1765
// cesta := [ 101 , 39 , 124 , 31 , 123 , 7 , 158 , 21 , 168 , 40 , 168 , 65 , 167 , 90 , 146 , 83 , 146 , 83 , 167 , 90 , 168 , 65 , 168 , 40 , 158 , 21 , 123 , 7 , 124 , 31 , 101 , 39 ] else
1628: LD_ADDR_VAR 0 4
1632: PUSH
1633: LD_INT 101
1635: PUSH
1636: LD_INT 39
1638: PUSH
1639: LD_INT 124
1641: PUSH
1642: LD_INT 31
1644: PUSH
1645: LD_INT 123
1647: PUSH
1648: LD_INT 7
1650: PUSH
1651: LD_INT 158
1653: PUSH
1654: LD_INT 21
1656: PUSH
1657: LD_INT 168
1659: PUSH
1660: LD_INT 40
1662: PUSH
1663: LD_INT 168
1665: PUSH
1666: LD_INT 65
1668: PUSH
1669: LD_INT 167
1671: PUSH
1672: LD_INT 90
1674: PUSH
1675: LD_INT 146
1677: PUSH
1678: LD_INT 83
1680: PUSH
1681: LD_INT 146
1683: PUSH
1684: LD_INT 83
1686: PUSH
1687: LD_INT 167
1689: PUSH
1690: LD_INT 90
1692: PUSH
1693: LD_INT 168
1695: PUSH
1696: LD_INT 65
1698: PUSH
1699: LD_INT 168
1701: PUSH
1702: LD_INT 40
1704: PUSH
1705: LD_INT 158
1707: PUSH
1708: LD_INT 21
1710: PUSH
1711: LD_INT 123
1713: PUSH
1714: LD_INT 7
1716: PUSH
1717: LD_INT 124
1719: PUSH
1720: LD_INT 31
1722: PUSH
1723: LD_INT 101
1725: PUSH
1726: LD_INT 39
1728: PUSH
1729: EMPTY
1730: LIST
1731: LIST
1732: LIST
1733: LIST
1734: LIST
1735: LIST
1736: LIST
1737: LIST
1738: LIST
1739: LIST
1740: LIST
1741: LIST
1742: LIST
1743: LIST
1744: LIST
1745: LIST
1746: LIST
1747: LIST
1748: LIST
1749: LIST
1750: LIST
1751: LIST
1752: LIST
1753: LIST
1754: LIST
1755: LIST
1756: LIST
1757: LIST
1758: LIST
1759: LIST
1760: LIST
1761: LIST
1762: ST_TO_ADDR
1763: GO 1836
// cesta := [ 101 , 39 , 124 , 31 , 123 , 7 , 135 , 7 , 135 , 7 , 123 , 7 , 124 , 31 , 101 , 39 ] ;
1765: LD_ADDR_VAR 0 4
1769: PUSH
1770: LD_INT 101
1772: PUSH
1773: LD_INT 39
1775: PUSH
1776: LD_INT 124
1778: PUSH
1779: LD_INT 31
1781: PUSH
1782: LD_INT 123
1784: PUSH
1785: LD_INT 7
1787: PUSH
1788: LD_INT 135
1790: PUSH
1791: LD_INT 7
1793: PUSH
1794: LD_INT 135
1796: PUSH
1797: LD_INT 7
1799: PUSH
1800: LD_INT 123
1802: PUSH
1803: LD_INT 7
1805: PUSH
1806: LD_INT 124
1808: PUSH
1809: LD_INT 31
1811: PUSH
1812: LD_INT 101
1814: PUSH
1815: LD_INT 39
1817: PUSH
1818: EMPTY
1819: LIST
1820: LIST
1821: LIST
1822: LIST
1823: LIST
1824: LIST
1825: LIST
1826: LIST
1827: LIST
1828: LIST
1829: LIST
1830: LIST
1831: LIST
1832: LIST
1833: LIST
1834: LIST
1835: ST_TO_ADDR
// repeat for i = 1 to ( cesta div 2 ) do
1836: LD_ADDR_VAR 0 1
1840: PUSH
1841: DOUBLE
1842: LD_INT 1
1844: DEC
1845: ST_TO_ADDR
1846: LD_VAR 0 4
1850: PUSH
1851: LD_INT 2
1853: DIV
1854: PUSH
1855: FOR_TO
1856: IFFALSE 1980
// begin x := cesta [ ( i * 2 ) - 1 ] ;
1858: LD_ADDR_VAR 0 2
1862: PUSH
1863: LD_VAR 0 4
1867: PUSH
1868: LD_VAR 0 1
1872: PUSH
1873: LD_INT 2
1875: MUL
1876: PUSH
1877: LD_INT 1
1879: MINUS
1880: ARRAY
1881: ST_TO_ADDR
// y := cesta [ ( i * 2 ) ] ;
1882: LD_ADDR_VAR 0 3
1886: PUSH
1887: LD_VAR 0 4
1891: PUSH
1892: LD_VAR 0 1
1896: PUSH
1897: LD_INT 2
1899: MUL
1900: ARRAY
1901: ST_TO_ADDR
// ComAgressiveMove ( us_patrol_1 , x , y ) ;
1902: LD_EXP 25
1906: PPUSH
1907: LD_VAR 0 2
1911: PPUSH
1912: LD_VAR 0 3
1916: PPUSH
1917: CALL_OW 114
// repeat wait ( 0 0$3 ) ;
1921: LD_INT 105
1923: PPUSH
1924: CALL_OW 67
// y := true ;
1928: LD_ADDR_VAR 0 3
1932: PUSH
1933: LD_INT 1
1935: ST_TO_ADDR
// for x in us_patrol_1 do
1936: LD_ADDR_VAR 0 2
1940: PUSH
1941: LD_EXP 25
1945: PUSH
1946: FOR_IN
1947: IFFALSE 1970
// if IsBusy ( x ) then
1949: LD_VAR 0 2
1953: PPUSH
1954: CALL_OW 315
1958: IFFALSE 1968
// y := false ;
1960: LD_ADDR_VAR 0 3
1964: PUSH
1965: LD_INT 0
1967: ST_TO_ADDR
1968: GO 1946
1970: POP
1971: POP
// until y ;
1972: LD_VAR 0 3
1976: IFFALSE 1921
// end ;
1978: GO 1855
1980: POP
1981: POP
// until ( not us_patrol_1 ) or ( blast_countdown ) ;
1982: LD_EXP 25
1986: NOT
1987: PUSH
1988: LD_EXP 27
1992: OR
1993: IFFALSE 1836
// if us_patrol_1 then
1995: LD_EXP 25
1999: IFFALSE 2039
// begin ComAgressiveMove ( us_patrol_1 , 56 , 77 ) ;
2001: LD_EXP 25
2005: PPUSH
2006: LD_INT 56
2008: PPUSH
2009: LD_INT 77
2011: PPUSH
2012: CALL_OW 114
// us_sol := us_sol ^ us_patrol_1 ;
2016: LD_ADDR_EXP 21
2020: PUSH
2021: LD_EXP 21
2025: PUSH
2026: LD_EXP 25
2030: ADD
2031: ST_TO_ADDR
// us_patrol_1 := [ ] ;
2032: LD_ADDR_EXP 25
2036: PUSH
2037: EMPTY
2038: ST_TO_ADDR
// end ; end ;
2039: PPOPN 4
2041: END
// every 0 0$1 marked 3 do var i , x , y , cesta ;
2042: GO 2044
2044: DISABLE
2045: LD_INT 0
2047: PPUSH
2048: PPUSH
2049: PPUSH
2050: PPUSH
// begin cesta := [ 135 , 7 , 158 , 21 , 168 , 40 , 168 , 65 , 167 , 90 , 146 , 83 , 146 , 83 , 167 , 90 , 168 , 65 , 168 , 40 , 158 , 21 , 135 , 7 ] ;
2051: LD_ADDR_VAR 0 4
2055: PUSH
2056: LD_INT 135
2058: PUSH
2059: LD_INT 7
2061: PUSH
2062: LD_INT 158
2064: PUSH
2065: LD_INT 21
2067: PUSH
2068: LD_INT 168
2070: PUSH
2071: LD_INT 40
2073: PUSH
2074: LD_INT 168
2076: PUSH
2077: LD_INT 65
2079: PUSH
2080: LD_INT 167
2082: PUSH
2083: LD_INT 90
2085: PUSH
2086: LD_INT 146
2088: PUSH
2089: LD_INT 83
2091: PUSH
2092: LD_INT 146
2094: PUSH
2095: LD_INT 83
2097: PUSH
2098: LD_INT 167
2100: PUSH
2101: LD_INT 90
2103: PUSH
2104: LD_INT 168
2106: PUSH
2107: LD_INT 65
2109: PUSH
2110: LD_INT 168
2112: PUSH
2113: LD_INT 40
2115: PUSH
2116: LD_INT 158
2118: PUSH
2119: LD_INT 21
2121: PUSH
2122: LD_INT 135
2124: PUSH
2125: LD_INT 7
2127: PUSH
2128: EMPTY
2129: LIST
2130: LIST
2131: LIST
2132: LIST
2133: LIST
2134: LIST
2135: LIST
2136: LIST
2137: LIST
2138: LIST
2139: LIST
2140: LIST
2141: LIST
2142: LIST
2143: LIST
2144: LIST
2145: LIST
2146: LIST
2147: LIST
2148: LIST
2149: LIST
2150: LIST
2151: LIST
2152: LIST
2153: ST_TO_ADDR
// repeat for i = 1 to ( cesta div 2 ) do
2154: LD_ADDR_VAR 0 1
2158: PUSH
2159: DOUBLE
2160: LD_INT 1
2162: DEC
2163: ST_TO_ADDR
2164: LD_VAR 0 4
2168: PUSH
2169: LD_INT 2
2171: DIV
2172: PUSH
2173: FOR_TO
2174: IFFALSE 2298
// begin x := cesta [ ( i * 2 ) - 1 ] ;
2176: LD_ADDR_VAR 0 2
2180: PUSH
2181: LD_VAR 0 4
2185: PUSH
2186: LD_VAR 0 1
2190: PUSH
2191: LD_INT 2
2193: MUL
2194: PUSH
2195: LD_INT 1
2197: MINUS
2198: ARRAY
2199: ST_TO_ADDR
// y := cesta [ ( i * 2 ) ] ;
2200: LD_ADDR_VAR 0 3
2204: PUSH
2205: LD_VAR 0 4
2209: PUSH
2210: LD_VAR 0 1
2214: PUSH
2215: LD_INT 2
2217: MUL
2218: ARRAY
2219: ST_TO_ADDR
// ComAgressiveMove ( us_patrol_2 , x , y ) ;
2220: LD_EXP 26
2224: PPUSH
2225: LD_VAR 0 2
2229: PPUSH
2230: LD_VAR 0 3
2234: PPUSH
2235: CALL_OW 114
// repeat wait ( 0 0$3 ) ;
2239: LD_INT 105
2241: PPUSH
2242: CALL_OW 67
// y := true ;
2246: LD_ADDR_VAR 0 3
2250: PUSH
2251: LD_INT 1
2253: ST_TO_ADDR
// for x in us_patrol_2 do
2254: LD_ADDR_VAR 0 2
2258: PUSH
2259: LD_EXP 26
2263: PUSH
2264: FOR_IN
2265: IFFALSE 2288
// if IsBusy ( x ) then
2267: LD_VAR 0 2
2271: PPUSH
2272: CALL_OW 315
2276: IFFALSE 2286
// y := false ;
2278: LD_ADDR_VAR 0 3
2282: PUSH
2283: LD_INT 0
2285: ST_TO_ADDR
2286: GO 2264
2288: POP
2289: POP
// until y ;
2290: LD_VAR 0 3
2294: IFFALSE 2239
// end ;
2296: GO 2173
2298: POP
2299: POP
// until ( not us_patrol_2 ) or ( blast_countdown ) ;
2300: LD_EXP 26
2304: NOT
2305: PUSH
2306: LD_EXP 27
2310: OR
2311: IFFALSE 2154
// if us_patrol_2 then
2313: LD_EXP 26
2317: IFFALSE 2357
// begin ComAgressiveMove ( us_patrol_2 , 56 , 77 ) ;
2319: LD_EXP 26
2323: PPUSH
2324: LD_INT 56
2326: PPUSH
2327: LD_INT 77
2329: PPUSH
2330: CALL_OW 114
// us_sol := us_sol ^ us_patrol_2 ;
2334: LD_ADDR_EXP 21
2338: PUSH
2339: LD_EXP 21
2343: PUSH
2344: LD_EXP 26
2348: ADD
2349: ST_TO_ADDR
// us_patrol_2 := [ ] ;
2350: LD_ADDR_EXP 26
2354: PUSH
2355: EMPTY
2356: ST_TO_ADDR
// end ; end ;
2357: PPOPN 4
2359: END
// function prepare_us_patrol ; var i , un , done , sol_lev ; begin
2360: LD_INT 0
2362: PPUSH
2363: PPUSH
2364: PPUSH
2365: PPUSH
2366: PPUSH
// done := 0 ;
2367: LD_ADDR_VAR 0 4
2371: PUSH
2372: LD_INT 0
2374: ST_TO_ADDR
// sol_lev := [ 4 , 5 , 8 ] [ difficulty ] ;
2375: LD_ADDR_VAR 0 5
2379: PUSH
2380: LD_INT 4
2382: PUSH
2383: LD_INT 5
2385: PUSH
2386: LD_INT 8
2388: PUSH
2389: EMPTY
2390: LIST
2391: LIST
2392: LIST
2393: PUSH
2394: LD_OWVAR 67
2398: ARRAY
2399: ST_TO_ADDR
// us_patrol_1 := [ ] ;
2400: LD_ADDR_EXP 25
2404: PUSH
2405: EMPTY
2406: ST_TO_ADDR
// us_patrol_2 := [ ] ;
2407: LD_ADDR_EXP 26
2411: PUSH
2412: EMPTY
2413: ST_TO_ADDR
// uc_nation := nation_american ;
2414: LD_ADDR_OWVAR 21
2418: PUSH
2419: LD_INT 1
2421: ST_TO_ADDR
// uc_side := americans ;
2422: LD_ADDR_OWVAR 20
2426: PUSH
2427: LD_EXP 17
2431: ST_TO_ADDR
// for i = 1 to ( difficulty + 1 ) do
2432: LD_ADDR_VAR 0 2
2436: PUSH
2437: DOUBLE
2438: LD_INT 1
2440: DEC
2441: ST_TO_ADDR
2442: LD_OWVAR 67
2446: PUSH
2447: LD_INT 1
2449: PLUS
2450: PUSH
2451: FOR_TO
2452: IFFALSE 2600
// begin done := done + 1 ;
2454: LD_ADDR_VAR 0 4
2458: PUSH
2459: LD_VAR 0 4
2463: PUSH
2464: LD_INT 1
2466: PLUS
2467: ST_TO_ADDR
// PrepareSoldier ( 0 , sol_lev + Rand ( 0 , 2 ) ) ;
2468: LD_INT 0
2470: PPUSH
2471: LD_VAR 0 5
2475: PUSH
2476: LD_INT 0
2478: PPUSH
2479: LD_INT 2
2481: PPUSH
2482: CALL_OW 12
2486: PLUS
2487: PPUSH
2488: CALL_OW 381
// un := CreateHuman ;
2492: LD_ADDR_VAR 0 3
2496: PUSH
2497: CALL_OW 44
2501: ST_TO_ADDR
// if ( difficulty = 3 ) and ( done > 2 ) then
2502: LD_OWVAR 67
2506: PUSH
2507: LD_INT 3
2509: EQUAL
2510: PUSH
2511: LD_VAR 0 4
2515: PUSH
2516: LD_INT 2
2518: GREATER
2519: AND
2520: IFFALSE 2561
// begin us_patrol_2 := us_patrol_2 ^ un ;
2522: LD_ADDR_EXP 26
2526: PUSH
2527: LD_EXP 26
2531: PUSH
2532: LD_VAR 0 3
2536: ADD
2537: ST_TO_ADDR
// PlaceUnitXYR ( un , 158 , 21 , 2 , false ) ;
2538: LD_VAR 0 3
2542: PPUSH
2543: LD_INT 158
2545: PPUSH
2546: LD_INT 21
2548: PPUSH
2549: LD_INT 2
2551: PPUSH
2552: LD_INT 0
2554: PPUSH
2555: CALL_OW 50
// end else
2559: GO 2598
// begin us_patrol_1 := us_patrol_1 ^ un ;
2561: LD_ADDR_EXP 25
2565: PUSH
2566: LD_EXP 25
2570: PUSH
2571: LD_VAR 0 3
2575: ADD
2576: ST_TO_ADDR
// PlaceUnitXYR ( un , 101 , 39 , 2 , false ) ;
2577: LD_VAR 0 3
2581: PPUSH
2582: LD_INT 101
2584: PPUSH
2585: LD_INT 39
2587: PPUSH
2588: LD_INT 2
2590: PPUSH
2591: LD_INT 0
2593: PPUSH
2594: CALL_OW 50
// end ; end ;
2598: GO 2451
2600: POP
2601: POP
// enable ( 2 ) ;
2602: LD_INT 2
2604: ENABLE_MARKED
// if difficulty = 3 then
2605: LD_OWVAR 67
2609: PUSH
2610: LD_INT 3
2612: EQUAL
2613: IFFALSE 2618
// enable ( 3 ) ;
2615: LD_INT 3
2617: ENABLE_MARKED
// end ;
2618: LD_VAR 0 1
2622: RET
// function prepare_us_base ; var i , un , b_list ; begin
2623: LD_INT 0
2625: PPUSH
2626: PPUSH
2627: PPUSH
2628: PPUSH
// us_sol := [ ] ;
2629: LD_ADDR_EXP 21
2633: PUSH
2634: EMPTY
2635: ST_TO_ADDR
// us_sci := [ ] ;
2636: LD_ADDR_EXP 22
2640: PUSH
2641: EMPTY
2642: ST_TO_ADDR
// uc_nation := nation_american ;
2643: LD_ADDR_OWVAR 21
2647: PUSH
2648: LD_INT 1
2650: ST_TO_ADDR
// uc_side := americans ;
2651: LD_ADDR_OWVAR 20
2655: PUSH
2656: LD_EXP 17
2660: ST_TO_ADDR
// for i = 1 to ( difficulty + 3 ) do
2661: LD_ADDR_VAR 0 2
2665: PUSH
2666: DOUBLE
2667: LD_INT 1
2669: DEC
2670: ST_TO_ADDR
2671: LD_OWVAR 67
2675: PUSH
2676: LD_INT 3
2678: PLUS
2679: PUSH
2680: FOR_TO
2681: IFFALSE 2759
// begin PrepareSoldier ( 0 , [ 3 , 6 , 9 ] [ difficulty ] ) ;
2683: LD_INT 0
2685: PPUSH
2686: LD_INT 3
2688: PUSH
2689: LD_INT 6
2691: PUSH
2692: LD_INT 9
2694: PUSH
2695: EMPTY
2696: LIST
2697: LIST
2698: LIST
2699: PUSH
2700: LD_OWVAR 67
2704: ARRAY
2705: PPUSH
2706: CALL_OW 381
// un := CreateHuman ;
2710: LD_ADDR_VAR 0 3
2714: PUSH
2715: CALL_OW 44
2719: ST_TO_ADDR
// us_sol := us_sol ^ un ;
2720: LD_ADDR_EXP 21
2724: PUSH
2725: LD_EXP 21
2729: PUSH
2730: LD_VAR 0 3
2734: ADD
2735: ST_TO_ADDR
// PlaceUnitXYR ( un , 55 , 75 , 4 , false ) ;
2736: LD_VAR 0 3
2740: PPUSH
2741: LD_INT 55
2743: PPUSH
2744: LD_INT 75
2746: PPUSH
2747: LD_INT 4
2749: PPUSH
2750: LD_INT 0
2752: PPUSH
2753: CALL_OW 50
// end ;
2757: GO 2680
2759: POP
2760: POP
// for i := 1 to 4 do
2761: LD_ADDR_VAR 0 2
2765: PUSH
2766: DOUBLE
2767: LD_INT 1
2769: DEC
2770: ST_TO_ADDR
2771: LD_INT 4
2773: PUSH
2774: FOR_TO
2775: IFFALSE 2842
// begin PrepareScientist ( sex_male , 6 + Rand ( 0 , 3 ) ) ;
2777: LD_INT 1
2779: PPUSH
2780: LD_INT 6
2782: PUSH
2783: LD_INT 0
2785: PPUSH
2786: LD_INT 3
2788: PPUSH
2789: CALL_OW 12
2793: PLUS
2794: PPUSH
2795: CALL_OW 384
// un := CreateHuman ;
2799: LD_ADDR_VAR 0 3
2803: PUSH
2804: CALL_OW 44
2808: ST_TO_ADDR
// us_sci := us_sci ^ un ;
2809: LD_ADDR_EXP 22
2813: PUSH
2814: LD_EXP 22
2818: PUSH
2819: LD_VAR 0 3
2823: ADD
2824: ST_TO_ADDR
// PlaceUnitArea ( un , us_base , false ) ;
2825: LD_VAR 0 3
2829: PPUSH
2830: LD_INT 1
2832: PPUSH
2833: LD_INT 0
2835: PPUSH
2836: CALL_OW 49
// end ;
2840: GO 2774
2842: POP
2843: POP
// PrepareMechanic ( 0 , [ 4 , 6 , 9 ] [ difficulty ] ) ;
2844: LD_INT 0
2846: PPUSH
2847: LD_INT 4
2849: PUSH
2850: LD_INT 6
2852: PUSH
2853: LD_INT 9
2855: PUSH
2856: EMPTY
2857: LIST
2858: LIST
2859: LIST
2860: PUSH
2861: LD_OWVAR 67
2865: ARRAY
2866: PPUSH
2867: CALL_OW 383
// us_mech := CreateHuman ;
2871: LD_ADDR_EXP 23
2875: PUSH
2876: CALL_OW 44
2880: ST_TO_ADDR
// PlaceUnitArea ( us_mech , am_repair , false ) ;
2881: LD_EXP 23
2885: PPUSH
2886: LD_INT 11
2888: PPUSH
2889: LD_INT 0
2891: PPUSH
2892: CALL_OW 49
// ComEnterUnit ( us_mech , crane ) ;
2896: LD_EXP 23
2900: PPUSH
2901: LD_INT 15
2903: PPUSH
2904: CALL_OW 120
// if Stevens then
2908: LD_EXP 5
2912: IFFALSE 2945
// begin PlaceUnitArea ( Stevens , us_base , false ) ;
2914: LD_EXP 5
2918: PPUSH
2919: LD_INT 1
2921: PPUSH
2922: LD_INT 0
2924: PPUSH
2925: CALL_OW 49
// us_sci := us_sci ^ Stevens ;
2929: LD_ADDR_EXP 22
2933: PUSH
2934: LD_EXP 22
2938: PUSH
2939: LD_EXP 5
2943: ADD
2944: ST_TO_ADDR
// end ; ComEnterUnit ( us_sci , us_lab ) ;
2945: LD_EXP 22
2949: PPUSH
2950: LD_INT 1
2952: PPUSH
2953: CALL_OW 120
// b_list := FilterAllUnits ( [ [ f_side , americans ] , [ f_btype , b_bunker ] ] ) ;
2957: LD_ADDR_VAR 0 4
2961: PUSH
2962: LD_INT 22
2964: PUSH
2965: LD_EXP 17
2969: PUSH
2970: EMPTY
2971: LIST
2972: LIST
2973: PUSH
2974: LD_INT 30
2976: PUSH
2977: LD_INT 32
2979: PUSH
2980: EMPTY
2981: LIST
2982: LIST
2983: PUSH
2984: EMPTY
2985: LIST
2986: LIST
2987: PPUSH
2988: CALL_OW 69
2992: ST_TO_ADDR
// for i = 1 to b_list do
2993: LD_ADDR_VAR 0 2
2997: PUSH
2998: DOUBLE
2999: LD_INT 1
3001: DEC
3002: ST_TO_ADDR
3003: LD_VAR 0 4
3007: PUSH
3008: FOR_TO
3009: IFFALSE 3039
// ComEnterUnit ( us_sol [ i ] , b_list [ i ] ) ;
3011: LD_EXP 21
3015: PUSH
3016: LD_VAR 0 2
3020: ARRAY
3021: PPUSH
3022: LD_VAR 0 4
3026: PUSH
3027: LD_VAR 0 2
3031: ARRAY
3032: PPUSH
3033: CALL_OW 120
3037: GO 3008
3039: POP
3040: POP
// us_all_units := FilterAllUnits ( [ [ f_side , americans ] , [ f_type , unit_human ] ] ) ;
3041: LD_ADDR_EXP 24
3045: PUSH
3046: LD_INT 22
3048: PUSH
3049: LD_EXP 17
3053: PUSH
3054: EMPTY
3055: LIST
3056: LIST
3057: PUSH
3058: LD_INT 21
3060: PUSH
3061: LD_INT 1
3063: PUSH
3064: EMPTY
3065: LIST
3066: LIST
3067: PUSH
3068: EMPTY
3069: LIST
3070: LIST
3071: PPUSH
3072: CALL_OW 69
3076: ST_TO_ADDR
// end ;
3077: LD_VAR 0 1
3081: RET
// export function prepare_us_side ; begin
3082: LD_INT 0
3084: PPUSH
// prepare_us_base ;
3085: CALL 2623 0 0
// prepare_us_patrol ;
3089: CALL 2360 0 0
// end ;
3093: LD_VAR 0 1
3097: RET
// every 0 0$1 trigger IsInArea ( truck1 , half_line ) or IsInArea ( truck2 , half_line ) do
3098: LD_EXP 6
3102: PPUSH
3103: LD_INT 5
3105: PPUSH
3106: CALL_OW 308
3110: PUSH
3111: LD_EXP 7
3115: PPUSH
3116: LD_INT 5
3118: PPUSH
3119: CALL_OW 308
3123: OR
3124: IFFALSE 3132
3126: GO 3128
3128: DISABLE
// begin enable ( 1 ) ;
3129: LD_INT 1
3131: ENABLE_MARKED
// end ;
3132: END
// every 0 0$1 trigger FilterUnitsInArea ( us_hunt , [ [ f_side , you ] ] ) marked 1 do var list ;
3133: LD_INT 3
3135: PPUSH
3136: LD_INT 22
3138: PUSH
3139: LD_EXP 16
3143: PUSH
3144: EMPTY
3145: LIST
3146: LIST
3147: PUSH
3148: EMPTY
3149: LIST
3150: PPUSH
3151: CALL_OW 70
3155: IFFALSE 3250
3157: GO 3159
3159: DISABLE
3160: LD_INT 0
3162: PPUSH
// begin list := FilterUnitsInArea ( us_hunt , [ [ f_side , you ] ] ) ;
3163: LD_ADDR_VAR 0 1
3167: PUSH
3168: LD_INT 3
3170: PPUSH
3171: LD_INT 22
3173: PUSH
3174: LD_EXP 16
3178: PUSH
3179: EMPTY
3180: LIST
3181: LIST
3182: PUSH
3183: EMPTY
3184: LIST
3185: PPUSH
3186: CALL_OW 70
3190: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3191: LD_INT 35
3193: PPUSH
3194: CALL_OW 67
// until not FilterUnitsInArea ( us_hunt , [ [ f_side , you ] ] ) ;
3198: LD_INT 3
3200: PPUSH
3201: LD_INT 22
3203: PUSH
3204: LD_EXP 16
3208: PUSH
3209: EMPTY
3210: LIST
3211: LIST
3212: PUSH
3213: EMPTY
3214: LIST
3215: PPUSH
3216: CALL_OW 70
3220: NOT
3221: IFFALSE 3191
// if list then
3223: LD_VAR 0 1
3227: IFFALSE 3242
// American_Hunt ( list [ 1 ] ) ;
3229: LD_VAR 0 1
3233: PUSH
3234: LD_INT 1
3236: ARRAY
3237: PPUSH
3238: CALL 3253 0 1
// if not query_started then
3242: LD_EXP 29
3246: NOT
3247: IFFALSE 3250
// enable ;
3249: ENABLE
// end ;
3250: PPOPN 1
3252: END
// function American_Hunt ( un ) ; var i , b_list ; begin
3253: LD_INT 0
3255: PPUSH
3256: PPUSH
3257: PPUSH
// ComExitBuilding ( us_sol ) ;
3258: LD_EXP 21
3262: PPUSH
3263: CALL_OW 122
// Wait ( 0 0$0.5 ) ;
3267: LD_INT 18
3269: PPUSH
3270: CALL_OW 67
// repeat ComAgressiveMove ( us_sol , GetX ( un ) , GetY ( un ) ) ;
3274: LD_EXP 21
3278: PPUSH
3279: LD_VAR 0 1
3283: PPUSH
3284: CALL_OW 250
3288: PPUSH
3289: LD_VAR 0 1
3293: PPUSH
3294: CALL_OW 251
3298: PPUSH
3299: CALL_OW 114
// wait ( 0 0$1 ) ;
3303: LD_INT 35
3305: PPUSH
3306: CALL_OW 67
// until not See ( americans , un ) or query_started ;
3310: LD_EXP 17
3314: PPUSH
3315: LD_VAR 0 1
3319: PPUSH
3320: CALL_OW 292
3324: NOT
3325: PUSH
3326: LD_EXP 29
3330: OR
3331: IFFALSE 3274
// b_list := FilterAllUnits ( [ [ f_side , americans ] , [ f_btype , b_bunker ] ] ) ;
3333: LD_ADDR_VAR 0 4
3337: PUSH
3338: LD_INT 22
3340: PUSH
3341: LD_EXP 17
3345: PUSH
3346: EMPTY
3347: LIST
3348: LIST
3349: PUSH
3350: LD_INT 30
3352: PUSH
3353: LD_INT 32
3355: PUSH
3356: EMPTY
3357: LIST
3358: LIST
3359: PUSH
3360: EMPTY
3361: LIST
3362: LIST
3363: PPUSH
3364: CALL_OW 69
3368: ST_TO_ADDR
// for i = 1 to us_sol do
3369: LD_ADDR_VAR 0 3
3373: PUSH
3374: DOUBLE
3375: LD_INT 1
3377: DEC
3378: ST_TO_ADDR
3379: LD_EXP 21
3383: PUSH
3384: FOR_TO
3385: IFFALSE 3451
// if i <= ( 0 + b_list ) then
3387: LD_VAR 0 3
3391: PUSH
3392: LD_INT 0
3394: PUSH
3395: LD_VAR 0 4
3399: PLUS
3400: LESSEQUAL
3401: IFFALSE 3431
// ComEnterUnit ( us_sol [ i ] , b_list [ i ] ) else
3403: LD_EXP 21
3407: PUSH
3408: LD_VAR 0 3
3412: ARRAY
3413: PPUSH
3414: LD_VAR 0 4
3418: PUSH
3419: LD_VAR 0 3
3423: ARRAY
3424: PPUSH
3425: CALL_OW 120
3429: GO 3449
// ComMoveToArea ( us_sol [ i ] , parking ) ;
3431: LD_EXP 21
3435: PUSH
3436: LD_VAR 0 3
3440: ARRAY
3441: PPUSH
3442: LD_INT 10
3444: PPUSH
3445: CALL_OW 113
3449: GO 3384
3451: POP
3452: POP
// wait ( 0 0$5 ) ;
3453: LD_INT 175
3455: PPUSH
3456: CALL_OW 67
// end ;
3460: LD_VAR 0 2
3464: RET
// every 0 0$5 marked 7 do var difficulty_time ;
3465: GO 3467
3467: DISABLE
3468: LD_INT 0
3470: PPUSH
// begin difficulty_time := [ 25 25$0 , 15 15$0 , 10 10$0 ] [ difficulty ] ;
3471: LD_ADDR_VAR 0 1
3475: PUSH
3476: LD_INT 52500
3478: PUSH
3479: LD_INT 31500
3481: PUSH
3482: LD_INT 21000
3484: PUSH
3485: EMPTY
3486: LIST
3487: LIST
3488: LIST
3489: PUSH
3490: LD_OWVAR 67
3494: ARRAY
3495: ST_TO_ADDR
// Wait ( difficulty_time ) ;
3496: LD_VAR 0 1
3500: PPUSH
3501: CALL_OW 67
// americans_leaving ;
3505: CALL 3520 0 0
// end ;
3509: PPOPN 1
3511: END
// every 0 0$1 marked 10 do
3512: GO 3514
3514: DISABLE
// begin americans_leaving ;
3515: CALL 3520 0 0
// end ;
3519: END
// function americans_leaving ; var un , list , i , max , vehicles ; begin
3520: LD_INT 0
3522: PPUSH
3523: PPUSH
3524: PPUSH
3525: PPUSH
3526: PPUSH
3527: PPUSH
// keep_base_finished := true ;
3528: LD_ADDR_EXP 15
3532: PUSH
3533: LD_INT 1
3535: ST_TO_ADDR
// ComExitBuilding ( us_sol ) ;
3536: LD_EXP 21
3540: PPUSH
3541: CALL_OW 122
// ComExitBuilding ( us_sci ) ;
3545: LD_EXP 22
3549: PPUSH
3550: CALL_OW 122
// wait ( 0 0$1 ) ;
3554: LD_INT 35
3556: PPUSH
3557: CALL_OW 67
// list := FilterAllUnits ( [ [ f_side , americans ] , [ f_type , unit_human ] ] ) ;
3561: LD_ADDR_VAR 0 3
3565: PUSH
3566: LD_INT 22
3568: PUSH
3569: LD_EXP 17
3573: PUSH
3574: EMPTY
3575: LIST
3576: LIST
3577: PUSH
3578: LD_INT 21
3580: PUSH
3581: LD_INT 1
3583: PUSH
3584: EMPTY
3585: LIST
3586: LIST
3587: PUSH
3588: EMPTY
3589: LIST
3590: LIST
3591: PPUSH
3592: CALL_OW 69
3596: ST_TO_ADDR
// ComMoveToArea ( list , leave_area ) ;
3597: LD_VAR 0 3
3601: PPUSH
3602: LD_INT 8
3604: PPUSH
3605: CALL_OW 113
// vehicles := FilterUnitsInArea ( us_base , [ [ f_side , americans ] , [ f_type , unit_vehicle ] , [ f_not , [ f_occupied ] ] ] ) ;
3609: LD_ADDR_VAR 0 6
3613: PUSH
3614: LD_INT 1
3616: PPUSH
3617: LD_INT 22
3619: PUSH
3620: LD_EXP 17
3624: PUSH
3625: EMPTY
3626: LIST
3627: LIST
3628: PUSH
3629: LD_INT 21
3631: PUSH
3632: LD_INT 2
3634: PUSH
3635: EMPTY
3636: LIST
3637: LIST
3638: PUSH
3639: LD_INT 3
3641: PUSH
3642: LD_INT 59
3644: PUSH
3645: EMPTY
3646: LIST
3647: PUSH
3648: EMPTY
3649: LIST
3650: LIST
3651: PUSH
3652: EMPTY
3653: LIST
3654: LIST
3655: LIST
3656: PPUSH
3657: CALL_OW 70
3661: ST_TO_ADDR
// if ( 0 + vehicles ) < list then
3662: LD_INT 0
3664: PUSH
3665: LD_VAR 0 6
3669: PLUS
3670: PUSH
3671: LD_VAR 0 3
3675: LESS
3676: IFFALSE 3694
// max := 0 + vehicles else
3678: LD_ADDR_VAR 0 5
3682: PUSH
3683: LD_INT 0
3685: PUSH
3686: LD_VAR 0 6
3690: PLUS
3691: ST_TO_ADDR
3692: GO 3708
// max := 0 + list ;
3694: LD_ADDR_VAR 0 5
3698: PUSH
3699: LD_INT 0
3701: PUSH
3702: LD_VAR 0 3
3706: PLUS
3707: ST_TO_ADDR
// if vehicles and list then
3708: LD_VAR 0 6
3712: PUSH
3713: LD_VAR 0 3
3717: AND
3718: IFFALSE 3786
// for i = 1 to max do
3720: LD_ADDR_VAR 0 4
3724: PUSH
3725: DOUBLE
3726: LD_INT 1
3728: DEC
3729: ST_TO_ADDR
3730: LD_VAR 0 5
3734: PUSH
3735: FOR_TO
3736: IFFALSE 3784
// begin ComEnterUnit ( list [ i ] , vehicles [ i ] ) ;
3738: LD_VAR 0 3
3742: PUSH
3743: LD_VAR 0 4
3747: ARRAY
3748: PPUSH
3749: LD_VAR 0 6
3753: PUSH
3754: LD_VAR 0 4
3758: ARRAY
3759: PPUSH
3760: CALL_OW 120
// AddComMoveToArea ( list [ i ] , leave_area ) ;
3764: LD_VAR 0 3
3768: PUSH
3769: LD_VAR 0 4
3773: ARRAY
3774: PPUSH
3775: LD_INT 8
3777: PPUSH
3778: CALL_OW 173
// end ;
3782: GO 3735
3784: POP
3785: POP
// time_out := true ;
3786: LD_ADDR_EXP 10
3790: PUSH
3791: LD_INT 1
3793: ST_TO_ADDR
// enable ( 9 ) ;
3794: LD_INT 9
3796: ENABLE_MARKED
// repeat list := FilterAllUnits ( [ [ f_side , americans ] , [ f_type , unit_human ] , [ f_placed ] , [ f_ok ] ] ) ;
3797: LD_ADDR_VAR 0 3
3801: PUSH
3802: LD_INT 22
3804: PUSH
3805: LD_EXP 17
3809: PUSH
3810: EMPTY
3811: LIST
3812: LIST
3813: PUSH
3814: LD_INT 21
3816: PUSH
3817: LD_INT 1
3819: PUSH
3820: EMPTY
3821: LIST
3822: LIST
3823: PUSH
3824: LD_INT 52
3826: PUSH
3827: EMPTY
3828: LIST
3829: PUSH
3830: LD_INT 50
3832: PUSH
3833: EMPTY
3834: LIST
3835: PUSH
3836: EMPTY
3837: LIST
3838: LIST
3839: LIST
3840: LIST
3841: PPUSH
3842: CALL_OW 69
3846: ST_TO_ADDR
// for un in list do
3847: LD_ADDR_VAR 0 2
3851: PUSH
3852: LD_VAR 0 3
3856: PUSH
3857: FOR_IN
3858: IFFALSE 3886
// if not HasTask ( un ) then
3860: LD_VAR 0 2
3864: PPUSH
3865: CALL_OW 314
3869: NOT
3870: IFFALSE 3884
// ComMoveToArea ( un , leave_area ) ;
3872: LD_VAR 0 2
3876: PPUSH
3877: LD_INT 8
3879: PPUSH
3880: CALL_OW 113
3884: GO 3857
3886: POP
3887: POP
// wait ( 0 0$1 ) ;
3888: LD_INT 35
3890: PPUSH
3891: CALL_OW 67
// until not list ;
3895: LD_VAR 0 3
3899: NOT
3900: IFFALSE 3797
// if not query_started then
3902: LD_EXP 29
3906: NOT
3907: IFFALSE 3916
// Mission_Failed ( 3 ) ;
3909: LD_INT 3
3911: PPUSH
3912: CALL 1487 0 1
// end ;
3916: LD_VAR 0 1
3920: RET
// every 0 0$1 trigger FilterUnitsInArea ( leave_area , [ [ f_side , americans ] ] ) marked 9 do var list , un , max ;
3921: LD_INT 8
3923: PPUSH
3924: LD_INT 22
3926: PUSH
3927: LD_EXP 17
3931: PUSH
3932: EMPTY
3933: LIST
3934: LIST
3935: PUSH
3936: EMPTY
3937: LIST
3938: PPUSH
3939: CALL_OW 70
3943: IFFALSE 4066
3945: GO 3947
3947: DISABLE
3948: LD_INT 0
3950: PPUSH
3951: PPUSH
3952: PPUSH
// begin list := FilterUnitsInArea ( leave_area , [ [ f_side , americans ] ] ) ;
3953: LD_ADDR_VAR 0 1
3957: PUSH
3958: LD_INT 8
3960: PPUSH
3961: LD_INT 22
3963: PUSH
3964: LD_EXP 17
3968: PUSH
3969: EMPTY
3970: LIST
3971: LIST
3972: PUSH
3973: EMPTY
3974: LIST
3975: PPUSH
3976: CALL_OW 70
3980: ST_TO_ADDR
// for un in list do
3981: LD_ADDR_VAR 0 2
3985: PUSH
3986: LD_VAR 0 1
3990: PUSH
3991: FOR_IN
3992: IFFALSE 4063
// begin if un in us_sci then
3994: LD_VAR 0 2
3998: PUSH
3999: LD_EXP 22
4003: IN
4004: IFFALSE 4022
// us_sci := us_sci diff un ;
4006: LD_ADDR_EXP 22
4010: PUSH
4011: LD_EXP 22
4015: PUSH
4016: LD_VAR 0 2
4020: DIFF
4021: ST_TO_ADDR
// max := IsInUnit ( un ) ;
4022: LD_ADDR_VAR 0 3
4026: PUSH
4027: LD_VAR 0 2
4031: PPUSH
4032: CALL_OW 310
4036: ST_TO_ADDR
// RemoveUnit ( un ) ;
4037: LD_VAR 0 2
4041: PPUSH
4042: CALL_OW 64
// if max then
4046: LD_VAR 0 3
4050: IFFALSE 4061
// RemoveUnit ( max ) ;
4052: LD_VAR 0 3
4056: PPUSH
4057: CALL_OW 64
// end ;
4061: GO 3991
4063: POP
4064: POP
// enable ;
4065: ENABLE
// end ; end_of_file
4066: PPOPN 3
4068: END
// on UnitDestroyed ( un ) do begin if GetSide ( un ) = americans then
4069: LD_VAR 0 1
4073: PPUSH
4074: CALL_OW 255
4078: PUSH
4079: LD_EXP 17
4083: EQUAL
4084: IFFALSE 4177
// begin us_patrol_1 := us_patrol_1 diff un ;
4086: LD_ADDR_EXP 25
4090: PUSH
4091: LD_EXP 25
4095: PUSH
4096: LD_VAR 0 1
4100: DIFF
4101: ST_TO_ADDR
// us_patrol_2 := us_patrol_2 diff un ;
4102: LD_ADDR_EXP 26
4106: PUSH
4107: LD_EXP 26
4111: PUSH
4112: LD_VAR 0 1
4116: DIFF
4117: ST_TO_ADDR
// us_sci := us_sci diff un ;
4118: LD_ADDR_EXP 22
4122: PUSH
4123: LD_EXP 22
4127: PUSH
4128: LD_VAR 0 1
4132: DIFF
4133: ST_TO_ADDR
// us_sol := us_sol diff un ;
4134: LD_ADDR_EXP 21
4138: PUSH
4139: LD_EXP 21
4143: PUSH
4144: LD_VAR 0 1
4148: DIFF
4149: ST_TO_ADDR
// if ( not us_sci ) and lab_destroyed and ( not technology_taken ) then
4150: LD_EXP 22
4154: NOT
4155: PUSH
4156: LD_EXP 9
4160: AND
4161: PUSH
4162: LD_EXP 14
4166: NOT
4167: AND
4168: IFFALSE 4177
// Mission_Failed ( 5 ) ;
4170: LD_INT 5
4172: PPUSH
4173: CALL 1487 0 1
// end ; if un = Burlak then
4177: LD_VAR 0 1
4181: PUSH
4182: LD_EXP 2
4186: EQUAL
4187: IFFALSE 4196
// Mission_Failed ( 1 ) ;
4189: LD_INT 1
4191: PPUSH
4192: CALL 1487 0 1
// if un = MacMillan then
4196: LD_VAR 0 1
4200: PUSH
4201: LD_EXP 1
4205: EQUAL
4206: IFFALSE 4215
// Mission_Failed ( 2 ) ;
4208: LD_INT 2
4210: PPUSH
4211: CALL 1487 0 1
// if ( un = us_lab ) then
4215: LD_VAR 0 1
4219: PUSH
4220: LD_INT 1
4222: EQUAL
4223: IFFALSE 4264
// begin lab_destroyed := true ;
4225: LD_ADDR_EXP 9
4229: PUSH
4230: LD_INT 1
4232: ST_TO_ADDR
// if not ( us_sci or technology_taken ) then
4233: LD_EXP 22
4237: PUSH
4238: LD_EXP 14
4242: OR
4243: NOT
4244: IFFALSE 4253
// Mission_Failed ( 5 ) ;
4246: LD_INT 5
4248: PPUSH
4249: CALL 1487 0 1
// if not query_started then
4253: LD_EXP 29
4257: NOT
4258: IFFALSE 4264
// query_kill ;
4260: CALL 6072 0 0
// end ; if ( GetSide ( un ) = you ) and ( GetType ( un ) = unit_vehicle ) and ( GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay ] ) then
4264: LD_VAR 0 1
4268: PPUSH
4269: CALL_OW 255
4273: PUSH
4274: LD_EXP 16
4278: EQUAL
4279: PUSH
4280: LD_VAR 0 1
4284: PPUSH
4285: CALL_OW 247
4289: PUSH
4290: LD_INT 2
4292: EQUAL
4293: AND
4294: PUSH
4295: LD_VAR 0 1
4299: PPUSH
4300: CALL_OW 264
4304: PUSH
4305: LD_INT 12
4307: PUSH
4308: LD_INT 51
4310: PUSH
4311: EMPTY
4312: LIST
4313: LIST
4314: IN
4315: AND
4316: IFFALSE 4325
// Mission_Failed ( 6 ) ;
4318: LD_INT 6
4320: PPUSH
4321: CALL 1487 0 1
// end ;
4325: PPOPN 1
4327: END
// on UnitGoesToRed ( un ) do begin if un in [ Burlak , MacMillan ] and not FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_building ] , [ f_btype , b_lab ] ] ) then
4328: LD_VAR 0 1
4332: PUSH
4333: LD_EXP 2
4337: PUSH
4338: LD_EXP 1
4342: PUSH
4343: EMPTY
4344: LIST
4345: LIST
4346: IN
4347: PUSH
4348: LD_INT 22
4350: PUSH
4351: LD_EXP 16
4355: PUSH
4356: EMPTY
4357: LIST
4358: LIST
4359: PUSH
4360: LD_INT 21
4362: PUSH
4363: LD_INT 3
4365: PUSH
4366: EMPTY
4367: LIST
4368: LIST
4369: PUSH
4370: LD_INT 30
4372: PUSH
4373: LD_INT 6
4375: PUSH
4376: EMPTY
4377: LIST
4378: LIST
4379: PUSH
4380: EMPTY
4381: LIST
4382: LIST
4383: LIST
4384: PPUSH
4385: CALL_OW 69
4389: NOT
4390: AND
4391: IFFALSE 4431
// begin if un = Burlak then
4393: LD_VAR 0 1
4397: PUSH
4398: LD_EXP 2
4402: EQUAL
4403: IFFALSE 4412
// Mission_Failed ( 1 ) ;
4405: LD_INT 1
4407: PPUSH
4408: CALL 1487 0 1
// if un = MacMillan then
4412: LD_VAR 0 1
4416: PUSH
4417: LD_EXP 1
4421: EQUAL
4422: IFFALSE 4431
// Mission_Failed ( 2 ) ;
4424: LD_INT 2
4426: PPUSH
4427: CALL 1487 0 1
// end ; if ( un = us_lab ) and ( not query_started ) then
4431: LD_VAR 0 1
4435: PUSH
4436: LD_INT 1
4438: EQUAL
4439: PUSH
4440: LD_EXP 29
4444: NOT
4445: AND
4446: IFFALSE 4452
// query_kill ;
4448: CALL 6072 0 0
// end ;
4452: PPOPN 1
4454: END
// on BuildingCaptured ( building , orig_side , engeneer ) do begin if ( building = us_depot ) and ( not query_started ) and ( not time_out ) then
4455: LD_VAR 0 1
4459: PUSH
4460: LD_INT 5
4462: EQUAL
4463: PUSH
4464: LD_EXP 29
4468: NOT
4469: AND
4470: PUSH
4471: LD_EXP 10
4475: NOT
4476: AND
4477: IFFALSE 4483
// query_kill ;
4479: CALL 6072 0 0
// if ( building = us_lab ) then
4483: LD_VAR 0 1
4487: PUSH
4488: LD_INT 1
4490: EQUAL
4491: IFFALSE 4505
// begin technology_taken := true ;
4493: LD_ADDR_EXP 14
4497: PUSH
4498: LD_INT 1
4500: ST_TO_ADDR
// konecny_rozhovor ;
4501: CALL 6997 0 0
// end ; end ;
4505: PPOPN 3
4507: END
// on ArtifactLoaded ( un , size ) do begin if not art_picked then
4508: LD_EXP 31
4512: NOT
4513: IFFALSE 4527
// begin art_picked := true ;
4515: LD_ADDR_EXP 31
4519: PUSH
4520: LD_INT 1
4522: ST_TO_ADDR
// Artefact_Picked ;
4523: CALL 5168 0 0
// end ; art_cargo := un ;
4527: LD_ADDR_EXP 32
4531: PUSH
4532: LD_VAR 0 1
4536: ST_TO_ADDR
// end ;
4537: PPOPN 2
4539: END
// on ArtifactUnloaded ( un , size ) do begin art_cargo := false ;
4540: LD_ADDR_EXP 32
4544: PUSH
4545: LD_INT 0
4547: ST_TO_ADDR
// end ; end_of_file
4548: PPOPN 2
4550: END
// every 0 0$2 do var un , animal_out ;
4551: GO 4553
4553: DISABLE
4554: LD_INT 0
4556: PPUSH
4557: PPUSH
// begin animal_out := FilterAllUnits ( [ [ f_nation , nation_nature ] ] ) ;
4558: LD_ADDR_VAR 0 2
4562: PUSH
4563: LD_INT 23
4565: PUSH
4566: LD_INT 0
4568: PUSH
4569: EMPTY
4570: LIST
4571: LIST
4572: PUSH
4573: EMPTY
4574: LIST
4575: PPUSH
4576: CALL_OW 69
4580: ST_TO_ADDR
// ComMoveToArea ( animal_out , nature ) ;
4581: LD_VAR 0 2
4585: PPUSH
4586: LD_INT 2
4588: PPUSH
4589: CALL_OW 113
// enable ;
4593: ENABLE
// end ; end_of_file
4594: PPOPN 2
4596: END
// export blast_done , query_started , contamine , art_picked , art_cargo ; export dokecano ; export function starting_scene ; begin
4597: LD_INT 0
4599: PPUSH
// RevealFogArea ( you , artefact_fog ) ;
4600: LD_EXP 16
4604: PPUSH
4605: LD_INT 4
4607: PPUSH
4608: CALL_OW 332
// CenterNowOnUnits ( [ truck1 , truck2 ] ) ;
4612: LD_EXP 6
4616: PUSH
4617: LD_EXP 7
4621: PUSH
4622: EMPTY
4623: LIST
4624: LIST
4625: PPUSH
4626: CALL_OW 87
// IngameOn ;
4630: CALL_OW 8
// ComMoveXY ( MacMillan , 192 , 82 ) ;
4634: LD_EXP 1
4638: PPUSH
4639: LD_INT 192
4641: PPUSH
4642: LD_INT 82
4644: PPUSH
4645: CALL_OW 111
// ComMoveXY ( Burlak , 193 , 86 ) ;
4649: LD_EXP 2
4653: PPUSH
4654: LD_INT 193
4656: PPUSH
4657: LD_INT 86
4659: PPUSH
4660: CALL_OW 111
// AddComExitVehicle ( [ MacMillan , Burlak ] ) ;
4664: LD_EXP 1
4668: PUSH
4669: LD_EXP 2
4673: PUSH
4674: EMPTY
4675: LIST
4676: LIST
4677: PPUSH
4678: CALL_OW 181
// wait ( 0 0$5 ) ;
4682: LD_INT 175
4684: PPUSH
4685: CALL_OW 67
// IngameOff ;
4689: CALL_OW 9
// DialogueOn ;
4693: CALL_OW 6
// interface_hidden := true ;
4697: LD_ADDR_OWVAR 54
4701: PUSH
4702: LD_INT 1
4704: ST_TO_ADDR
// Say ( Burlak , D2-Bur-1 ) ;
4705: LD_EXP 2
4709: PPUSH
4710: LD_STRING D2-Bur-1
4712: PPUSH
4713: CALL_OW 88
// Say ( MacMillan , D2-JMM-1 ) ;
4717: LD_EXP 1
4721: PPUSH
4722: LD_STRING D2-JMM-1
4724: PPUSH
4725: CALL_OW 88
// Say ( Burlak , D2-Bur-2 ) ;
4729: LD_EXP 2
4733: PPUSH
4734: LD_STRING D2-Bur-2
4736: PPUSH
4737: CALL_OW 88
// SaveForQuickRestart ;
4741: CALL_OW 22
// wait ( 10 ) ;
4745: LD_INT 10
4747: PPUSH
4748: CALL_OW 67
// ChangeMissionObjectives ( MPickup ) ;
4752: LD_STRING MPickup
4754: PPUSH
4755: CALL_OW 337
// interface_hidden := false ;
4759: LD_ADDR_OWVAR 54
4763: PUSH
4764: LD_INT 0
4766: ST_TO_ADDR
// DialogueOff ;
4767: CALL_OW 7
// ComFree ( [ MacMillan , Burlak ] ) ;
4771: LD_EXP 1
4775: PUSH
4776: LD_EXP 2
4780: PUSH
4781: EMPTY
4782: LIST
4783: LIST
4784: PPUSH
4785: CALL_OW 139
// end ;
4789: LD_VAR 0 1
4793: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_see , you ] , [ f_side , americans ] , [ f_type , unit_human ] ] ) do
4794: LD_INT 101
4796: PUSH
4797: LD_EXP 16
4801: PUSH
4802: EMPTY
4803: LIST
4804: LIST
4805: PUSH
4806: LD_INT 22
4808: PUSH
4809: LD_EXP 17
4813: PUSH
4814: EMPTY
4815: LIST
4816: LIST
4817: PUSH
4818: LD_INT 21
4820: PUSH
4821: LD_INT 1
4823: PUSH
4824: EMPTY
4825: LIST
4826: LIST
4827: PUSH
4828: EMPTY
4829: LIST
4830: LIST
4831: LIST
4832: PPUSH
4833: CALL_OW 69
4837: IFFALSE 4941
4839: GO 4841
4841: DISABLE
// begin if blast_done then
4842: LD_EXP 28
4846: IFFALSE 4850
// exit ;
4848: GO 4941
// repeat wait ( 0 0$1 ) ;
4850: LD_INT 35
4852: PPUSH
4853: CALL_OW 67
// until not FilterAllUnits ( [ [ f_see , you ] , [ f_side , americans ] , [ f_type , unit_human ] , [ f_ok ] ] ) ;
4857: LD_INT 101
4859: PUSH
4860: LD_EXP 16
4864: PUSH
4865: EMPTY
4866: LIST
4867: LIST
4868: PUSH
4869: LD_INT 22
4871: PUSH
4872: LD_EXP 17
4876: PUSH
4877: EMPTY
4878: LIST
4879: LIST
4880: PUSH
4881: LD_INT 21
4883: PUSH
4884: LD_INT 1
4886: PUSH
4887: EMPTY
4888: LIST
4889: LIST
4890: PUSH
4891: LD_INT 50
4893: PUSH
4894: EMPTY
4895: LIST
4896: PUSH
4897: EMPTY
4898: LIST
4899: LIST
4900: LIST
4901: LIST
4902: PPUSH
4903: CALL_OW 69
4907: NOT
4908: IFFALSE 4850
// wait ( 0 0$2 ) ;
4910: LD_INT 70
4912: PPUSH
4913: CALL_OW 67
// Say ( Burlak , D3-Bur-1 ) ;
4917: LD_EXP 2
4921: PPUSH
4922: LD_STRING D3-Bur-1
4924: PPUSH
4925: CALL_OW 88
// Say ( MacMillan , D3-JMM-1 ) ;
4929: LD_EXP 1
4933: PPUSH
4934: LD_STRING D3-JMM-1
4936: PPUSH
4937: CALL_OW 88
// end ;
4941: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_see , you ] , [ f_type , unit_building ] ] ) do
4942: LD_INT 101
4944: PUSH
4945: LD_EXP 16
4949: PUSH
4950: EMPTY
4951: LIST
4952: LIST
4953: PUSH
4954: LD_INT 21
4956: PUSH
4957: LD_INT 3
4959: PUSH
4960: EMPTY
4961: LIST
4962: LIST
4963: PUSH
4964: EMPTY
4965: LIST
4966: LIST
4967: PPUSH
4968: CALL_OW 69
4972: IFFALSE 5167
4974: GO 4976
4976: DISABLE
// begin wait ( 0 0$2 ) ;
4977: LD_INT 70
4979: PPUSH
4980: CALL_OW 67
// DialogueOn ;
4984: CALL_OW 6
// interface_hidden := true ;
4988: LD_ADDR_OWVAR 54
4992: PUSH
4993: LD_INT 1
4995: ST_TO_ADDR
// Say ( MacMillan , D3a-JMM-1 ) ;
4996: LD_EXP 1
5000: PPUSH
5001: LD_STRING D3a-JMM-1
5003: PPUSH
5004: CALL_OW 88
// Say ( Burlak , D3a-Bur-1 ) ;
5008: LD_EXP 2
5012: PPUSH
5013: LD_STRING D3a-Bur-1
5015: PPUSH
5016: CALL_OW 88
// Say ( Burlak , D3a-Bur-1a ) ;
5020: LD_EXP 2
5024: PPUSH
5025: LD_STRING D3a-Bur-1a
5027: PPUSH
5028: CALL_OW 88
// SayRadio ( ru_sci , D3a-RSci1-1 ) ;
5032: LD_EXP 3
5036: PPUSH
5037: LD_STRING D3a-RSci1-1
5039: PPUSH
5040: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-1 ) ;
5044: LD_EXP 5
5048: PPUSH
5049: LD_STRING D3a-Huck-1
5051: PPUSH
5052: CALL_OW 94
// SayRadio ( Powell , D3a-Pow-1 ) ;
5056: LD_EXP 4
5060: PPUSH
5061: LD_STRING D3a-Pow-1
5063: PPUSH
5064: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-2 ) ;
5068: LD_EXP 5
5072: PPUSH
5073: LD_STRING D3a-Huck-2
5075: PPUSH
5076: CALL_OW 94
// SayRadio ( Powell , D3a-Pow-2 ) ;
5080: LD_EXP 4
5084: PPUSH
5085: LD_STRING D3a-Pow-2
5087: PPUSH
5088: CALL_OW 94
// SayRadio ( Stevens , D3a-Huck-3 ) ;
5092: LD_EXP 5
5096: PPUSH
5097: LD_STRING D3a-Huck-3
5099: PPUSH
5100: CALL_OW 94
// Say ( MacMillan , D3a-JMM-3 ) ;
5104: LD_EXP 1
5108: PPUSH
5109: LD_STRING D3a-JMM-3
5111: PPUSH
5112: CALL_OW 88
// SayRadio ( ru_sci , D3a-RSci1-3 ) ;
5116: LD_EXP 3
5120: PPUSH
5121: LD_STRING D3a-RSci1-3
5123: PPUSH
5124: CALL_OW 94
// Say ( MacMillan , D3a-JMM-4 ) ;
5128: LD_EXP 1
5132: PPUSH
5133: LD_STRING D3a-JMM-4
5135: PPUSH
5136: CALL_OW 88
// Say ( Burlak , D3a-Bur-4 ) ;
5140: LD_EXP 2
5144: PPUSH
5145: LD_STRING D3a-Bur-4
5147: PPUSH
5148: CALL_OW 88
// interface_hidden := false ;
5152: LD_ADDR_OWVAR 54
5156: PUSH
5157: LD_INT 0
5159: ST_TO_ADDR
// DialogueOff ;
5160: CALL_OW 7
// enable ( 4 ) ;
5164: LD_INT 4
5166: ENABLE_MARKED
// end ;
5167: END
// export function Artefact_Picked ; begin
5168: LD_INT 0
5170: PPUSH
// wait ( 5 ) ;
5171: LD_INT 5
5173: PPUSH
5174: CALL_OW 67
// DialogueOn ;
5178: CALL_OW 6
// interface_hidden := true ;
5182: LD_ADDR_OWVAR 54
5186: PUSH
5187: LD_INT 1
5189: ST_TO_ADDR
// Say ( MacMillan , D4-JMM-1 ) ;
5190: LD_EXP 1
5194: PPUSH
5195: LD_STRING D4-JMM-1
5197: PPUSH
5198: CALL_OW 88
// Say ( Burlak , D4-Bur-1 ) ;
5202: LD_EXP 2
5206: PPUSH
5207: LD_STRING D4-Bur-1
5209: PPUSH
5210: CALL_OW 88
// ChangeMissionObjectives ( MReturn ) ;
5214: LD_STRING MReturn
5216: PPUSH
5217: CALL_OW 337
// interface_hidden := false ;
5221: LD_ADDR_OWVAR 54
5225: PUSH
5226: LD_INT 0
5228: ST_TO_ADDR
// DialogueOff ;
5229: CALL_OW 7
// end ;
5233: LD_VAR 0 1
5237: RET
// every 0 0$1 marked 4 do var blast_time ;
5238: GO 5240
5240: DISABLE
5241: LD_INT 0
5243: PPUSH
// begin blast_countdown := true ;
5244: LD_ADDR_EXP 27
5248: PUSH
5249: LD_INT 1
5251: ST_TO_ADDR
// blast_time := TICK + ( [ 6 6$0 , 3 3$0 , 1 1$0 ] [ difficulty ] ) ;
5252: LD_ADDR_VAR 0 1
5256: PUSH
5257: LD_OWVAR 1
5261: PUSH
5262: LD_INT 12600
5264: PUSH
5265: LD_INT 6300
5267: PUSH
5268: LD_INT 2100
5270: PUSH
5271: EMPTY
5272: LIST
5273: LIST
5274: LIST
5275: PUSH
5276: LD_OWVAR 67
5280: ARRAY
5281: PLUS
5282: ST_TO_ADDR
// repeat wait ( 0 0$3 ) ;
5283: LD_INT 105
5285: PPUSH
5286: CALL_OW 67
// until ( TICK > blast_time ) or IsInArea ( truck1 , half_line ) or IsInArea ( truck2 , half_line ) or IsInArea ( truck1 , leave_blast ) or IsInArea ( truck2 , leave_blast ) ;
5290: LD_OWVAR 1
5294: PUSH
5295: LD_VAR 0 1
5299: GREATER
5300: PUSH
5301: LD_EXP 6
5305: PPUSH
5306: LD_INT 5
5308: PPUSH
5309: CALL_OW 308
5313: OR
5314: PUSH
5315: LD_EXP 7
5319: PPUSH
5320: LD_INT 5
5322: PPUSH
5323: CALL_OW 308
5327: OR
5328: PUSH
5329: LD_EXP 6
5333: PPUSH
5334: LD_INT 9
5336: PPUSH
5337: CALL_OW 308
5341: OR
5342: PUSH
5343: LD_EXP 7
5347: PPUSH
5348: LD_INT 9
5350: PPUSH
5351: CALL_OW 308
5355: OR
5356: IFFALSE 5283
// blast_time := tick ;
5358: LD_ADDR_VAR 0 1
5362: PUSH
5363: LD_OWVAR 1
5367: ST_TO_ADDR
// DialogueOn ;
5368: CALL_OW 6
// interface_hidden := true ;
5372: LD_ADDR_OWVAR 54
5376: PUSH
5377: LD_INT 1
5379: ST_TO_ADDR
// CenterOnXY ( 103 , 52 ) ;
5380: LD_INT 103
5382: PPUSH
5383: LD_INT 52
5385: PPUSH
5386: CALL_OW 84
// wait ( 0 0$3 ) ;
5390: LD_INT 105
5392: PPUSH
5393: CALL_OW 67
// PrepareSiberiteRocket ;
5397: CALL_OW 357
// SendSiberiteRocket ( 103 , 52 ) ;
5401: LD_INT 103
5403: PPUSH
5404: LD_INT 52
5406: PPUSH
5407: CALL_OW 429
// interface_hidden := false ;
5411: LD_ADDR_OWVAR 54
5415: PUSH
5416: LD_INT 0
5418: ST_TO_ADDR
// DialogueOff ;
5419: CALL_OW 7
// blast_done := true ;
5423: LD_ADDR_EXP 28
5427: PUSH
5428: LD_INT 1
5430: ST_TO_ADDR
// contamine := TICK + 6000 ;
5431: LD_ADDR_EXP 30
5435: PUSH
5436: LD_OWVAR 1
5440: PUSH
5441: LD_INT 6000
5443: PLUS
5444: ST_TO_ADDR
// wait ( 0 0$4 ) ;
5445: LD_INT 140
5447: PPUSH
5448: CALL_OW 67
// if not IsLive ( Burlak ) then
5452: LD_EXP 2
5456: PPUSH
5457: CALL_OW 300
5461: NOT
5462: IFFALSE 5471
// Mission_Failed ( 1 ) ;
5464: LD_INT 1
5466: PPUSH
5467: CALL 1487 0 1
// if not IsLive ( MacMillan ) then
5471: LD_EXP 1
5475: PPUSH
5476: CALL_OW 300
5480: NOT
5481: IFFALSE 5490
// Mission_Failed ( 2 ) ;
5483: LD_INT 2
5485: PPUSH
5486: CALL 1487 0 1
// if not ( FindArtifact ( 4 ) or art_cargo ) then
5490: LD_INT 4
5492: PPUSH
5493: CALL_OW 469
5497: PUSH
5498: LD_EXP 32
5502: OR
5503: NOT
5504: IFFALSE 5513
// Mission_Failed ( 4 ) ;
5506: LD_INT 4
5508: PPUSH
5509: CALL 1487 0 1
// after_the_blast ;
5513: CALL 5526 0 0
// enable ( 5 ) ;
5517: LD_INT 5
5519: ENABLE_MARKED
// enable ( 7 ) ;
5520: LD_INT 7
5522: ENABLE_MARKED
// end ;
5523: PPOPN 1
5525: END
// function after_the_blast ; begin
5526: LD_INT 0
5528: PPUSH
// blast_was_seen := true ;
5529: LD_ADDR_EXP 8
5533: PUSH
5534: LD_INT 1
5536: ST_TO_ADDR
// DialogueOn ;
5537: CALL_OW 6
// interface_hidden := true ;
5541: LD_ADDR_OWVAR 54
5545: PUSH
5546: LD_INT 1
5548: ST_TO_ADDR
// Say ( MacMillan , D6a-JMM-1 ) ;
5549: LD_EXP 1
5553: PPUSH
5554: LD_STRING D6a-JMM-1
5556: PPUSH
5557: CALL_OW 88
// Say ( Burlak , D6a-Bur-1 ) ;
5561: LD_EXP 2
5565: PPUSH
5566: LD_STRING D6a-Bur-1
5568: PPUSH
5569: CALL_OW 88
// enable ( 8 ) ;
5573: LD_INT 8
5575: ENABLE_MARKED
// Say ( Burlak , D6c-Bur-1 ) ;
5576: LD_EXP 2
5580: PPUSH
5581: LD_STRING D6c-Bur-1
5583: PPUSH
5584: CALL_OW 88
// Say ( MacMillan , D6c-JMM-1 ) ;
5588: LD_EXP 1
5592: PPUSH
5593: LD_STRING D6c-JMM-1
5595: PPUSH
5596: CALL_OW 88
// ChangeMissionObjectives ( MBase ) ;
5600: LD_STRING MBase
5602: PPUSH
5603: CALL_OW 337
// interface_hidden := false ;
5607: LD_ADDR_OWVAR 54
5611: PUSH
5612: LD_INT 0
5614: ST_TO_ADDR
// DialogueOff ;
5615: CALL_OW 7
// enable ( 6 ) ;
5619: LD_INT 6
5621: ENABLE_MARKED
// end ;
5622: LD_VAR 0 1
5626: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , you ] , [ f_distxy , 103 , 52 , 27 ] ] ) marked 8 do
5627: LD_INT 22
5629: PUSH
5630: LD_EXP 16
5634: PUSH
5635: EMPTY
5636: LIST
5637: LIST
5638: PUSH
5639: LD_INT 92
5641: PUSH
5642: LD_INT 103
5644: PUSH
5645: LD_INT 52
5647: PUSH
5648: LD_INT 27
5650: PUSH
5651: EMPTY
5652: LIST
5653: LIST
5654: LIST
5655: LIST
5656: PUSH
5657: EMPTY
5658: LIST
5659: LIST
5660: PPUSH
5661: CALL_OW 69
5665: IFFALSE 5736
5667: GO 5669
5669: DISABLE
// begin CenterOnUnits ( [ MacMillan , Burlak ] ) ;
5670: LD_EXP 1
5674: PUSH
5675: LD_EXP 2
5679: PUSH
5680: EMPTY
5681: LIST
5682: LIST
5683: PPUSH
5684: CALL_OW 85
// DialogueOn ;
5688: CALL_OW 6
// interface_hidden := true ;
5692: LD_ADDR_OWVAR 54
5696: PUSH
5697: LD_INT 1
5699: ST_TO_ADDR
// Say ( MacMillan , D6b-JMM-1 ) ;
5700: LD_EXP 1
5704: PPUSH
5705: LD_STRING D6b-JMM-1
5707: PPUSH
5708: CALL_OW 88
// Say ( Burlak , D6b-Bur-1 ) ;
5712: LD_EXP 2
5716: PPUSH
5717: LD_STRING D6b-Bur-1
5719: PPUSH
5720: CALL_OW 88
// interface_hidden := false ;
5724: LD_ADDR_OWVAR 54
5728: PUSH
5729: LD_INT 0
5731: ST_TO_ADDR
// DialogueOff ;
5732: CALL_OW 7
// end ;
5736: END
// every 0 0$1 trigger IsInArea ( MacMillan , blast_area ) and ( contamine > TICK ) marked 6 do
5737: LD_EXP 1
5741: PPUSH
5742: LD_INT 6
5744: PPUSH
5745: CALL_OW 308
5749: PUSH
5750: LD_EXP 30
5754: PUSH
5755: LD_OWVAR 1
5759: GREATER
5760: AND
5761: IFFALSE 5819
5763: GO 5765
5765: DISABLE
// begin CenterOnUnits ( MacMillan ) ;
5766: LD_EXP 1
5770: PPUSH
5771: CALL_OW 85
// DialogueOn ;
5775: CALL_OW 6
// interface_hidden := true ;
5779: LD_ADDR_OWVAR 54
5783: PUSH
5784: LD_INT 1
5786: ST_TO_ADDR
// Say ( MacMillan , D7-JMM-1 ) ;
5787: LD_EXP 1
5791: PPUSH
5792: LD_STRING D7-JMM-1
5794: PPUSH
5795: CALL_OW 88
// interface_hidden := false ;
5799: LD_ADDR_OWVAR 54
5803: PUSH
5804: LD_INT 0
5806: ST_TO_ADDR
// DialogueOff ;
5807: CALL_OW 7
// entered_contaminated_area := true ;
5811: LD_ADDR_EXP 11
5815: PUSH
5816: LD_INT 1
5818: ST_TO_ADDR
// end ;
5819: END
// every 0 0$1 trigger IsInArea ( Burlak , blast_area ) and ( contamine > TICK ) marked 6 do
5820: LD_EXP 2
5824: PPUSH
5825: LD_INT 6
5827: PPUSH
5828: CALL_OW 308
5832: PUSH
5833: LD_EXP 30
5837: PUSH
5838: LD_OWVAR 1
5842: GREATER
5843: AND
5844: IFFALSE 5902
5846: GO 5848
5848: DISABLE
// begin CenterOnUnits ( Burlak ) ;
5849: LD_EXP 2
5853: PPUSH
5854: CALL_OW 85
// DialogueOn ;
5858: CALL_OW 6
// interface_hidden := true ;
5862: LD_ADDR_OWVAR 54
5866: PUSH
5867: LD_INT 1
5869: ST_TO_ADDR
// Say ( Burlak , D7-Bur-1 ) ;
5870: LD_EXP 2
5874: PPUSH
5875: LD_STRING D7-Bur-1
5877: PPUSH
5878: CALL_OW 88
// interface_hidden := false ;
5882: LD_ADDR_OWVAR 54
5886: PUSH
5887: LD_INT 0
5889: ST_TO_ADDR
// DialogueOff ;
5890: CALL_OW 7
// entered_contaminated_area := true ;
5894: LD_ADDR_EXP 11
5898: PUSH
5899: LD_INT 1
5901: ST_TO_ADDR
// end ;
5902: END
// every 0 0$10 marked 5 do var time_limit , warning_time ;
5903: GO 5905
5905: DISABLE
5906: LD_INT 0
5908: PPUSH
5909: PPUSH
// begin time_limit := [ 5 5$0 , 4 4$0 , 3 3$0 ] ;
5910: LD_ADDR_VAR 0 1
5914: PUSH
5915: LD_INT 10500
5917: PUSH
5918: LD_INT 8400
5920: PUSH
5921: LD_INT 6300
5923: PUSH
5924: EMPTY
5925: LIST
5926: LIST
5927: LIST
5928: ST_TO_ADDR
// warning_time := TICK + time_limit [ difficulty ] ;
5929: LD_ADDR_VAR 0 2
5933: PUSH
5934: LD_OWVAR 1
5938: PUSH
5939: LD_VAR 0 1
5943: PUSH
5944: LD_OWVAR 67
5948: ARRAY
5949: PLUS
5950: ST_TO_ADDR
// repeat wait ( 0 0$10 ) ;
5951: LD_INT 350
5953: PPUSH
5954: CALL_OW 67
// until TICK > warning_time ;
5958: LD_OWVAR 1
5962: PUSH
5963: LD_VAR 0 2
5967: GREATER
5968: IFFALSE 5951
// if ( not query_started ) or ( not technology_taken ) then
5970: LD_EXP 29
5974: NOT
5975: PUSH
5976: LD_EXP 14
5980: NOT
5981: OR
5982: IFFALSE 5996
// Say ( MacMillan , D8-JMM-1 ) ;
5984: LD_EXP 1
5988: PPUSH
5989: LD_STRING D8-JMM-1
5991: PPUSH
5992: CALL_OW 88
// end ;
5996: PPOPN 2
5998: END
// every 0 0$2 trigger See ( you , oil_2 ) do
5999: LD_EXP 16
6003: PPUSH
6004: LD_INT 9
6006: PPUSH
6007: CALL_OW 292
6011: IFFALSE 6071
6013: GO 6015
6015: DISABLE
// begin CenterOnUnits ( oil_2 ) ;
6016: LD_INT 9
6018: PPUSH
6019: CALL_OW 85
// DialogueOn ;
6023: CALL_OW 6
// interface_hidden := true ;
6027: LD_ADDR_OWVAR 54
6031: PUSH
6032: LD_INT 1
6034: ST_TO_ADDR
// Say ( Burlak , D9-Bur-1 ) ;
6035: LD_EXP 2
6039: PPUSH
6040: LD_STRING D9-Bur-1
6042: PPUSH
6043: CALL_OW 88
// Say ( MacMillan , D9-JMM-1 ) ;
6047: LD_EXP 1
6051: PPUSH
6052: LD_STRING D9-JMM-1
6054: PPUSH
6055: CALL_OW 88
// interface_hidden := false ;
6059: LD_ADDR_OWVAR 54
6063: PUSH
6064: LD_INT 0
6066: ST_TO_ADDR
// DialogueOff ;
6067: CALL_OW 7
// end ;
6071: END
// export function query_kill ; var odpoved ; begin
6072: LD_INT 0
6074: PPUSH
6075: PPUSH
// query_started := true ;
6076: LD_ADDR_EXP 29
6080: PUSH
6081: LD_INT 1
6083: ST_TO_ADDR
// if Query ( QKill ) = 1 then
6084: LD_STRING QKill
6086: PPUSH
6087: CALL_OW 97
6091: PUSH
6092: LD_INT 1
6094: EQUAL
6095: IFFALSE 6103
// query_vyjednavat else
6097: CALL 6112 0 0
6101: GO 6107
// query_pozabijet ;
6103: CALL 6619 0 0
// end ;
6107: LD_VAR 0 1
6111: RET
// function query_vyjednavat ; var un , vedci , list ; begin
6112: LD_INT 0
6114: PPUSH
6115: PPUSH
6116: PPUSH
6117: PPUSH
// SetAttitude ( you , americans , att_friend , true ) ;
6118: LD_EXP 16
6122: PPUSH
6123: LD_EXP 17
6127: PPUSH
6128: LD_INT 1
6130: PPUSH
6131: LD_INT 1
6133: PPUSH
6134: CALL_OW 80
// list := FilterAllUnits ( [ [ f_side , americans ] , [ f_type , unit_human ] ] ) ;
6138: LD_ADDR_VAR 0 4
6142: PUSH
6143: LD_INT 22
6145: PUSH
6146: LD_EXP 17
6150: PUSH
6151: EMPTY
6152: LIST
6153: LIST
6154: PUSH
6155: LD_INT 21
6157: PUSH
6158: LD_INT 1
6160: PUSH
6161: EMPTY
6162: LIST
6163: LIST
6164: PUSH
6165: EMPTY
6166: LIST
6167: LIST
6168: PPUSH
6169: CALL_OW 69
6173: ST_TO_ADDR
// for un in list do
6174: LD_ADDR_VAR 0 2
6178: PUSH
6179: LD_VAR 0 4
6183: PUSH
6184: FOR_IN
6185: IFFALSE 6266
// if not IsInUnit ( un ) then
6187: LD_VAR 0 2
6191: PPUSH
6192: CALL_OW 310
6196: NOT
6197: IFFALSE 6264
// ComMoveXY ( un , ShiftX ( GetX ( un ) , GetDir ( un ) , 1 ) , ShiftY ( GetY ( un ) , GetDir ( un ) , 1 ) ) ;
6199: LD_VAR 0 2
6203: PPUSH
6204: LD_VAR 0 2
6208: PPUSH
6209: CALL_OW 250
6213: PPUSH
6214: LD_VAR 0 2
6218: PPUSH
6219: CALL_OW 254
6223: PPUSH
6224: LD_INT 1
6226: PPUSH
6227: CALL_OW 272
6231: PPUSH
6232: LD_VAR 0 2
6236: PPUSH
6237: CALL_OW 251
6241: PPUSH
6242: LD_VAR 0 2
6246: PPUSH
6247: CALL_OW 254
6251: PPUSH
6252: LD_INT 1
6254: PPUSH
6255: CALL_OW 273
6259: PPUSH
6260: CALL_OW 111
6264: GO 6184
6266: POP
6267: POP
// Wait ( 10 ) ;
6268: LD_INT 10
6270: PPUSH
6271: CALL_OW 67
// CenterOnUnits ( [ us_lab ] ) ;
6275: LD_INT 1
6277: PUSH
6278: EMPTY
6279: LIST
6280: PPUSH
6281: CALL_OW 85
// InGameOn ;
6285: CALL_OW 8
// if GetLives ( us_lab ) > 300 then
6289: LD_INT 1
6291: PPUSH
6292: CALL_OW 256
6296: PUSH
6297: LD_INT 300
6299: GREATER
6300: IFFALSE 6311
// ComExitBuilding ( us_sci ) ;
6302: LD_EXP 22
6306: PPUSH
6307: CALL_OW 122
// Check_Heroes ;
6311: CALL 7177 0 0
// Say ( Burlak , D10a-Bur-1 ) ;
6315: LD_EXP 2
6319: PPUSH
6320: LD_STRING D10a-Bur-1
6322: PPUSH
6323: CALL_OW 88
// if original_stevens then
6327: LD_EXP 12
6331: IFFALSE 6413
// begin if GetDistUnitArea ( Burlak , us_base ) = 0 then
6333: LD_EXP 2
6337: PPUSH
6338: LD_INT 1
6340: PPUSH
6341: CALL_OW 299
6345: PUSH
6346: LD_INT 0
6348: EQUAL
6349: IFFALSE 6367
// ComMoveUnit ( Stevens , Burlak ) else
6351: LD_EXP 5
6355: PPUSH
6356: LD_EXP 2
6360: PPUSH
6361: CALL_OW 112
6365: GO 6381
// ComMoveUnit ( Stevens , MacMillan ) ;
6367: LD_EXP 5
6371: PPUSH
6372: LD_EXP 1
6376: PPUSH
6377: CALL_OW 112
// Say ( Stevens , D10a-Huck-1 ) ;
6381: LD_EXP 5
6385: PPUSH
6386: LD_STRING D10a-Huck-1
6388: PPUSH
6389: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
6393: LD_INT 35
6395: PPUSH
6396: CALL_OW 67
// until IsBusy ( Stevens ) ;
6400: LD_EXP 5
6404: PPUSH
6405: CALL_OW 315
6409: IFFALSE 6393
// end else
6411: GO 6557
// begin vedci := FilterAllUnits ( [ [ f_side , americans ] , [ f_class , class_scientistic ] ] ) ;
6413: LD_ADDR_VAR 0 3
6417: PUSH
6418: LD_INT 22
6420: PUSH
6421: LD_EXP 17
6425: PUSH
6426: EMPTY
6427: LIST
6428: LIST
6429: PUSH
6430: LD_INT 25
6432: PUSH
6433: LD_INT 4
6435: PUSH
6436: EMPTY
6437: LIST
6438: LIST
6439: PUSH
6440: EMPTY
6441: LIST
6442: LIST
6443: PPUSH
6444: CALL_OW 69
6448: ST_TO_ADDR
// if vedci then
6449: LD_VAR 0 3
6453: IFFALSE 6471
// un := vedci [ 1 ] else
6455: LD_ADDR_VAR 0 2
6459: PUSH
6460: LD_VAR 0 3
6464: PUSH
6465: LD_INT 1
6467: ARRAY
6468: ST_TO_ADDR
6469: GO 6479
// un := 0 ;
6471: LD_ADDR_VAR 0 2
6475: PUSH
6476: LD_INT 0
6478: ST_TO_ADDR
// Say ( un , D10a-Sci1-1 ) ;
6479: LD_VAR 0 2
6483: PPUSH
6484: LD_STRING D10a-Sci1-1
6486: PPUSH
6487: CALL_OW 88
// if GetDistUnitArea ( Burlak , us_base ) = 0 then
6491: LD_EXP 2
6495: PPUSH
6496: LD_INT 1
6498: PPUSH
6499: CALL_OW 299
6503: PUSH
6504: LD_INT 0
6506: EQUAL
6507: IFFALSE 6525
// ComMoveUnit ( un , Burlak ) else
6509: LD_VAR 0 2
6513: PPUSH
6514: LD_EXP 2
6518: PPUSH
6519: CALL_OW 112
6523: GO 6539
// ComMoveUnit ( un , MacMillan ) ;
6525: LD_VAR 0 2
6529: PPUSH
6530: LD_EXP 1
6534: PPUSH
6535: CALL_OW 112
// repeat wait ( 0 0$1 ) ;
6539: LD_INT 35
6541: PPUSH
6542: CALL_OW 67
// until IsBusy ( un ) ;
6546: LD_VAR 0 2
6550: PPUSH
6551: CALL_OW 315
6555: IFFALSE 6539
// end ; ComStop ( un ) ;
6557: LD_VAR 0 2
6561: PPUSH
6562: CALL_OW 141
// Say ( Burlak , D10a-Bur-2 ) ;
6566: LD_EXP 2
6570: PPUSH
6571: LD_STRING D10a-Bur-2
6573: PPUSH
6574: CALL_OW 88
// technology_taken := true ;
6578: LD_ADDR_EXP 14
6582: PUSH
6583: LD_INT 1
6585: ST_TO_ADDR
// InGameOff ;
6586: CALL_OW 9
// SetAttitude ( you , americans , att_neutral , true ) ;
6590: LD_EXP 16
6594: PPUSH
6595: LD_EXP 17
6599: PPUSH
6600: LD_INT 0
6602: PPUSH
6603: LD_INT 1
6605: PPUSH
6606: CALL_OW 80
// konecny_rozhovor ;
6610: CALL 6997 0 0
// end ;
6614: LD_VAR 0 1
6618: RET
// function query_pozabijet ; var un , list , defenders , intruders ; begin
6619: LD_INT 0
6621: PPUSH
6622: PPUSH
6623: PPUSH
6624: PPUSH
6625: PPUSH
// Check_Heroes ;
6626: CALL 7177 0 0
// DialogueOn ;
6630: CALL_OW 6
// interface_hidden := true ;
6634: LD_ADDR_OWVAR 54
6638: PUSH
6639: LD_INT 1
6641: ST_TO_ADDR
// Say ( MacMillan , D10b-JMM-1 ) ;
6642: LD_EXP 1
6646: PPUSH
6647: LD_STRING D10b-JMM-1
6649: PPUSH
6650: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , americans ] , [ f_btype , b_warehouse ] ] ) then
6654: LD_INT 22
6656: PUSH
6657: LD_EXP 17
6661: PUSH
6662: EMPTY
6663: LIST
6664: LIST
6665: PUSH
6666: LD_INT 30
6668: PUSH
6669: LD_INT 1
6671: PUSH
6672: EMPTY
6673: LIST
6674: LIST
6675: PUSH
6676: EMPTY
6677: LIST
6678: LIST
6679: PPUSH
6680: CALL_OW 69
6684: IFFALSE 6698
// Say ( Burlak , D10b-Bur-1 ) ;
6686: LD_EXP 2
6690: PPUSH
6691: LD_STRING D10b-Bur-1
6693: PPUSH
6694: CALL_OW 88
// interface_hidden := false ;
6698: LD_ADDR_OWVAR 54
6702: PUSH
6703: LD_INT 0
6705: ST_TO_ADDR
// DialogueOff ;
6706: CALL_OW 7
// enable ( 9 ) ;
6710: LD_INT 9
6712: ENABLE_MARKED
// repeat ComMoveToArea ( us_sci , leave_area ) ;
6713: LD_EXP 22
6717: PPUSH
6718: LD_INT 8
6720: PPUSH
6721: CALL_OW 113
// defenders := FilterAllUnits ( [ [ f_side , americans ] , [ f_class , class_soldier ] ] ) ;
6725: LD_ADDR_VAR 0 4
6729: PUSH
6730: LD_INT 22
6732: PUSH
6733: LD_EXP 17
6737: PUSH
6738: EMPTY
6739: LIST
6740: LIST
6741: PUSH
6742: LD_INT 25
6744: PUSH
6745: LD_INT 1
6747: PUSH
6748: EMPTY
6749: LIST
6750: LIST
6751: PUSH
6752: EMPTY
6753: LIST
6754: LIST
6755: PPUSH
6756: CALL_OW 69
6760: ST_TO_ADDR
// intruders := FilterUnitsInArea ( us_base , [ [ f_side , you ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
6761: LD_ADDR_VAR 0 5
6765: PUSH
6766: LD_INT 1
6768: PPUSH
6769: LD_INT 22
6771: PUSH
6772: LD_EXP 16
6776: PUSH
6777: EMPTY
6778: LIST
6779: LIST
6780: PUSH
6781: LD_INT 2
6783: PUSH
6784: LD_INT 21
6786: PUSH
6787: LD_INT 1
6789: PUSH
6790: EMPTY
6791: LIST
6792: LIST
6793: PUSH
6794: LD_INT 21
6796: PUSH
6797: LD_INT 2
6799: PUSH
6800: EMPTY
6801: LIST
6802: LIST
6803: PUSH
6804: EMPTY
6805: LIST
6806: LIST
6807: LIST
6808: PUSH
6809: EMPTY
6810: LIST
6811: LIST
6812: PPUSH
6813: CALL_OW 70
6817: ST_TO_ADDR
// if intruders then
6818: LD_VAR 0 5
6822: IFFALSE 6842
// ComAttackUnit ( defenders , intruders [ 1 ] ) ;
6824: LD_VAR 0 4
6828: PPUSH
6829: LD_VAR 0 5
6833: PUSH
6834: LD_INT 1
6836: ARRAY
6837: PPUSH
6838: CALL_OW 115
// wait ( 0 0$1 ) ;
6842: LD_INT 35
6844: PPUSH
6845: CALL_OW 67
// until ( not us_sci ) or lab_destroyed or ( not intruders ) ;
6849: LD_EXP 22
6853: NOT
6854: PUSH
6855: LD_EXP 9
6859: OR
6860: PUSH
6861: LD_VAR 0 5
6865: NOT
6866: OR
6867: IFFALSE 6713
// ComExitBuilding ( defenders ) ;
6869: LD_VAR 0 4
6873: PPUSH
6874: CALL_OW 122
// repeat list := FilterAllUnits ( [ [ f_see , americans ] , [ f_side , you ] ] ) ;
6878: LD_ADDR_VAR 0 3
6882: PUSH
6883: LD_INT 101
6885: PUSH
6886: LD_EXP 17
6890: PUSH
6891: EMPTY
6892: LIST
6893: LIST
6894: PUSH
6895: LD_INT 22
6897: PUSH
6898: LD_EXP 16
6902: PUSH
6903: EMPTY
6904: LIST
6905: LIST
6906: PUSH
6907: EMPTY
6908: LIST
6909: LIST
6910: PPUSH
6911: CALL_OW 69
6915: ST_TO_ADDR
// if list then
6916: LD_VAR 0 3
6920: IFFALSE 6942
// ComAttackUnit ( defenders , list [ 1 ] ) else
6922: LD_VAR 0 4
6926: PPUSH
6927: LD_VAR 0 3
6931: PUSH
6932: LD_INT 1
6934: ARRAY
6935: PPUSH
6936: CALL_OW 115
6940: GO 6967
// if GetLives ( us_lab ) > 1 then
6942: LD_INT 1
6944: PPUSH
6945: CALL_OW 256
6949: PUSH
6950: LD_INT 1
6952: GREATER
6953: IFFALSE 6967
// ComAttackUnit ( defenders , us_lab ) ;
6955: LD_VAR 0 4
6959: PPUSH
6960: LD_INT 1
6962: PPUSH
6963: CALL_OW 115
// wait ( 0 0$1 ) ;
6967: LD_INT 35
6969: PPUSH
6970: CALL_OW 67
// until lab_destroyed ;
6974: LD_EXP 9
6978: IFFALSE 6878
// ComMoveToArea ( defenders , leave_area ) ;
6980: LD_VAR 0 4
6984: PPUSH
6985: LD_INT 8
6987: PPUSH
6988: CALL_OW 113
// end ;
6992: LD_VAR 0 1
6996: RET
// export function konecny_rozhovor ; var art_ready ; begin
6997: LD_INT 0
6999: PPUSH
7000: PPUSH
// if not dokecano then
7001: LD_EXP 33
7005: NOT
7006: IFFALSE 7065
// begin dokecano := true ;
7008: LD_ADDR_EXP 33
7012: PUSH
7013: LD_INT 1
7015: ST_TO_ADDR
// DialogueOn ;
7016: CALL_OW 6
// interface_hidden := true ;
7020: LD_ADDR_OWVAR 54
7024: PUSH
7025: LD_INT 1
7027: ST_TO_ADDR
// Say ( Burlak , D11-Bur-1 ) ;
7028: LD_EXP 2
7032: PPUSH
7033: LD_STRING D11-Bur-1
7035: PPUSH
7036: CALL_OW 88
// ChangeMissionObjectives ( MEnd ) ;
7040: LD_STRING MEnd
7042: PPUSH
7043: CALL_OW 337
// enable ( 10 ) ;
7047: LD_INT 10
7049: ENABLE_MARKED
// disable ( 1 ) ;
7050: LD_INT 1
7052: DISABLE_MARKED
// interface_hidden := false ;
7053: LD_ADDR_OWVAR 54
7057: PUSH
7058: LD_INT 0
7060: ST_TO_ADDR
// DialogueOff ;
7061: CALL_OW 7
// end ; SetAreaMapShow ( exit_area , 1 ) ;
7065: LD_INT 12
7067: PPUSH
7068: LD_INT 1
7070: PPUSH
7071: CALL_OW 424
// repeat wait ( 0 0$2 ) ;
7075: LD_INT 70
7077: PPUSH
7078: CALL_OW 67
// if art_cargo and not IsInArea ( art_cargo , us_base ) then
7082: LD_EXP 32
7086: PUSH
7087: LD_EXP 32
7091: PPUSH
7092: LD_INT 1
7094: PPUSH
7095: CALL_OW 308
7099: NOT
7100: AND
7101: IFFALSE 7113
// art_ready := true else
7103: LD_ADDR_VAR 0 2
7107: PUSH
7108: LD_INT 1
7110: ST_TO_ADDR
7111: GO 7121
// art_ready := false ;
7113: LD_ADDR_VAR 0 2
7117: PUSH
7118: LD_INT 0
7120: ST_TO_ADDR
// until not ( IsInArea ( MacMillan , us_base ) or IsInArea ( Burlak , us_base ) or not art_ready ) ;
7121: LD_EXP 1
7125: PPUSH
7126: LD_INT 1
7128: PPUSH
7129: CALL_OW 308
7133: PUSH
7134: LD_EXP 2
7138: PPUSH
7139: LD_INT 1
7141: PPUSH
7142: CALL_OW 308
7146: OR
7147: PUSH
7148: LD_VAR 0 2
7152: NOT
7153: OR
7154: NOT
7155: IFFALSE 7075
// wait ( 0 0$2 ) ;
7157: LD_INT 70
7159: PPUSH
7160: CALL_OW 67
// konec_mise ;
7164: CALL 1112 0 0
// DialogueOff ;
7168: CALL_OW 7
// end ;
7172: LD_VAR 0 1
7176: RET
// function Check_Heroes ; begin
7177: LD_INT 0
7179: PPUSH
// if not IsOK ( MacMillan ) then
7180: LD_EXP 1
7184: PPUSH
7185: CALL_OW 302
7189: NOT
7190: IFFALSE 7199
// YouLost ( 2 ) ;
7192: LD_INT 2
7194: PPUSH
7195: CALL_OW 104
// if not IsOK ( Burlak ) then
7199: LD_EXP 2
7203: PPUSH
7204: CALL_OW 302
7208: NOT
7209: IFFALSE 7218
// YouLost ( 1 ) ;
7211: LD_INT 1
7213: PPUSH
7214: CALL_OW 104
// end ; end_of_file
7218: LD_VAR 0 1
7222: RET
// every 0 0$1 marked 7 do var list , un ;
7223: GO 7225
7225: DISABLE
7226: LD_INT 0
7228: PPUSH
7229: PPUSH
// begin list := FilterAllUnits ( [ [ f_side , americans ] , [ f_type , unit_building ] , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] , f_not , [ f_lives , 1000 ] ] ) ;
7230: LD_ADDR_VAR 0 1
7234: PUSH
7235: LD_INT 22
7237: PUSH
7238: LD_EXP 17
7242: PUSH
7243: EMPTY
7244: LIST
7245: LIST
7246: PUSH
7247: LD_INT 21
7249: PUSH
7250: LD_INT 3
7252: PUSH
7253: EMPTY
7254: LIST
7255: LIST
7256: PUSH
7257: LD_INT 2
7259: PUSH
7260: LD_INT 30
7262: PUSH
7263: LD_INT 33
7265: PUSH
7266: EMPTY
7267: LIST
7268: LIST
7269: PUSH
7270: LD_INT 30
7272: PUSH
7273: LD_INT 32
7275: PUSH
7276: EMPTY
7277: LIST
7278: LIST
7279: PUSH
7280: EMPTY
7281: LIST
7282: LIST
7283: LIST
7284: PUSH
7285: LD_INT 3
7287: PUSH
7288: LD_INT 24
7290: PUSH
7291: LD_INT 1000
7293: PUSH
7294: EMPTY
7295: LIST
7296: LIST
7297: PUSH
7298: EMPTY
7299: LIST
7300: LIST
7301: LIST
7302: LIST
7303: LIST
7304: PPUSH
7305: CALL_OW 69
7309: ST_TO_ADDR
// if list then
7310: LD_VAR 0 1
7314: IFFALSE 7325
// repair_base ( list ) ;
7316: LD_VAR 0 1
7320: PPUSH
7321: CALL 7336 0 1
// if not keep_base_finished then
7325: LD_EXP 15
7329: NOT
7330: IFFALSE 7333
// enable ;
7332: ENABLE
// end ;
7333: PPOPN 2
7335: END
// function repair_base ( list ) ; var un , driver ; begin
7336: LD_INT 0
7338: PPUSH
7339: PPUSH
7340: PPUSH
// repeat if keep_base_finished then
7341: LD_EXP 15
7345: IFFALSE 7349
// exit ;
7347: GO 7541
// if list then
7349: LD_VAR 0 1
7353: IFFALSE 7373
// ComRepairBuilding ( crane , list [ 1 ] ) else
7355: LD_INT 15
7357: PPUSH
7358: LD_VAR 0 1
7362: PUSH
7363: LD_INT 1
7365: ARRAY
7366: PPUSH
7367: CALL_OW 130
7371: GO 7375
// exit ;
7373: GO 7541
// if GetLives ( crane ) < 700 then
7375: LD_INT 15
7377: PPUSH
7378: CALL_OW 256
7382: PUSH
7383: LD_INT 700
7385: LESS
7386: IFFALSE 7488
// begin ComMoveToArea ( crane , am_repair ) ;
7388: LD_INT 15
7390: PPUSH
7391: LD_INT 11
7393: PPUSH
7394: CALL_OW 113
// while not IsInArea ( crane , am_repair ) do
7398: LD_INT 15
7400: PPUSH
7401: LD_INT 11
7403: PPUSH
7404: CALL_OW 308
7408: NOT
7409: IFFALSE 7420
// wait ( 0 0$1 ) ;
7411: LD_INT 35
7413: PPUSH
7414: CALL_OW 67
7418: GO 7398
// ComExitVehicle ( crane ) ;
7420: LD_INT 15
7422: PPUSH
7423: CALL_OW 121
// while IsDrivenBy ( crane ) do
7427: LD_INT 15
7429: PPUSH
7430: CALL_OW 311
7434: IFFALSE 7445
// wait ( 10 ) ;
7436: LD_INT 10
7438: PPUSH
7439: CALL_OW 67
7443: GO 7427
// ComRepairVehicle ( us_mech , crane ) ;
7445: LD_EXP 23
7449: PPUSH
7450: LD_INT 15
7452: PPUSH
7453: CALL_OW 129
// AddComEnterUnit ( us_mech , crane ) ;
7457: LD_EXP 23
7461: PPUSH
7462: LD_INT 15
7464: PPUSH
7465: CALL_OW 180
// while not IsDrivenBy ( crane ) do
7469: LD_INT 15
7471: PPUSH
7472: CALL_OW 311
7476: NOT
7477: IFFALSE 7488
// wait ( 0 0$1 ) ;
7479: LD_INT 35
7481: PPUSH
7482: CALL_OW 67
7486: GO 7469
// end ; if GetLives ( list [ 1 ] ) = 1000 then
7488: LD_VAR 0 1
7492: PUSH
7493: LD_INT 1
7495: ARRAY
7496: PPUSH
7497: CALL_OW 256
7501: PUSH
7502: LD_INT 1000
7504: EQUAL
7505: IFFALSE 7527
// list := list diff list [ 1 ] ;
7507: LD_ADDR_VAR 0 1
7511: PUSH
7512: LD_VAR 0 1
7516: PUSH
7517: LD_VAR 0 1
7521: PUSH
7522: LD_INT 1
7524: ARRAY
7525: DIFF
7526: ST_TO_ADDR
// wait ( 0 0$1 ) ;
7527: LD_INT 35
7529: PPUSH
7530: CALL_OW 67
// until not list ;
7534: LD_VAR 0 1
7538: NOT
7539: IFFALSE 7341
// end ; end_of_file
7541: LD_VAR 0 2
7545: RET
// every 0 0$2 + 0 0$0.1 do
7546: GO 7548
7548: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
7549: LD_INT 22
7551: PUSH
7552: LD_INT 7
7554: PUSH
7555: EMPTY
7556: LIST
7557: LIST
7558: PUSH
7559: LD_INT 2
7561: PUSH
7562: LD_INT 25
7564: PUSH
7565: LD_INT 12
7567: PUSH
7568: EMPTY
7569: LIST
7570: LIST
7571: PUSH
7572: LD_INT 25
7574: PUSH
7575: LD_INT 16
7577: PUSH
7578: EMPTY
7579: LIST
7580: LIST
7581: PUSH
7582: LD_INT 25
7584: PUSH
7585: LD_INT 15
7587: PUSH
7588: EMPTY
7589: LIST
7590: LIST
7591: PUSH
7592: LD_INT 25
7594: PUSH
7595: LD_INT 17
7597: PUSH
7598: EMPTY
7599: LIST
7600: LIST
7601: PUSH
7602: EMPTY
7603: LIST
7604: LIST
7605: LIST
7606: LIST
7607: LIST
7608: PUSH
7609: EMPTY
7610: LIST
7611: LIST
7612: PPUSH
7613: CALL_OW 69
7617: PUSH
7618: LD_INT 22
7620: PUSH
7621: LD_INT 7
7623: PUSH
7624: EMPTY
7625: LIST
7626: LIST
7627: PUSH
7628: LD_INT 21
7630: PUSH
7631: LD_INT 1
7633: PUSH
7634: EMPTY
7635: LIST
7636: LIST
7637: PUSH
7638: LD_INT 3
7640: PUSH
7641: LD_INT 2
7643: PUSH
7644: LD_INT 25
7646: PUSH
7647: LD_INT 12
7649: PUSH
7650: EMPTY
7651: LIST
7652: LIST
7653: PUSH
7654: LD_INT 25
7656: PUSH
7657: LD_INT 16
7659: PUSH
7660: EMPTY
7661: LIST
7662: LIST
7663: PUSH
7664: LD_INT 25
7666: PUSH
7667: LD_INT 15
7669: PUSH
7670: EMPTY
7671: LIST
7672: LIST
7673: PUSH
7674: LD_INT 25
7676: PUSH
7677: LD_INT 17
7679: PUSH
7680: EMPTY
7681: LIST
7682: LIST
7683: PUSH
7684: EMPTY
7685: LIST
7686: LIST
7687: LIST
7688: LIST
7689: LIST
7690: PUSH
7691: EMPTY
7692: LIST
7693: LIST
7694: PUSH
7695: EMPTY
7696: LIST
7697: LIST
7698: LIST
7699: PPUSH
7700: CALL_OW 69
7704: GREATER
7705: IFFALSE 7716
// begin SetAchievement ( ACH_POTA ) ;
7707: LD_STRING ACH_POTA
7709: PPUSH
7710: CALL_OW 543
// exit ;
7714: GO 7717
// end ; enable ;
7716: ENABLE
// end ; end_of_file
7717: END
// export function SA_EndMission ( campaignNumber , missionNumber , medal1 , medal2 , medal3 ) ; var achiv ; begin
7718: LD_INT 0
7720: PPUSH
7721: PPUSH
// if not missionNumber then
7722: LD_VAR 0 2
7726: NOT
7727: IFFALSE 7731
// exit ;
7729: GO 7861
// achiv := false ;
7731: LD_ADDR_VAR 0 7
7735: PUSH
7736: LD_INT 0
7738: ST_TO_ADDR
// case campaignNumber of 1 :
7739: LD_VAR 0 1
7743: PUSH
7744: LD_INT 1
7746: DOUBLE
7747: EQUAL
7748: IFTRUE 7752
7750: GO 7763
7752: POP
// achiv := ACH_GOTA ; 2 :
7753: LD_ADDR_VAR 0 7
7757: PUSH
7758: LD_STRING ACH_GOTA
7760: ST_TO_ADDR
7761: GO 7813
7763: LD_INT 2
7765: DOUBLE
7766: EQUAL
7767: IFTRUE 7771
7769: GO 7774
7771: POP
// ; 3 :
7772: GO 7813
7774: LD_INT 3
7776: DOUBLE
7777: EQUAL
7778: IFTRUE 7782
7780: GO 7793
7782: POP
// achiv := ACH_MOTSU ; 4 :
7783: LD_ADDR_VAR 0 7
7787: PUSH
7788: LD_STRING ACH_MOTSU
7790: ST_TO_ADDR
7791: GO 7813
7793: LD_INT 4
7795: DOUBLE
7796: EQUAL
7797: IFTRUE 7801
7799: GO 7812
7801: POP
// achiv := ACH_LOP ; end ;
7802: LD_ADDR_VAR 0 7
7806: PUSH
7807: LD_STRING ACH_LOP
7809: ST_TO_ADDR
7810: GO 7813
7812: POP
// if Difficulty = 3 and achiv and medal1 and medal2 and medal3 then
7813: LD_OWVAR 67
7817: PUSH
7818: LD_INT 3
7820: EQUAL
7821: PUSH
7822: LD_VAR 0 7
7826: AND
7827: PUSH
7828: LD_VAR 0 3
7832: AND
7833: PUSH
7834: LD_VAR 0 4
7838: AND
7839: PUSH
7840: LD_VAR 0 5
7844: AND
7845: IFFALSE 7861
// SetAchievementEX ( achiv , missionNumber ) ;
7847: LD_VAR 0 7
7851: PPUSH
7852: LD_VAR 0 2
7856: PPUSH
7857: CALL_OW 564
// end ;
7861: LD_VAR 0 6
7865: RET
// export function SA_BehemothConstructed ; begin
7866: LD_INT 0
7868: PPUSH
// SetAchievement ( ACH_SMC ) ;
7869: LD_STRING ACH_SMC
7871: PPUSH
7872: CALL_OW 543
// end ;
7876: LD_VAR 0 1
7880: RET

// export you , ru , us , ar , ar_al , neutral , camp ; export cpu_list ; export ru_nation , us_nation , ar_nation ; export Burlak , MacMillan , Roth , Gossudarov ; export Petrosyan , Belkov , Kirilenkova , Gnyevko , Gladkov , Dolgov , Gleb , Kapitsova , Kuzmov , Kovalyuk , Scholtze , Karamazov , Titov , Oblukov , Kozlov , Petrovova , Bystrov , Lipshchin , Fadeev , Xavier , survivors5 ; export Bobby , Brown , Cornell , Connie , Cyrus , Denis , Donaldson , Frank , Gary , Gladstone , Joan , Lisa , Peterson , Simms , VanHouten , Yamoko ; export Omar , OmarKilled , NegotiationOffered , OmarWillTryContaminateMotherlode ; export Powell , Platonov ; export aliance_forces ; export finalize ; export prefered_control ; export siberite_rocket_send ; function prepare_us_units ; begin
   0: LD_INT 0
   2: PPUSH
// Powell := NewCharacter ( Powell ) ;
   3: LD_ADDR_EXP 57
   7: PUSH
   8: LD_STRING Powell
  10: PPUSH
  11: CALL_OW 25
  15: ST_TO_ADDR
// SetSide ( Powell , us ) ;
  16: LD_EXP 57
  20: PPUSH
  21: LD_EXP 3
  25: PPUSH
  26: CALL_OW 235
// end ;
  30: LD_VAR 0 1
  34: RET
// function prepare_ru_units ; begin
  35: LD_INT 0
  37: PPUSH
// Platonov := NewCharacter ( Platonov ) ;
  38: LD_ADDR_EXP 58
  42: PUSH
  43: LD_STRING Platonov
  45: PPUSH
  46: CALL_OW 25
  50: ST_TO_ADDR
// SetSide ( Platonov , ru ) ;
  51: LD_EXP 58
  55: PPUSH
  56: LD_EXP 2
  60: PPUSH
  61: CALL_OW 235
// end ;
  65: LD_VAR 0 1
  69: RET
// function prepare_ar_units ; begin
  70: LD_INT 0
  72: PPUSH
// OmarWillTryContaminateMotherlode = false ;
  73: LD_ADDR_EXP 56
  77: PUSH
  78: LD_INT 0
  80: ST_TO_ADDR
// if difficulty >= 2 then
  81: LD_OWVAR 67
  85: PUSH
  86: LD_INT 2
  88: GREATEREQUAL
  89: IFFALSE 106
// SetTech ( tech_stimdrugs , ar_al , state_researched ) ;
  91: LD_INT 5
  93: PPUSH
  94: LD_EXP 5
  98: PPUSH
  99: LD_INT 2
 101: PPUSH
 102: CALL_OW 322
// if camp = 6 then
 106: LD_EXP 7
 110: PUSH
 111: LD_INT 6
 113: EQUAL
 114: IFFALSE 134
// OmarKilled := LoadVariable ( OmarKilled , true ) else
 116: LD_ADDR_EXP 54
 120: PUSH
 121: LD_STRING OmarKilled
 123: PPUSH
 124: LD_INT 1
 126: PPUSH
 127: CALL_OW 30
 131: ST_TO_ADDR
 132: GO 142
// OmarKilled = false ;
 134: LD_ADDR_EXP 54
 138: PUSH
 139: LD_INT 0
 141: ST_TO_ADDR
// if OmarKilled then
 142: LD_EXP 54
 146: IFFALSE 158
// begin Omar = 0 ;
 148: LD_ADDR_EXP 53
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// exit ;
 156: GO 244
// end ; if TestCharacters ( Omar ) then
 158: LD_STRING Omar
 160: PPUSH
 161: CALL_OW 28
 165: IFFALSE 182
// Omar := CreateCharacter ( Omar ) else
 167: LD_ADDR_EXP 53
 171: PUSH
 172: LD_STRING Omar
 174: PPUSH
 175: CALL_OW 34
 179: ST_TO_ADDR
 180: GO 195
// Omar = NewCharacter ( Omar ) ;
 182: LD_ADDR_EXP 53
 186: PUSH
 187: LD_STRING Omar
 189: PPUSH
 190: CALL_OW 25
 194: ST_TO_ADDR
// SetSide ( Omar , ar_al ) ;
 195: LD_EXP 53
 199: PPUSH
 200: LD_EXP 5
 204: PPUSH
 205: CALL_OW 235
// NegotiationOffered := LoadVariable ( NegotiationsOffered , false ) ;
 209: LD_ADDR_EXP 55
 213: PUSH
 214: LD_STRING NegotiationsOffered
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// if NegotiationOffered then
 225: LD_EXP 55
 229: IFFALSE 236
// enable ( 2 ) else
 231: LD_INT 2
 233: ENABLE_MARKED
 234: GO 244
// OmarWillTryContaminateMotherlode = true ;
 236: LD_ADDR_EXP 56
 240: PUSH
 241: LD_INT 1
 243: ST_TO_ADDR
// end ;
 244: LD_VAR 0 1
 248: RET
// function prepare_al_units ; var un , count , i , nations , art_loaded , selected , aliance , pom_list , veh_cargo , veh_basic , veh_battle , vehicles , veh_list , JMM_car , Bur_car ; begin
 249: LD_INT 0
 251: PPUSH
 252: PPUSH
 253: PPUSH
 254: PPUSH
 255: PPUSH
 256: PPUSH
 257: PPUSH
 258: PPUSH
 259: PPUSH
 260: PPUSH
 261: PPUSH
 262: PPUSH
 263: PPUSH
 264: PPUSH
 265: PPUSH
 266: PPUSH
// nations := [ nation_american , nation_russian ] ;
 267: LD_ADDR_VAR 0 5
 271: PUSH
 272: LD_INT 1
 274: PUSH
 275: LD_INT 3
 277: PUSH
 278: EMPTY
 279: LIST
 280: LIST
 281: ST_TO_ADDR
// uc_side := you ;
 282: LD_ADDR_OWVAR 20
 286: PUSH
 287: LD_EXP 1
 291: ST_TO_ADDR
// aliance_forces := [ ] ;
 292: LD_ADDR_EXP 59
 296: PUSH
 297: EMPTY
 298: ST_TO_ADDR
// load_all_aliance ;
 299: CALL 2860 0 0
// aliance := [ ] ;
 303: LD_ADDR_VAR 0 8
 307: PUSH
 308: EMPTY
 309: ST_TO_ADDR
// Burlak := CreateCharacter ( Burlak ) ;
 310: LD_ADDR_EXP 12
 314: PUSH
 315: LD_STRING Burlak
 317: PPUSH
 318: CALL_OW 34
 322: ST_TO_ADDR
// aliance := aliance ^ Burlak ;
 323: LD_ADDR_VAR 0 8
 327: PUSH
 328: LD_VAR 0 8
 332: PUSH
 333: LD_EXP 12
 337: ADD
 338: ST_TO_ADDR
// if TestCharacters ( JMM ) and CheckCharacterSet ( JMM ) then
 339: LD_STRING JMM
 341: PPUSH
 342: CALL_OW 28
 346: PUSH
 347: LD_STRING JMM
 349: PPUSH
 350: CALL_OW 29
 354: AND
 355: IFFALSE 398
// begin MacMillan := CreateCharacter ( JMM ) ;
 357: LD_ADDR_EXP 13
 361: PUSH
 362: LD_STRING JMM
 364: PPUSH
 365: CALL_OW 34
 369: ST_TO_ADDR
// SetClass ( MacMillan , class_engineer ) ;
 370: LD_EXP 13
 374: PPUSH
 375: LD_INT 2
 377: PPUSH
 378: CALL_OW 336
// aliance := aliance ^ MacMillan ;
 382: LD_ADDR_VAR 0 8
 386: PUSH
 387: LD_VAR 0 8
 391: PUSH
 392: LD_EXP 13
 396: ADD
 397: ST_TO_ADDR
// end ; if TestCharacters ( Roth ) and CheckCharacterSet ( Roth ) then
 398: LD_STRING Roth
 400: PPUSH
 401: CALL_OW 28
 405: PUSH
 406: LD_STRING Roth
 408: PPUSH
 409: CALL_OW 29
 413: AND
 414: IFFALSE 457
// begin Roth := CreateCharacter ( Roth ) ;
 416: LD_ADDR_EXP 14
 420: PUSH
 421: LD_STRING Roth
 423: PPUSH
 424: CALL_OW 34
 428: ST_TO_ADDR
// SetClass ( Roth , class_scientistic ) ;
 429: LD_EXP 14
 433: PPUSH
 434: LD_INT 4
 436: PPUSH
 437: CALL_OW 336
// aliance := aliance ^ Roth ;
 441: LD_ADDR_VAR 0 8
 445: PUSH
 446: LD_VAR 0 8
 450: PUSH
 451: LD_EXP 14
 455: ADD
 456: ST_TO_ADDR
// end ; if TestCharacters ( Gossudarov ) and CheckCharacterSet ( Gossudarov ) then
 457: LD_STRING Gossudarov
 459: PPUSH
 460: CALL_OW 28
 464: PUSH
 465: LD_STRING Gossudarov
 467: PPUSH
 468: CALL_OW 29
 472: AND
 473: IFFALSE 516
// begin Gossudarov := CreateCharacter ( Gossudarov ) ;
 475: LD_ADDR_EXP 15
 479: PUSH
 480: LD_STRING Gossudarov
 482: PPUSH
 483: CALL_OW 34
 487: ST_TO_ADDR
// SetClass ( Gossudarov , class_scientistic ) ;
 488: LD_EXP 15
 492: PPUSH
 493: LD_INT 4
 495: PPUSH
 496: CALL_OW 336
// aliance := aliance ^ Gossudarov ;
 500: LD_ADDR_VAR 0 8
 504: PUSH
 505: LD_VAR 0 8
 509: PUSH
 510: LD_EXP 15
 514: ADD
 515: ST_TO_ADDR
// end ; if aliance_forces < 20 then
 516: LD_EXP 59
 520: PUSH
 521: LD_INT 20
 523: LESS
 524: IFFALSE 612
// for i = aliance_forces to 20 do
 526: LD_ADDR_VAR 0 4
 530: PUSH
 531: DOUBLE
 532: LD_EXP 59
 536: DEC
 537: ST_TO_ADDR
 538: LD_INT 20
 540: PUSH
 541: FOR_TO
 542: IFFALSE 610
// begin PrepareHuman ( 0 , 0 , 6 ) ;
 544: LD_INT 0
 546: PPUSH
 547: LD_INT 0
 549: PPUSH
 550: LD_INT 6
 552: PPUSH
 553: CALL_OW 380
// hc_last_mission := 15 ;
 557: LD_ADDR_OWVAR 36
 561: PUSH
 562: LD_INT 15
 564: ST_TO_ADDR
// uc_nation = [ nation_american , nation_russian ] [ Rand ( 1 , 2 ) ] ;
 565: LD_ADDR_OWVAR 21
 569: PUSH
 570: LD_INT 1
 572: PUSH
 573: LD_INT 3
 575: PUSH
 576: EMPTY
 577: LIST
 578: LIST
 579: PUSH
 580: LD_INT 1
 582: PPUSH
 583: LD_INT 2
 585: PPUSH
 586: CALL_OW 12
 590: ARRAY
 591: ST_TO_ADDR
// aliance_forces := aliance_forces ^ CreateHuman ;
 592: LD_ADDR_EXP 59
 596: PUSH
 597: LD_EXP 59
 601: PUSH
 602: CALL_OW 44
 606: ADD
 607: ST_TO_ADDR
// end ;
 608: GO 541
 610: POP
 611: POP
// selected := CharacterSelection (  , 12 - aliance , 12 - aliance , aliance ^ [ sel_not_hired , sel_changeable , sel_change_class ] ^ aliance_forces , [ class_soldier , class_engineer , class_mechanic , class_scientistic ] ) ;
 612: LD_ADDR_VAR 0 7
 616: PUSH
 617: LD_STRING 
 619: PPUSH
 620: LD_INT 12
 622: PUSH
 623: LD_VAR 0 8
 627: MINUS
 628: PPUSH
 629: LD_INT 12
 631: PUSH
 632: LD_VAR 0 8
 636: MINUS
 637: PPUSH
 638: LD_VAR 0 8
 642: PUSH
 643: LD_INT -2
 645: PUSH
 646: LD_INT -3
 648: PUSH
 649: LD_INT -5
 651: PUSH
 652: EMPTY
 653: LIST
 654: LIST
 655: LIST
 656: ADD
 657: PUSH
 658: LD_EXP 59
 662: ADD
 663: PPUSH
 664: LD_INT 1
 666: PUSH
 667: LD_INT 2
 669: PUSH
 670: LD_INT 3
 672: PUSH
 673: LD_INT 4
 675: PUSH
 676: EMPTY
 677: LIST
 678: LIST
 679: LIST
 680: LIST
 681: PPUSH
 682: CALL_OW 42
 686: ST_TO_ADDR
// aliance_forces := aliance ^ selected ;
 687: LD_ADDR_EXP 59
 691: PUSH
 692: LD_VAR 0 8
 696: PUSH
 697: LD_VAR 0 7
 701: ADD
 702: ST_TO_ADDR
// JMM_car := LoadVariable ( JMM_car , [ us_medium_tracked , engine_combustion , control_manual , us_cargo_bay ] ) ;
 703: LD_ADDR_VAR 0 15
 707: PUSH
 708: LD_STRING JMM_car
 710: PPUSH
 711: LD_INT 3
 713: PUSH
 714: LD_INT 1
 716: PUSH
 717: LD_INT 1
 719: PUSH
 720: LD_INT 12
 722: PUSH
 723: EMPTY
 724: LIST
 725: LIST
 726: LIST
 727: LIST
 728: PPUSH
 729: CALL_OW 30
 733: ST_TO_ADDR
// Bur_car := LoadVariable ( Bur_car , [ ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher ] ) ;
 734: LD_ADDR_VAR 0 16
 738: PUSH
 739: LD_STRING Bur_car
 741: PPUSH
 742: LD_INT 22
 744: PUSH
 745: LD_INT 3
 747: PUSH
 748: LD_INT 1
 750: PUSH
 751: LD_INT 45
 753: PUSH
 754: EMPTY
 755: LIST
 756: LIST
 757: LIST
 758: LIST
 759: PPUSH
 760: CALL_OW 30
 764: ST_TO_ADDR
// if TestVariable ( Masha ) then
 765: LD_STRING Masha
 767: PPUSH
 768: CALL_OW 27
 772: IFFALSE 805
// Bur_car = LoadVariable ( Masha , [ ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher ] ) ;
 774: LD_ADDR_VAR 0 16
 778: PUSH
 779: LD_STRING Masha
 781: PPUSH
 782: LD_INT 22
 784: PUSH
 785: LD_INT 3
 787: PUSH
 788: LD_INT 1
 790: PUSH
 791: LD_INT 45
 793: PUSH
 794: EMPTY
 795: LIST
 796: LIST
 797: LIST
 798: LIST
 799: PPUSH
 800: CALL_OW 30
 804: ST_TO_ADDR
// if ( JMM_car [ 1 ] = 0 ) then
 805: LD_VAR 0 15
 809: PUSH
 810: LD_INT 1
 812: ARRAY
 813: PUSH
 814: LD_INT 0
 816: EQUAL
 817: IFFALSE 842
// JMM_car := [ us_medium_tracked , engine_combustion , control_manual , us_cargo_bay ] ;
 819: LD_ADDR_VAR 0 15
 823: PUSH
 824: LD_INT 3
 826: PUSH
 827: LD_INT 1
 829: PUSH
 830: LD_INT 1
 832: PUSH
 833: LD_INT 12
 835: PUSH
 836: EMPTY
 837: LIST
 838: LIST
 839: LIST
 840: LIST
 841: ST_TO_ADDR
// if ( Bur_car [ 1 ] = 0 ) then
 842: LD_VAR 0 16
 846: PUSH
 847: LD_INT 1
 849: ARRAY
 850: PUSH
 851: LD_INT 0
 853: EQUAL
 854: IFFALSE 879
// Bur_car := [ ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher ] ;
 856: LD_ADDR_VAR 0 16
 860: PUSH
 861: LD_INT 22
 863: PUSH
 864: LD_INT 3
 866: PUSH
 867: LD_INT 1
 869: PUSH
 870: LD_INT 45
 872: PUSH
 873: EMPTY
 874: LIST
 875: LIST
 876: LIST
 877: LIST
 878: ST_TO_ADDR
// if not ( ( JMM_car [ 4 ] in [ us_cargo_bay , ru_cargo_bay ] ) or ( Bur_car [ 4 ] in [ us_cargo_bay , ru_cargo_bay ] ) ) then
 879: LD_VAR 0 15
 883: PUSH
 884: LD_INT 4
 886: ARRAY
 887: PUSH
 888: LD_INT 12
 890: PUSH
 891: LD_INT 51
 893: PUSH
 894: EMPTY
 895: LIST
 896: LIST
 897: IN
 898: PUSH
 899: LD_VAR 0 16
 903: PUSH
 904: LD_INT 4
 906: ARRAY
 907: PUSH
 908: LD_INT 12
 910: PUSH
 911: LD_INT 51
 913: PUSH
 914: EMPTY
 915: LIST
 916: LIST
 917: IN
 918: OR
 919: NOT
 920: IFFALSE 945
// JMM_car := [ us_medium_tracked , engine_combustion , control_manual , us_cargo_bay ] ;
 922: LD_ADDR_VAR 0 15
 926: PUSH
 927: LD_INT 3
 929: PUSH
 930: LD_INT 1
 932: PUSH
 933: LD_INT 1
 935: PUSH
 936: LD_INT 12
 938: PUSH
 939: EMPTY
 940: LIST
 941: LIST
 942: LIST
 943: LIST
 944: ST_TO_ADDR
// if JMM_car [ 1 ] in [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] then
 945: LD_VAR 0 15
 949: PUSH
 950: LD_INT 1
 952: ARRAY
 953: PUSH
 954: LD_INT 1
 956: PUSH
 957: LD_INT 2
 959: PUSH
 960: LD_INT 3
 962: PUSH
 963: LD_INT 4
 965: PUSH
 966: LD_INT 5
 968: PUSH
 969: EMPTY
 970: LIST
 971: LIST
 972: LIST
 973: LIST
 974: LIST
 975: IN
 976: IFFALSE 988
// uc_nation := nation_american else
 978: LD_ADDR_OWVAR 21
 982: PUSH
 983: LD_INT 1
 985: ST_TO_ADDR
 986: GO 996
// uc_nation := nation_russian ;
 988: LD_ADDR_OWVAR 21
 992: PUSH
 993: LD_INT 3
 995: ST_TO_ADDR
// uc_direction := Rand ( 2 , 3 ) ;
 996: LD_ADDR_OWVAR 24
1000: PUSH
1001: LD_INT 2
1003: PPUSH
1004: LD_INT 3
1006: PPUSH
1007: CALL_OW 12
1011: ST_TO_ADDR
// vc_chassis := JMM_car [ 1 ] ;
1012: LD_ADDR_OWVAR 37
1016: PUSH
1017: LD_VAR 0 15
1021: PUSH
1022: LD_INT 1
1024: ARRAY
1025: ST_TO_ADDR
// vc_engine := JMM_car [ 2 ] ;
1026: LD_ADDR_OWVAR 39
1030: PUSH
1031: LD_VAR 0 15
1035: PUSH
1036: LD_INT 2
1038: ARRAY
1039: ST_TO_ADDR
// vc_control := JMM_car [ 3 ] ;
1040: LD_ADDR_OWVAR 38
1044: PUSH
1045: LD_VAR 0 15
1049: PUSH
1050: LD_INT 3
1052: ARRAY
1053: ST_TO_ADDR
// vc_weapon := JMM_car [ 4 ] ;
1054: LD_ADDR_OWVAR 40
1058: PUSH
1059: LD_VAR 0 15
1063: PUSH
1064: LD_INT 4
1066: ARRAY
1067: ST_TO_ADDR
// un := CreateVehicle ;
1068: LD_ADDR_VAR 0 2
1072: PUSH
1073: CALL_OW 45
1077: ST_TO_ADDR
// art_loaded := false ;
1078: LD_ADDR_VAR 0 6
1082: PUSH
1083: LD_INT 0
1085: ST_TO_ADDR
// PlaceHumanInUnit ( MacMillan , un ) ;
1086: LD_EXP 13
1090: PPUSH
1091: LD_VAR 0 2
1095: PPUSH
1096: CALL_OW 52
// PlaceUnitArea ( un , jmm_starting , false ) ;
1100: LD_VAR 0 2
1104: PPUSH
1105: LD_INT 27
1107: PPUSH
1108: LD_INT 0
1110: PPUSH
1111: CALL_OW 49
// if GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay ] then
1115: LD_VAR 0 2
1119: PPUSH
1120: CALL_OW 264
1124: PUSH
1125: LD_INT 12
1127: PUSH
1128: LD_INT 51
1130: PUSH
1131: EMPTY
1132: LIST
1133: LIST
1134: IN
1135: IFFALSE 1160
// begin SetCargo ( un , mat_artefact , 50 ) ;
1137: LD_VAR 0 2
1141: PPUSH
1142: LD_INT 4
1144: PPUSH
1145: LD_INT 50
1147: PPUSH
1148: CALL_OW 290
// art_loaded := true ;
1152: LD_ADDR_VAR 0 6
1156: PUSH
1157: LD_INT 1
1159: ST_TO_ADDR
// end ; if Bur_car [ 1 ] in [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] then
1160: LD_VAR 0 16
1164: PUSH
1165: LD_INT 1
1167: ARRAY
1168: PUSH
1169: LD_INT 21
1171: PUSH
1172: LD_INT 22
1174: PUSH
1175: LD_INT 23
1177: PUSH
1178: LD_INT 24
1180: PUSH
1181: EMPTY
1182: LIST
1183: LIST
1184: LIST
1185: LIST
1186: IN
1187: IFFALSE 1199
// uc_nation := nation_russian else
1189: LD_ADDR_OWVAR 21
1193: PUSH
1194: LD_INT 3
1196: ST_TO_ADDR
1197: GO 1207
// uc_nation := nation_american ;
1199: LD_ADDR_OWVAR 21
1203: PUSH
1204: LD_INT 1
1206: ST_TO_ADDR
// uc_direction := Rand ( 2 , 3 ) ;
1207: LD_ADDR_OWVAR 24
1211: PUSH
1212: LD_INT 2
1214: PPUSH
1215: LD_INT 3
1217: PPUSH
1218: CALL_OW 12
1222: ST_TO_ADDR
// vc_chassis := Bur_car [ 1 ] ;
1223: LD_ADDR_OWVAR 37
1227: PUSH
1228: LD_VAR 0 16
1232: PUSH
1233: LD_INT 1
1235: ARRAY
1236: ST_TO_ADDR
// vc_engine := Bur_car [ 2 ] ;
1237: LD_ADDR_OWVAR 39
1241: PUSH
1242: LD_VAR 0 16
1246: PUSH
1247: LD_INT 2
1249: ARRAY
1250: ST_TO_ADDR
// vc_control := Bur_car [ 3 ] ;
1251: LD_ADDR_OWVAR 38
1255: PUSH
1256: LD_VAR 0 16
1260: PUSH
1261: LD_INT 3
1263: ARRAY
1264: ST_TO_ADDR
// vc_weapon := Bur_car [ 4 ] ;
1265: LD_ADDR_OWVAR 40
1269: PUSH
1270: LD_VAR 0 16
1274: PUSH
1275: LD_INT 4
1277: ARRAY
1278: ST_TO_ADDR
// un := CreateVehicle ;
1279: LD_ADDR_VAR 0 2
1283: PUSH
1284: CALL_OW 45
1288: ST_TO_ADDR
// if TestVariable ( Masha ) then
1289: LD_STRING Masha
1291: PPUSH
1292: CALL_OW 27
1296: IFFALSE 1310
// SetMark ( un , 1 ) ;
1298: LD_VAR 0 2
1302: PPUSH
1303: LD_INT 1
1305: PPUSH
1306: CALL_OW 242
// PlaceHumanInUnit ( Burlak , un ) ;
1310: LD_EXP 12
1314: PPUSH
1315: LD_VAR 0 2
1319: PPUSH
1320: CALL_OW 52
// PlaceUnitArea ( un , burlak_starting , false ) ;
1324: LD_VAR 0 2
1328: PPUSH
1329: LD_INT 10
1331: PPUSH
1332: LD_INT 0
1334: PPUSH
1335: CALL_OW 49
// if ( GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay ] ) and not art_loaded then
1339: LD_VAR 0 2
1343: PPUSH
1344: CALL_OW 264
1348: PUSH
1349: LD_INT 12
1351: PUSH
1352: LD_INT 51
1354: PUSH
1355: EMPTY
1356: LIST
1357: LIST
1358: IN
1359: PUSH
1360: LD_VAR 0 6
1364: NOT
1365: AND
1366: IFFALSE 1383
// SetCargo ( un , mat_artefact , 50 ) ;
1368: LD_VAR 0 2
1372: PPUSH
1373: LD_INT 4
1375: PPUSH
1376: LD_INT 50
1378: PPUSH
1379: CALL_OW 290
// veh_cargo := [ [ nation_american , us_medium_tracked , engine_combustion , control_computer , us_cargo_bay ] , [ nation_american , us_medium_tracked , engine_combustion , control_manual , us_cargo_bay ] , [ nation_russian , ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay ] , [ nation_russian , ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay ] ] ;
1383: LD_ADDR_VAR 0 10
1387: PUSH
1388: LD_INT 1
1390: PUSH
1391: LD_INT 3
1393: PUSH
1394: LD_INT 1
1396: PUSH
1397: LD_INT 3
1399: PUSH
1400: LD_INT 12
1402: PUSH
1403: EMPTY
1404: LIST
1405: LIST
1406: LIST
1407: LIST
1408: LIST
1409: PUSH
1410: LD_INT 1
1412: PUSH
1413: LD_INT 3
1415: PUSH
1416: LD_INT 1
1418: PUSH
1419: LD_INT 1
1421: PUSH
1422: LD_INT 12
1424: PUSH
1425: EMPTY
1426: LIST
1427: LIST
1428: LIST
1429: LIST
1430: LIST
1431: PUSH
1432: LD_INT 3
1434: PUSH
1435: LD_INT 22
1437: PUSH
1438: LD_INT 3
1440: PUSH
1441: LD_INT 3
1443: PUSH
1444: LD_INT 51
1446: PUSH
1447: EMPTY
1448: LIST
1449: LIST
1450: LIST
1451: LIST
1452: LIST
1453: PUSH
1454: LD_INT 3
1456: PUSH
1457: LD_INT 22
1459: PUSH
1460: LD_INT 3
1462: PUSH
1463: LD_INT 1
1465: PUSH
1466: LD_INT 51
1468: PUSH
1469: EMPTY
1470: LIST
1471: LIST
1472: LIST
1473: LIST
1474: LIST
1475: PUSH
1476: EMPTY
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: ST_TO_ADDR
// veh_basic := [ [ nation_american , us_medium_tracked , engine_combustion , control_computer , us_crane ] , [ nation_russian , ru_heavy_tracked , engine_siberite , control_manual , ru_bulldozer ] , ] ;
1482: LD_ADDR_VAR 0 11
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 3
1492: PUSH
1493: LD_INT 1
1495: PUSH
1496: LD_INT 3
1498: PUSH
1499: LD_INT 13
1501: PUSH
1502: EMPTY
1503: LIST
1504: LIST
1505: LIST
1506: LIST
1507: LIST
1508: PUSH
1509: LD_INT 3
1511: PUSH
1512: LD_INT 24
1514: PUSH
1515: LD_INT 3
1517: PUSH
1518: LD_INT 1
1520: PUSH
1521: LD_INT 53
1523: PUSH
1524: EMPTY
1525: LIST
1526: LIST
1527: LIST
1528: LIST
1529: LIST
1530: PUSH
1531: EMPTY
1532: LIST
1533: LIST
1534: ST_TO_ADDR
// veh_battle := [ [ nation_american , us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ nation_american , us_medium_tracked , engine_siberite , control_manual , us_laser ] , [ nation_american , us_heavy_tracked , engine_siberite , control_manual , us_heavy_gun ] , [ nation_american , us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ nation_russian , ru_medium_wheeled , engine_combustion , control_manual , ru_rocket_launcher ] , [ nation_russian , ru_medium_tracked , engine_siberite , control_manual , ru_gun ] , [ nation_russian , ru_heavy_wheeled , engine_combustion , control_manual , ru_heavy_gun ] , [ nation_russian , ru_heavy_tracked , engine_siberite , control_manual , ru_heavy_gun ] , ] ;
1535: LD_ADDR_VAR 0 12
1539: PUSH
1540: LD_INT 1
1542: PUSH
1543: LD_INT 3
1545: PUSH
1546: LD_INT 1
1548: PUSH
1549: LD_INT 1
1551: PUSH
1552: LD_INT 7
1554: PUSH
1555: EMPTY
1556: LIST
1557: LIST
1558: LIST
1559: LIST
1560: LIST
1561: PUSH
1562: LD_INT 1
1564: PUSH
1565: LD_INT 3
1567: PUSH
1568: LD_INT 3
1570: PUSH
1571: LD_INT 1
1573: PUSH
1574: LD_INT 9
1576: PUSH
1577: EMPTY
1578: LIST
1579: LIST
1580: LIST
1581: LIST
1582: LIST
1583: PUSH
1584: LD_INT 1
1586: PUSH
1587: LD_INT 4
1589: PUSH
1590: LD_INT 3
1592: PUSH
1593: LD_INT 1
1595: PUSH
1596: LD_INT 6
1598: PUSH
1599: EMPTY
1600: LIST
1601: LIST
1602: LIST
1603: LIST
1604: LIST
1605: PUSH
1606: LD_INT 1
1608: PUSH
1609: LD_INT 5
1611: PUSH
1612: LD_INT 1
1614: PUSH
1615: LD_INT 1
1617: PUSH
1618: LD_INT 7
1620: PUSH
1621: EMPTY
1622: LIST
1623: LIST
1624: LIST
1625: LIST
1626: LIST
1627: PUSH
1628: LD_INT 3
1630: PUSH
1631: LD_INT 21
1633: PUSH
1634: LD_INT 1
1636: PUSH
1637: LD_INT 1
1639: PUSH
1640: LD_INT 45
1642: PUSH
1643: EMPTY
1644: LIST
1645: LIST
1646: LIST
1647: LIST
1648: LIST
1649: PUSH
1650: LD_INT 3
1652: PUSH
1653: LD_INT 22
1655: PUSH
1656: LD_INT 3
1658: PUSH
1659: LD_INT 1
1661: PUSH
1662: LD_INT 44
1664: PUSH
1665: EMPTY
1666: LIST
1667: LIST
1668: LIST
1669: LIST
1670: LIST
1671: PUSH
1672: LD_INT 3
1674: PUSH
1675: LD_INT 23
1677: PUSH
1678: LD_INT 1
1680: PUSH
1681: LD_INT 1
1683: PUSH
1684: LD_INT 46
1686: PUSH
1687: EMPTY
1688: LIST
1689: LIST
1690: LIST
1691: LIST
1692: LIST
1693: PUSH
1694: LD_INT 3
1696: PUSH
1697: LD_INT 24
1699: PUSH
1700: LD_INT 3
1702: PUSH
1703: LD_INT 1
1705: PUSH
1706: LD_INT 46
1708: PUSH
1709: EMPTY
1710: LIST
1711: LIST
1712: LIST
1713: LIST
1714: LIST
1715: PUSH
1716: EMPTY
1717: LIST
1718: LIST
1719: LIST
1720: LIST
1721: LIST
1722: LIST
1723: LIST
1724: LIST
1725: ST_TO_ADDR
// veh_list := [ ] ;
1726: LD_ADDR_VAR 0 14
1730: PUSH
1731: EMPTY
1732: ST_TO_ADDR
// count := 0 ;
1733: LD_ADDR_VAR 0 3
1737: PUSH
1738: LD_INT 0
1740: ST_TO_ADDR
// for i = 3 to 4 do
1741: LD_ADDR_VAR 0 4
1745: PUSH
1746: DOUBLE
1747: LD_INT 3
1749: DEC
1750: ST_TO_ADDR
1751: LD_INT 4
1753: PUSH
1754: FOR_TO
1755: IFFALSE 1940
// begin uc_direction := Rand ( 2 , 3 ) ;
1757: LD_ADDR_OWVAR 24
1761: PUSH
1762: LD_INT 2
1764: PPUSH
1765: LD_INT 3
1767: PPUSH
1768: CALL_OW 12
1772: ST_TO_ADDR
// un := veh_cargo [ Rand ( 1 , veh_cargo ) ] ;
1773: LD_ADDR_VAR 0 2
1777: PUSH
1778: LD_VAR 0 10
1782: PUSH
1783: LD_INT 1
1785: PPUSH
1786: LD_VAR 0 10
1790: PPUSH
1791: CALL_OW 12
1795: ARRAY
1796: ST_TO_ADDR
// uc_nation := un [ 1 ] ;
1797: LD_ADDR_OWVAR 21
1801: PUSH
1802: LD_VAR 0 2
1806: PUSH
1807: LD_INT 1
1809: ARRAY
1810: ST_TO_ADDR
// vc_chassis := un [ 2 ] ;
1811: LD_ADDR_OWVAR 37
1815: PUSH
1816: LD_VAR 0 2
1820: PUSH
1821: LD_INT 2
1823: ARRAY
1824: ST_TO_ADDR
// vc_engine := un [ 3 ] ;
1825: LD_ADDR_OWVAR 39
1829: PUSH
1830: LD_VAR 0 2
1834: PUSH
1835: LD_INT 3
1837: ARRAY
1838: ST_TO_ADDR
// vc_control := un [ 4 ] ;
1839: LD_ADDR_OWVAR 38
1843: PUSH
1844: LD_VAR 0 2
1848: PUSH
1849: LD_INT 4
1851: ARRAY
1852: ST_TO_ADDR
// vc_weapon := un [ 5 ] ;
1853: LD_ADDR_OWVAR 40
1857: PUSH
1858: LD_VAR 0 2
1862: PUSH
1863: LD_INT 5
1865: ARRAY
1866: ST_TO_ADDR
// veh_list := veh_list ^ CreateVehicle ;
1867: LD_ADDR_VAR 0 14
1871: PUSH
1872: LD_VAR 0 14
1876: PUSH
1877: CALL_OW 45
1881: ADD
1882: ST_TO_ADDR
// if un [ 4 ] = control_manual then
1883: LD_VAR 0 2
1887: PUSH
1888: LD_INT 4
1890: ARRAY
1891: PUSH
1892: LD_INT 1
1894: EQUAL
1895: IFFALSE 1911
// count := count + 1 ;
1897: LD_ADDR_VAR 0 3
1901: PUSH
1902: LD_VAR 0 3
1906: PUSH
1907: LD_INT 1
1909: PLUS
1910: ST_TO_ADDR
// SetCargo ( veh_list [ veh_list ] , mat_artefact , i * 10 ) ;
1911: LD_VAR 0 14
1915: PUSH
1916: LD_VAR 0 14
1920: ARRAY
1921: PPUSH
1922: LD_INT 4
1924: PPUSH
1925: LD_VAR 0 4
1929: PUSH
1930: LD_INT 10
1932: MUL
1933: PPUSH
1934: CALL_OW 290
// end ;
1938: GO 1754
1940: POP
1941: POP
// for un in veh_basic do
1942: LD_ADDR_VAR 0 2
1946: PUSH
1947: LD_VAR 0 11
1951: PUSH
1952: FOR_IN
1953: IFFALSE 2087
// begin uc_direction := Rand ( 2 , 3 ) ;
1955: LD_ADDR_OWVAR 24
1959: PUSH
1960: LD_INT 2
1962: PPUSH
1963: LD_INT 3
1965: PPUSH
1966: CALL_OW 12
1970: ST_TO_ADDR
// uc_nation := un [ 1 ] ;
1971: LD_ADDR_OWVAR 21
1975: PUSH
1976: LD_VAR 0 2
1980: PUSH
1981: LD_INT 1
1983: ARRAY
1984: ST_TO_ADDR
// vc_chassis := un [ 2 ] ;
1985: LD_ADDR_OWVAR 37
1989: PUSH
1990: LD_VAR 0 2
1994: PUSH
1995: LD_INT 2
1997: ARRAY
1998: ST_TO_ADDR
// vc_engine := un [ 3 ] ;
1999: LD_ADDR_OWVAR 39
2003: PUSH
2004: LD_VAR 0 2
2008: PUSH
2009: LD_INT 3
2011: ARRAY
2012: ST_TO_ADDR
// vc_control := un [ 4 ] ;
2013: LD_ADDR_OWVAR 38
2017: PUSH
2018: LD_VAR 0 2
2022: PUSH
2023: LD_INT 4
2025: ARRAY
2026: ST_TO_ADDR
// vc_weapon := un [ 5 ] ;
2027: LD_ADDR_OWVAR 40
2031: PUSH
2032: LD_VAR 0 2
2036: PUSH
2037: LD_INT 5
2039: ARRAY
2040: ST_TO_ADDR
// veh_list := veh_list ^ CreateVehicle ;
2041: LD_ADDR_VAR 0 14
2045: PUSH
2046: LD_VAR 0 14
2050: PUSH
2051: CALL_OW 45
2055: ADD
2056: ST_TO_ADDR
// if un [ 4 ] = control_manual then
2057: LD_VAR 0 2
2061: PUSH
2062: LD_INT 4
2064: ARRAY
2065: PUSH
2066: LD_INT 1
2068: EQUAL
2069: IFFALSE 2085
// count := count + 1 ;
2071: LD_ADDR_VAR 0 3
2075: PUSH
2076: LD_VAR 0 3
2080: PUSH
2081: LD_INT 1
2083: PLUS
2084: ST_TO_ADDR
// end ;
2085: GO 1952
2087: POP
2088: POP
// count := aliance_forces - 2 - count ;
2089: LD_ADDR_VAR 0 3
2093: PUSH
2094: LD_EXP 59
2098: PUSH
2099: LD_INT 2
2101: MINUS
2102: PUSH
2103: LD_VAR 0 3
2107: MINUS
2108: ST_TO_ADDR
// for i = 1 to count do
2109: LD_ADDR_VAR 0 4
2113: PUSH
2114: DOUBLE
2115: LD_INT 1
2117: DEC
2118: ST_TO_ADDR
2119: LD_VAR 0 3
2123: PUSH
2124: FOR_TO
2125: IFFALSE 2255
// begin uc_direction := Rand ( 2 , 3 ) ;
2127: LD_ADDR_OWVAR 24
2131: PUSH
2132: LD_INT 2
2134: PPUSH
2135: LD_INT 3
2137: PPUSH
2138: CALL_OW 12
2142: ST_TO_ADDR
// un := veh_battle [ Rand ( 1 , veh_battle ) ] ;
2143: LD_ADDR_VAR 0 2
2147: PUSH
2148: LD_VAR 0 12
2152: PUSH
2153: LD_INT 1
2155: PPUSH
2156: LD_VAR 0 12
2160: PPUSH
2161: CALL_OW 12
2165: ARRAY
2166: ST_TO_ADDR
// uc_nation := un [ 1 ] ;
2167: LD_ADDR_OWVAR 21
2171: PUSH
2172: LD_VAR 0 2
2176: PUSH
2177: LD_INT 1
2179: ARRAY
2180: ST_TO_ADDR
// vc_chassis := un [ 2 ] ;
2181: LD_ADDR_OWVAR 37
2185: PUSH
2186: LD_VAR 0 2
2190: PUSH
2191: LD_INT 2
2193: ARRAY
2194: ST_TO_ADDR
// vc_engine := un [ 3 ] ;
2195: LD_ADDR_OWVAR 39
2199: PUSH
2200: LD_VAR 0 2
2204: PUSH
2205: LD_INT 3
2207: ARRAY
2208: ST_TO_ADDR
// vc_control := un [ 4 ] ;
2209: LD_ADDR_OWVAR 38
2213: PUSH
2214: LD_VAR 0 2
2218: PUSH
2219: LD_INT 4
2221: ARRAY
2222: ST_TO_ADDR
// vc_weapon := un [ 5 ] ;
2223: LD_ADDR_OWVAR 40
2227: PUSH
2228: LD_VAR 0 2
2232: PUSH
2233: LD_INT 5
2235: ARRAY
2236: ST_TO_ADDR
// veh_list := veh_list ^ CreateVehicle ;
2237: LD_ADDR_VAR 0 14
2241: PUSH
2242: LD_VAR 0 14
2246: PUSH
2247: CALL_OW 45
2251: ADD
2252: ST_TO_ADDR
// end ;
2253: GO 2124
2255: POP
2256: POP
// pom_list := aliance_forces diff [ MacMillan , Burlak ] ;
2257: LD_ADDR_VAR 0 9
2261: PUSH
2262: LD_EXP 59
2266: PUSH
2267: LD_EXP 13
2271: PUSH
2272: LD_EXP 12
2276: PUSH
2277: EMPTY
2278: LIST
2279: LIST
2280: DIFF
2281: ST_TO_ADDR
// i := 1 ;
2282: LD_ADDR_VAR 0 4
2286: PUSH
2287: LD_INT 1
2289: ST_TO_ADDR
// for un in veh_list do
2290: LD_ADDR_VAR 0 2
2294: PUSH
2295: LD_VAR 0 14
2299: PUSH
2300: FOR_IN
2301: IFFALSE 2402
// begin uc_direction := Rand ( 2 , 3 ) ;
2303: LD_ADDR_OWVAR 24
2307: PUSH
2308: LD_INT 2
2310: PPUSH
2311: LD_INT 3
2313: PPUSH
2314: CALL_OW 12
2318: ST_TO_ADDR
// if GetControl ( un ) = control_manual then
2319: LD_VAR 0 2
2323: PPUSH
2324: CALL_OW 263
2328: PUSH
2329: LD_INT 1
2331: EQUAL
2332: IFFALSE 2385
// begin PlaceHumanInUnit ( pom_list [ i ] , un ) ;
2334: LD_VAR 0 9
2338: PUSH
2339: LD_VAR 0 4
2343: ARRAY
2344: PPUSH
2345: LD_VAR 0 2
2349: PPUSH
2350: CALL_OW 52
// PlaceUnitArea ( un , starting_area , false ) ;
2354: LD_VAR 0 2
2358: PPUSH
2359: LD_INT 7
2361: PPUSH
2362: LD_INT 0
2364: PPUSH
2365: CALL_OW 49
// i := i + 1 ;
2369: LD_ADDR_VAR 0 4
2373: PUSH
2374: LD_VAR 0 4
2378: PUSH
2379: LD_INT 1
2381: PLUS
2382: ST_TO_ADDR
// end else
2383: GO 2400
// PlaceUnitArea ( un , starting_area , false ) ;
2385: LD_VAR 0 2
2389: PPUSH
2390: LD_INT 7
2392: PPUSH
2393: LD_INT 0
2395: PPUSH
2396: CALL_OW 49
// end ;
2400: GO 2300
2402: POP
2403: POP
// ComEnterUnit ( uss_ape , uss ) ;
2404: LD_INT 146
2406: PPUSH
2407: LD_INT 38
2409: PPUSH
2410: CALL_OW 120
// end ;
2414: LD_VAR 0 1
2418: RET
// function prepare_sides ; begin
2419: LD_INT 0
2421: PPUSH
// neutral := 0 ;
2422: LD_ADDR_EXP 6
2426: PUSH
2427: LD_INT 0
2429: ST_TO_ADDR
// you := 7 ;
2430: LD_ADDR_EXP 1
2434: PUSH
2435: LD_INT 7
2437: ST_TO_ADDR
// camp := 6 ;
2438: LD_ADDR_EXP 7
2442: PUSH
2443: LD_INT 6
2445: ST_TO_ADDR
// ru := 3 ;
2446: LD_ADDR_EXP 2
2450: PUSH
2451: LD_INT 3
2453: ST_TO_ADDR
// us := 1 ;
2454: LD_ADDR_EXP 3
2458: PUSH
2459: LD_INT 1
2461: ST_TO_ADDR
// ar := 2 ;
2462: LD_ADDR_EXP 4
2466: PUSH
2467: LD_INT 2
2469: ST_TO_ADDR
// ar_al := 5 ;
2470: LD_ADDR_EXP 5
2474: PUSH
2475: LD_INT 5
2477: ST_TO_ADDR
// cpu_list := [ us , ar , ru ] ;
2478: LD_ADDR_EXP 8
2482: PUSH
2483: LD_EXP 3
2487: PUSH
2488: LD_EXP 4
2492: PUSH
2493: LD_EXP 2
2497: PUSH
2498: EMPTY
2499: LIST
2500: LIST
2501: LIST
2502: ST_TO_ADDR
// ru_nation := nation_russian ;
2503: LD_ADDR_EXP 9
2507: PUSH
2508: LD_INT 3
2510: ST_TO_ADDR
// us_nation := nation_american ;
2511: LD_ADDR_EXP 10
2515: PUSH
2516: LD_INT 1
2518: ST_TO_ADDR
// ar_nation := nation_arabian ;
2519: LD_ADDR_EXP 11
2523: PUSH
2524: LD_INT 2
2526: ST_TO_ADDR
// finalize := 0 ;
2527: LD_ADDR_EXP 60
2531: PUSH
2532: LD_INT 0
2534: ST_TO_ADDR
// siberite_rocket_send := false ;
2535: LD_ADDR_EXP 62
2539: PUSH
2540: LD_INT 0
2542: ST_TO_ADDR
// disable ( 1 ) ;
2543: LD_INT 1
2545: DISABLE_MARKED
// disable ( 2 ) ;
2546: LD_INT 2
2548: DISABLE_MARKED
// disable ( 4 ) ;
2549: LD_INT 4
2551: DISABLE_MARKED
// disable ( 5 ) ;
2552: LD_INT 5
2554: DISABLE_MARKED
// disable ( 24 ) ;
2555: LD_INT 24
2557: DISABLE_MARKED
// disable ( 25 ) ;
2558: LD_INT 25
2560: DISABLE_MARKED
// disable ( 26 ) ;
2561: LD_INT 26
2563: DISABLE_MARKED
// disable ( 222 ) ;
2564: LD_INT 222
2566: DISABLE_MARKED
// disable ( 223 ) ;
2567: LD_INT 223
2569: DISABLE_MARKED
// SetAttitude ( you , ru , att_enemy , true ) ;
2570: LD_EXP 1
2574: PPUSH
2575: LD_EXP 2
2579: PPUSH
2580: LD_INT 2
2582: PPUSH
2583: LD_INT 1
2585: PPUSH
2586: CALL_OW 80
// SetAttitude ( you , us , att_enemy , true ) ;
2590: LD_EXP 1
2594: PPUSH
2595: LD_EXP 3
2599: PPUSH
2600: LD_INT 2
2602: PPUSH
2603: LD_INT 1
2605: PPUSH
2606: CALL_OW 80
// SetAttitude ( you , ar , att_enemy , true ) ;
2610: LD_EXP 1
2614: PPUSH
2615: LD_EXP 4
2619: PPUSH
2620: LD_INT 2
2622: PPUSH
2623: LD_INT 1
2625: PPUSH
2626: CALL_OW 80
// SetAttitude ( you , neutral , att_neutral , true ) ;
2630: LD_EXP 1
2634: PPUSH
2635: LD_EXP 6
2639: PPUSH
2640: LD_INT 0
2642: PPUSH
2643: LD_INT 1
2645: PPUSH
2646: CALL_OW 80
// SetAttitude ( you , ar_al , att_enemy , true ) ;
2650: LD_EXP 1
2654: PPUSH
2655: LD_EXP 5
2659: PPUSH
2660: LD_INT 2
2662: PPUSH
2663: LD_INT 1
2665: PPUSH
2666: CALL_OW 80
// SetAttitude ( ru , us , att_enemy , true ) ;
2670: LD_EXP 2
2674: PPUSH
2675: LD_EXP 3
2679: PPUSH
2680: LD_INT 2
2682: PPUSH
2683: LD_INT 1
2685: PPUSH
2686: CALL_OW 80
// SetAttitude ( ru , ar , att_enemy , true ) ;
2690: LD_EXP 2
2694: PPUSH
2695: LD_EXP 4
2699: PPUSH
2700: LD_INT 2
2702: PPUSH
2703: LD_INT 1
2705: PPUSH
2706: CALL_OW 80
// SetAttitude ( us , ar , att_enemy , true ) ;
2710: LD_EXP 3
2714: PPUSH
2715: LD_EXP 4
2719: PPUSH
2720: LD_INT 2
2722: PPUSH
2723: LD_INT 1
2725: PPUSH
2726: CALL_OW 80
// SetAttitude ( ru , ar_al , att_enemy , true ) ;
2730: LD_EXP 2
2734: PPUSH
2735: LD_EXP 5
2739: PPUSH
2740: LD_INT 2
2742: PPUSH
2743: LD_INT 1
2745: PPUSH
2746: CALL_OW 80
// SetAttitude ( us , ar_al , att_enemy , true ) ;
2750: LD_EXP 3
2754: PPUSH
2755: LD_EXP 5
2759: PPUSH
2760: LD_INT 2
2762: PPUSH
2763: LD_INT 1
2765: PPUSH
2766: CALL_OW 80
// end ;
2770: LD_VAR 0 1
2774: RET
// starting begin RandomizeAll ;
2775: CALL_OW 11
// prepare_sides ;
2779: CALL 2419 0 0
// prepare_us_units ;
2783: CALL 0 0 0
// prepare_ru_units ;
2787: CALL 35 0 0
// prepare_ar_units ;
2791: CALL 70 0 0
// prepare_al_units ;
2795: CALL 249 0 0
// prepare_apemans ;
2799: CALL 7430 0 0
// create_russians ;
2803: CALL 4953 0 0
// create_americans ;
2807: CALL 5653 0 0
// create_arabians ;
2811: CALL 6404 0 0
// init_distribution ;
2815: CALL 26773 0 0
// init_defend ;
2819: CALL 18578 0 0
// init_attack ;
2823: CALL 21191 0 0
// init_keep_base ;
2827: CALL 32646 0 0
// init_research ;
2831: CALL 24370 0 0
// init_manufacture ;
2835: CALL 27120 0 0
// init_crates_loading ;
2839: CALL 33052 0 0
// init_crates_collecting ;
2843: CALL 33789 0 0
// init_alien_research ;
2847: CALL 37313 0 0
// init_sib_rocket ;
2851: CALL 36482 0 0
// starting_scene ;
2855: CALL 7662 0 0
// end ; end_of_file
2859: END
// export function load_all_aliance ; begin
2860: LD_INT 0
2862: PPUSH
// if TestCharacters ( Belkov ) and CheckCharacterSet ( Belkov ) and LoadVariable ( belkov_side , 0 ) > 0 then
2863: LD_STRING Belkov
2865: PPUSH
2866: CALL_OW 28
2870: PUSH
2871: LD_STRING Belkov
2873: PPUSH
2874: CALL_OW 29
2878: AND
2879: PUSH
2880: LD_STRING belkov_side
2882: PPUSH
2883: LD_INT 0
2885: PPUSH
2886: CALL_OW 30
2890: PUSH
2891: LD_INT 0
2893: GREATER
2894: AND
2895: IFFALSE 2926
// begin Belkov := CreateCharacter ( Belkov ) ;
2897: LD_ADDR_EXP 17
2901: PUSH
2902: LD_STRING Belkov
2904: PPUSH
2905: CALL_OW 34
2909: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Belkov ;
2910: LD_ADDR_EXP 59
2914: PUSH
2915: LD_EXP 59
2919: PUSH
2920: LD_EXP 17
2924: ADD
2925: ST_TO_ADDR
// end ; if TestCharacters ( Petrosyan ) and CheckCharacterSet ( Petrosyan ) and LoadVariable ( petros_side , 0 ) > 0 then
2926: LD_STRING Petrosyan
2928: PPUSH
2929: CALL_OW 28
2933: PUSH
2934: LD_STRING Petrosyan
2936: PPUSH
2937: CALL_OW 29
2941: AND
2942: PUSH
2943: LD_STRING petros_side
2945: PPUSH
2946: LD_INT 0
2948: PPUSH
2949: CALL_OW 30
2953: PUSH
2954: LD_INT 0
2956: GREATER
2957: AND
2958: IFFALSE 2989
// begin Petrosyan := CreateCharacter ( Petrosyan ) ;
2960: LD_ADDR_EXP 16
2964: PUSH
2965: LD_STRING Petrosyan
2967: PPUSH
2968: CALL_OW 34
2972: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Petrosyan ;
2973: LD_ADDR_EXP 59
2977: PUSH
2978: LD_EXP 59
2982: PUSH
2983: LD_EXP 16
2987: ADD
2988: ST_TO_ADDR
// end ; if TestCharacters ( Kirilenkova ) and CheckCharacterSet ( Kirilenkova ) and LoadVariable ( kiril_side , 0 ) > 0 then
2989: LD_STRING Kirilenkova
2991: PPUSH
2992: CALL_OW 28
2996: PUSH
2997: LD_STRING Kirilenkova
2999: PPUSH
3000: CALL_OW 29
3004: AND
3005: PUSH
3006: LD_STRING kiril_side
3008: PPUSH
3009: LD_INT 0
3011: PPUSH
3012: CALL_OW 30
3016: PUSH
3017: LD_INT 0
3019: GREATER
3020: AND
3021: IFFALSE 3052
// begin Kirilenkova := CreateCharacter ( Kirilenkova ) ;
3023: LD_ADDR_EXP 18
3027: PUSH
3028: LD_STRING Kirilenkova
3030: PPUSH
3031: CALL_OW 34
3035: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Kirilenkova ;
3036: LD_ADDR_EXP 59
3040: PUSH
3041: LD_EXP 59
3045: PUSH
3046: LD_EXP 18
3050: ADD
3051: ST_TO_ADDR
// end ; if TestCharacters ( Gnyevko ) and CheckCharacterSet ( Gnyevko ) and LoadVariable ( gnyevko_side , 0 ) > 0 then
3052: LD_STRING Gnyevko
3054: PPUSH
3055: CALL_OW 28
3059: PUSH
3060: LD_STRING Gnyevko
3062: PPUSH
3063: CALL_OW 29
3067: AND
3068: PUSH
3069: LD_STRING gnyevko_side
3071: PPUSH
3072: LD_INT 0
3074: PPUSH
3075: CALL_OW 30
3079: PUSH
3080: LD_INT 0
3082: GREATER
3083: AND
3084: IFFALSE 3115
// begin Gnyevko := CreateCharacter ( Gnyevko ) ;
3086: LD_ADDR_EXP 19
3090: PUSH
3091: LD_STRING Gnyevko
3093: PPUSH
3094: CALL_OW 34
3098: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Gnyevko ;
3099: LD_ADDR_EXP 59
3103: PUSH
3104: LD_EXP 59
3108: PUSH
3109: LD_EXP 19
3113: ADD
3114: ST_TO_ADDR
// end ; if TestCharacters ( Dolgov ) and CheckCharacterSet ( Dolgov ) and LoadVariable ( dolgov_side , 0 ) > 0 then
3115: LD_STRING Dolgov
3117: PPUSH
3118: CALL_OW 28
3122: PUSH
3123: LD_STRING Dolgov
3125: PPUSH
3126: CALL_OW 29
3130: AND
3131: PUSH
3132: LD_STRING dolgov_side
3134: PPUSH
3135: LD_INT 0
3137: PPUSH
3138: CALL_OW 30
3142: PUSH
3143: LD_INT 0
3145: GREATER
3146: AND
3147: IFFALSE 3178
// begin Dolgov := CreateCharacter ( Dolgov ) ;
3149: LD_ADDR_EXP 21
3153: PUSH
3154: LD_STRING Dolgov
3156: PPUSH
3157: CALL_OW 34
3161: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Dolgov ;
3162: LD_ADDR_EXP 59
3166: PUSH
3167: LD_EXP 59
3171: PUSH
3172: LD_EXP 21
3176: ADD
3177: ST_TO_ADDR
// end ; if TestCharacters ( Gleb ) and CheckCharacterSet ( Gleb ) and LoadVariable ( gleb_side , 0 ) > 0 then
3178: LD_STRING Gleb
3180: PPUSH
3181: CALL_OW 28
3185: PUSH
3186: LD_STRING Gleb
3188: PPUSH
3189: CALL_OW 29
3193: AND
3194: PUSH
3195: LD_STRING gleb_side
3197: PPUSH
3198: LD_INT 0
3200: PPUSH
3201: CALL_OW 30
3205: PUSH
3206: LD_INT 0
3208: GREATER
3209: AND
3210: IFFALSE 3241
// begin Gleb := CreateCharacter ( Gleb ) ;
3212: LD_ADDR_EXP 22
3216: PUSH
3217: LD_STRING Gleb
3219: PPUSH
3220: CALL_OW 34
3224: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Gleb ;
3225: LD_ADDR_EXP 59
3229: PUSH
3230: LD_EXP 59
3234: PUSH
3235: LD_EXP 22
3239: ADD
3240: ST_TO_ADDR
// end ; if TestCharacters ( Kapitsova ) and CheckCharacterSet ( Kapitsova ) and LoadVariable ( kapitsova_side , 0 ) > 0 then
3241: LD_STRING Kapitsova
3243: PPUSH
3244: CALL_OW 28
3248: PUSH
3249: LD_STRING Kapitsova
3251: PPUSH
3252: CALL_OW 29
3256: AND
3257: PUSH
3258: LD_STRING kapitsova_side
3260: PPUSH
3261: LD_INT 0
3263: PPUSH
3264: CALL_OW 30
3268: PUSH
3269: LD_INT 0
3271: GREATER
3272: AND
3273: IFFALSE 3304
// begin Kapitsova := CreateCharacter ( Kapitsova ) ;
3275: LD_ADDR_EXP 23
3279: PUSH
3280: LD_STRING Kapitsova
3282: PPUSH
3283: CALL_OW 34
3287: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Kapitsova ;
3288: LD_ADDR_EXP 59
3292: PUSH
3293: LD_EXP 59
3297: PUSH
3298: LD_EXP 23
3302: ADD
3303: ST_TO_ADDR
// end ; if TestCharacters ( Kuzmov ) and CheckCharacterSet ( Kuzmov ) and LoadVariable ( kuzmov_side , 0 ) > 0 then
3304: LD_STRING Kuzmov
3306: PPUSH
3307: CALL_OW 28
3311: PUSH
3312: LD_STRING Kuzmov
3314: PPUSH
3315: CALL_OW 29
3319: AND
3320: PUSH
3321: LD_STRING kuzmov_side
3323: PPUSH
3324: LD_INT 0
3326: PPUSH
3327: CALL_OW 30
3331: PUSH
3332: LD_INT 0
3334: GREATER
3335: AND
3336: IFFALSE 3367
// begin Kuzmov := CreateCharacter ( Kuzmov ) ;
3338: LD_ADDR_EXP 24
3342: PUSH
3343: LD_STRING Kuzmov
3345: PPUSH
3346: CALL_OW 34
3350: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Kuzmov ;
3351: LD_ADDR_EXP 59
3355: PUSH
3356: LD_EXP 59
3360: PUSH
3361: LD_EXP 24
3365: ADD
3366: ST_TO_ADDR
// end ; if TestCharacters ( Kovalyuk ) and CheckCharacterSet ( Kovalyuk ) and LoadVariable ( kovalyuk_side , 0 ) > 0 then
3367: LD_STRING Kovalyuk
3369: PPUSH
3370: CALL_OW 28
3374: PUSH
3375: LD_STRING Kovalyuk
3377: PPUSH
3378: CALL_OW 29
3382: AND
3383: PUSH
3384: LD_STRING kovalyuk_side
3386: PPUSH
3387: LD_INT 0
3389: PPUSH
3390: CALL_OW 30
3394: PUSH
3395: LD_INT 0
3397: GREATER
3398: AND
3399: IFFALSE 3430
// begin Kovalyuk := CreateCharacter ( Kovalyuk ) ;
3401: LD_ADDR_EXP 25
3405: PUSH
3406: LD_STRING Kovalyuk
3408: PPUSH
3409: CALL_OW 34
3413: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Kovalyuk ;
3414: LD_ADDR_EXP 59
3418: PUSH
3419: LD_EXP 59
3423: PUSH
3424: LD_EXP 25
3428: ADD
3429: ST_TO_ADDR
// end ; if TestCharacters ( Scholtze ) and CheckCharacterSet ( Scholtze ) and LoadVariable ( scholtze_side , 0 ) > 0 then
3430: LD_STRING Scholtze
3432: PPUSH
3433: CALL_OW 28
3437: PUSH
3438: LD_STRING Scholtze
3440: PPUSH
3441: CALL_OW 29
3445: AND
3446: PUSH
3447: LD_STRING scholtze_side
3449: PPUSH
3450: LD_INT 0
3452: PPUSH
3453: CALL_OW 30
3457: PUSH
3458: LD_INT 0
3460: GREATER
3461: AND
3462: IFFALSE 3493
// begin Scholtze := CreateCharacter ( Scholtze ) ;
3464: LD_ADDR_EXP 26
3468: PUSH
3469: LD_STRING Scholtze
3471: PPUSH
3472: CALL_OW 34
3476: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Scholtze ;
3477: LD_ADDR_EXP 59
3481: PUSH
3482: LD_EXP 59
3486: PUSH
3487: LD_EXP 26
3491: ADD
3492: ST_TO_ADDR
// end ; if TestCharacters ( Karamazov ) and CheckCharacterSet ( Karamazov ) and LoadVariable ( karam_side , 0 ) > 0 then
3493: LD_STRING Karamazov
3495: PPUSH
3496: CALL_OW 28
3500: PUSH
3501: LD_STRING Karamazov
3503: PPUSH
3504: CALL_OW 29
3508: AND
3509: PUSH
3510: LD_STRING karam_side
3512: PPUSH
3513: LD_INT 0
3515: PPUSH
3516: CALL_OW 30
3520: PUSH
3521: LD_INT 0
3523: GREATER
3524: AND
3525: IFFALSE 3556
// begin Karamazov := CreateCharacter ( Karamazov ) ;
3527: LD_ADDR_EXP 27
3531: PUSH
3532: LD_STRING Karamazov
3534: PPUSH
3535: CALL_OW 34
3539: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Karamazov ;
3540: LD_ADDR_EXP 59
3544: PUSH
3545: LD_EXP 59
3549: PUSH
3550: LD_EXP 27
3554: ADD
3555: ST_TO_ADDR
// end ; if TestCharacters ( Titov ) and CheckCharacterSet ( Titov ) and LoadVariable ( titov_side , 0 ) > 0 then
3556: LD_STRING Titov
3558: PPUSH
3559: CALL_OW 28
3563: PUSH
3564: LD_STRING Titov
3566: PPUSH
3567: CALL_OW 29
3571: AND
3572: PUSH
3573: LD_STRING titov_side
3575: PPUSH
3576: LD_INT 0
3578: PPUSH
3579: CALL_OW 30
3583: PUSH
3584: LD_INT 0
3586: GREATER
3587: AND
3588: IFFALSE 3619
// begin Titov := CreateCharacter ( Titov ) ;
3590: LD_ADDR_EXP 28
3594: PUSH
3595: LD_STRING Titov
3597: PPUSH
3598: CALL_OW 34
3602: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Titov ;
3603: LD_ADDR_EXP 59
3607: PUSH
3608: LD_EXP 59
3612: PUSH
3613: LD_EXP 28
3617: ADD
3618: ST_TO_ADDR
// end ; if TestCharacters ( Oblukov ) and CheckCharacterSet ( Oblukov ) and LoadVariable ( oblukov_side , 0 ) > 0 then
3619: LD_STRING Oblukov
3621: PPUSH
3622: CALL_OW 28
3626: PUSH
3627: LD_STRING Oblukov
3629: PPUSH
3630: CALL_OW 29
3634: AND
3635: PUSH
3636: LD_STRING oblukov_side
3638: PPUSH
3639: LD_INT 0
3641: PPUSH
3642: CALL_OW 30
3646: PUSH
3647: LD_INT 0
3649: GREATER
3650: AND
3651: IFFALSE 3682
// begin Oblukov := CreateCharacter ( Oblukov ) ;
3653: LD_ADDR_EXP 29
3657: PUSH
3658: LD_STRING Oblukov
3660: PPUSH
3661: CALL_OW 34
3665: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Oblukov ;
3666: LD_ADDR_EXP 59
3670: PUSH
3671: LD_EXP 59
3675: PUSH
3676: LD_EXP 29
3680: ADD
3681: ST_TO_ADDR
// end ; if TestCharacters ( Kozlov ) and CheckCharacterSet ( Kozlov ) and LoadVariable ( kozlov_side , 0 ) > 0 then
3682: LD_STRING Kozlov
3684: PPUSH
3685: CALL_OW 28
3689: PUSH
3690: LD_STRING Kozlov
3692: PPUSH
3693: CALL_OW 29
3697: AND
3698: PUSH
3699: LD_STRING kozlov_side
3701: PPUSH
3702: LD_INT 0
3704: PPUSH
3705: CALL_OW 30
3709: PUSH
3710: LD_INT 0
3712: GREATER
3713: AND
3714: IFFALSE 3745
// begin Kozlov := CreateCharacter ( Kozlov ) ;
3716: LD_ADDR_EXP 30
3720: PUSH
3721: LD_STRING Kozlov
3723: PPUSH
3724: CALL_OW 34
3728: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Kozlov ;
3729: LD_ADDR_EXP 59
3733: PUSH
3734: LD_EXP 59
3738: PUSH
3739: LD_EXP 30
3743: ADD
3744: ST_TO_ADDR
// end ; if TestCharacters ( Petrovova ) and CheckCharacterSet ( Petrovova ) and LoadVariable ( petrov_side , 0 ) > 0 then
3745: LD_STRING Petrovova
3747: PPUSH
3748: CALL_OW 28
3752: PUSH
3753: LD_STRING Petrovova
3755: PPUSH
3756: CALL_OW 29
3760: AND
3761: PUSH
3762: LD_STRING petrov_side
3764: PPUSH
3765: LD_INT 0
3767: PPUSH
3768: CALL_OW 30
3772: PUSH
3773: LD_INT 0
3775: GREATER
3776: AND
3777: IFFALSE 3808
// begin Petrovova := CreateCharacter ( Petrovova ) ;
3779: LD_ADDR_EXP 31
3783: PUSH
3784: LD_STRING Petrovova
3786: PPUSH
3787: CALL_OW 34
3791: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Petrovova ;
3792: LD_ADDR_EXP 59
3796: PUSH
3797: LD_EXP 59
3801: PUSH
3802: LD_EXP 31
3806: ADD
3807: ST_TO_ADDR
// end ; if TestCharacters ( Xavier ) and CheckCharacterSet ( Xavier ) and LoadVariable ( xavier_side , 0 ) > 0 then
3808: LD_STRING Xavier
3810: PPUSH
3811: CALL_OW 28
3815: PUSH
3816: LD_STRING Xavier
3818: PPUSH
3819: CALL_OW 29
3823: AND
3824: PUSH
3825: LD_STRING xavier_side
3827: PPUSH
3828: LD_INT 0
3830: PPUSH
3831: CALL_OW 30
3835: PUSH
3836: LD_INT 0
3838: GREATER
3839: AND
3840: IFFALSE 3871
// begin Xavier := CreateCharacter ( Xavier ) ;
3842: LD_ADDR_EXP 35
3846: PUSH
3847: LD_STRING Xavier
3849: PPUSH
3850: CALL_OW 34
3854: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Xavier ;
3855: LD_ADDR_EXP 59
3859: PUSH
3860: LD_EXP 59
3864: PUSH
3865: LD_EXP 35
3869: ADD
3870: ST_TO_ADDR
// end ; if TestCharacters ( Lipshchin ) and CheckCharacterSet ( Lipshchin ) and LoadVariable ( lipshchin_side , 0 ) > 0 then
3871: LD_STRING Lipshchin
3873: PPUSH
3874: CALL_OW 28
3878: PUSH
3879: LD_STRING Lipshchin
3881: PPUSH
3882: CALL_OW 29
3886: AND
3887: PUSH
3888: LD_STRING lipshchin_side
3890: PPUSH
3891: LD_INT 0
3893: PPUSH
3894: CALL_OW 30
3898: PUSH
3899: LD_INT 0
3901: GREATER
3902: AND
3903: IFFALSE 3934
// begin Lipshchin := CreateCharacter ( Lipshchin ) ;
3905: LD_ADDR_EXP 33
3909: PUSH
3910: LD_STRING Lipshchin
3912: PPUSH
3913: CALL_OW 34
3917: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Lipshchin ;
3918: LD_ADDR_EXP 59
3922: PUSH
3923: LD_EXP 59
3927: PUSH
3928: LD_EXP 33
3932: ADD
3933: ST_TO_ADDR
// end ; if TestCharacters ( Bobby ) and CheckCharacterSet ( Bobby ) then
3934: LD_STRING Bobby
3936: PPUSH
3937: CALL_OW 28
3941: PUSH
3942: LD_STRING Bobby
3944: PPUSH
3945: CALL_OW 29
3949: AND
3950: IFFALSE 3981
// begin Bobby := CreateCharacter ( Bobby ) ;
3952: LD_ADDR_EXP 37
3956: PUSH
3957: LD_STRING Bobby
3959: PPUSH
3960: CALL_OW 34
3964: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Bobby ;
3965: LD_ADDR_EXP 59
3969: PUSH
3970: LD_EXP 59
3974: PUSH
3975: LD_EXP 37
3979: ADD
3980: ST_TO_ADDR
// end ; if TestCharacters ( Brown ) and CheckCharacterSet ( Brown ) then
3981: LD_STRING Brown
3983: PPUSH
3984: CALL_OW 28
3988: PUSH
3989: LD_STRING Brown
3991: PPUSH
3992: CALL_OW 29
3996: AND
3997: IFFALSE 4028
// begin Brown := CreateCharacter ( Brown ) ;
3999: LD_ADDR_EXP 38
4003: PUSH
4004: LD_STRING Brown
4006: PPUSH
4007: CALL_OW 34
4011: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Brown ;
4012: LD_ADDR_EXP 59
4016: PUSH
4017: LD_EXP 59
4021: PUSH
4022: LD_EXP 38
4026: ADD
4027: ST_TO_ADDR
// end ; if TestCharacters ( Cornell ) and CheckCharacterSet ( Cornell ) then
4028: LD_STRING Cornell
4030: PPUSH
4031: CALL_OW 28
4035: PUSH
4036: LD_STRING Cornell
4038: PPUSH
4039: CALL_OW 29
4043: AND
4044: IFFALSE 4075
// begin Cornell := CreateCharacter ( Cornell ) ;
4046: LD_ADDR_EXP 39
4050: PUSH
4051: LD_STRING Cornell
4053: PPUSH
4054: CALL_OW 34
4058: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Cornell ;
4059: LD_ADDR_EXP 59
4063: PUSH
4064: LD_EXP 59
4068: PUSH
4069: LD_EXP 39
4073: ADD
4074: ST_TO_ADDR
// end ; if TestCharacters ( Connie ) and CheckCharacterSet ( Connie ) then
4075: LD_STRING Connie
4077: PPUSH
4078: CALL_OW 28
4082: PUSH
4083: LD_STRING Connie
4085: PPUSH
4086: CALL_OW 29
4090: AND
4091: IFFALSE 4122
// begin Connie := CreateCharacter ( Connie ) ;
4093: LD_ADDR_EXP 40
4097: PUSH
4098: LD_STRING Connie
4100: PPUSH
4101: CALL_OW 34
4105: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Connie ;
4106: LD_ADDR_EXP 59
4110: PUSH
4111: LD_EXP 59
4115: PUSH
4116: LD_EXP 40
4120: ADD
4121: ST_TO_ADDR
// end ; if TestCharacters ( Cyrus ) and CheckCharacterSet ( Cyrus ) then
4122: LD_STRING Cyrus
4124: PPUSH
4125: CALL_OW 28
4129: PUSH
4130: LD_STRING Cyrus
4132: PPUSH
4133: CALL_OW 29
4137: AND
4138: IFFALSE 4169
// begin Cyrus := CreateCharacter ( Cyrus ) ;
4140: LD_ADDR_EXP 41
4144: PUSH
4145: LD_STRING Cyrus
4147: PPUSH
4148: CALL_OW 34
4152: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Cyrus ;
4153: LD_ADDR_EXP 59
4157: PUSH
4158: LD_EXP 59
4162: PUSH
4163: LD_EXP 41
4167: ADD
4168: ST_TO_ADDR
// end ; if TestCharacters ( Denis ) and CheckCharacterSet ( Denis ) then
4169: LD_STRING Denis
4171: PPUSH
4172: CALL_OW 28
4176: PUSH
4177: LD_STRING Denis
4179: PPUSH
4180: CALL_OW 29
4184: AND
4185: IFFALSE 4216
// begin Denis := CreateCharacter ( Denis ) ;
4187: LD_ADDR_EXP 42
4191: PUSH
4192: LD_STRING Denis
4194: PPUSH
4195: CALL_OW 34
4199: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Denis ;
4200: LD_ADDR_EXP 59
4204: PUSH
4205: LD_EXP 59
4209: PUSH
4210: LD_EXP 42
4214: ADD
4215: ST_TO_ADDR
// end ; if TestCharacters ( Donaldson ) and CheckCharacterSet ( Donaldson ) then
4216: LD_STRING Donaldson
4218: PPUSH
4219: CALL_OW 28
4223: PUSH
4224: LD_STRING Donaldson
4226: PPUSH
4227: CALL_OW 29
4231: AND
4232: IFFALSE 4263
// begin Donaldson := CreateCharacter ( Donaldson ) ;
4234: LD_ADDR_EXP 43
4238: PUSH
4239: LD_STRING Donaldson
4241: PPUSH
4242: CALL_OW 34
4246: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Donaldson ;
4247: LD_ADDR_EXP 59
4251: PUSH
4252: LD_EXP 59
4256: PUSH
4257: LD_EXP 43
4261: ADD
4262: ST_TO_ADDR
// end ; if TestCharacters ( Frank ) and CheckCharacterSet ( Frank ) then
4263: LD_STRING Frank
4265: PPUSH
4266: CALL_OW 28
4270: PUSH
4271: LD_STRING Frank
4273: PPUSH
4274: CALL_OW 29
4278: AND
4279: IFFALSE 4310
// begin Frank := CreateCharacter ( Frank ) ;
4281: LD_ADDR_EXP 44
4285: PUSH
4286: LD_STRING Frank
4288: PPUSH
4289: CALL_OW 34
4293: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Frank ;
4294: LD_ADDR_EXP 59
4298: PUSH
4299: LD_EXP 59
4303: PUSH
4304: LD_EXP 44
4308: ADD
4309: ST_TO_ADDR
// end ; if TestCharacters ( Gary ) and CheckCharacterSet ( Gary ) then
4310: LD_STRING Gary
4312: PPUSH
4313: CALL_OW 28
4317: PUSH
4318: LD_STRING Gary
4320: PPUSH
4321: CALL_OW 29
4325: AND
4326: IFFALSE 4357
// begin Gary := CreateCharacter ( Gary ) ;
4328: LD_ADDR_EXP 45
4332: PUSH
4333: LD_STRING Gary
4335: PPUSH
4336: CALL_OW 34
4340: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Gary ;
4341: LD_ADDR_EXP 59
4345: PUSH
4346: LD_EXP 59
4350: PUSH
4351: LD_EXP 45
4355: ADD
4356: ST_TO_ADDR
// end ; if TestCharacters ( Gladstone ) and CheckCharacterSet ( Gladstone ) then
4357: LD_STRING Gladstone
4359: PPUSH
4360: CALL_OW 28
4364: PUSH
4365: LD_STRING Gladstone
4367: PPUSH
4368: CALL_OW 29
4372: AND
4373: IFFALSE 4404
// begin Gladstone := CreateCharacter ( Gladstone ) ;
4375: LD_ADDR_EXP 46
4379: PUSH
4380: LD_STRING Gladstone
4382: PPUSH
4383: CALL_OW 34
4387: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Gladstone ;
4388: LD_ADDR_EXP 59
4392: PUSH
4393: LD_EXP 59
4397: PUSH
4398: LD_EXP 46
4402: ADD
4403: ST_TO_ADDR
// end ; if TestCharacters ( Joan ) and CheckCharacterSet ( Joan ) and camp = 4 then
4404: LD_STRING Joan
4406: PPUSH
4407: CALL_OW 28
4411: PUSH
4412: LD_STRING Joan
4414: PPUSH
4415: CALL_OW 29
4419: AND
4420: PUSH
4421: LD_EXP 7
4425: PUSH
4426: LD_INT 4
4428: EQUAL
4429: AND
4430: IFFALSE 4461
// begin Joan := CreateCharacter ( Joan ) ;
4432: LD_ADDR_EXP 47
4436: PUSH
4437: LD_STRING Joan
4439: PPUSH
4440: CALL_OW 34
4444: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Joan ;
4445: LD_ADDR_EXP 59
4449: PUSH
4450: LD_EXP 59
4454: PUSH
4455: LD_EXP 47
4459: ADD
4460: ST_TO_ADDR
// end ; if TestCharacters ( Lisa ) and CheckCharacterSet ( Lisa ) then
4461: LD_STRING Lisa
4463: PPUSH
4464: CALL_OW 28
4468: PUSH
4469: LD_STRING Lisa
4471: PPUSH
4472: CALL_OW 29
4476: AND
4477: IFFALSE 4508
// begin Lisa := CreateCharacter ( Lisa ) ;
4479: LD_ADDR_EXP 48
4483: PUSH
4484: LD_STRING Lisa
4486: PPUSH
4487: CALL_OW 34
4491: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Lisa ;
4492: LD_ADDR_EXP 59
4496: PUSH
4497: LD_EXP 59
4501: PUSH
4502: LD_EXP 48
4506: ADD
4507: ST_TO_ADDR
// end ; if TestCharacters ( Peterson ) and CheckCharacterSet ( Peterson ) then
4508: LD_STRING Peterson
4510: PPUSH
4511: CALL_OW 28
4515: PUSH
4516: LD_STRING Peterson
4518: PPUSH
4519: CALL_OW 29
4523: AND
4524: IFFALSE 4555
// begin Peterson := CreateCharacter ( Peterson ) ;
4526: LD_ADDR_EXP 49
4530: PUSH
4531: LD_STRING Peterson
4533: PPUSH
4534: CALL_OW 34
4538: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Peterson ;
4539: LD_ADDR_EXP 59
4543: PUSH
4544: LD_EXP 59
4548: PUSH
4549: LD_EXP 49
4553: ADD
4554: ST_TO_ADDR
// end ; if TestCharacters ( Simms ) and CheckCharacterSet ( Simms ) then
4555: LD_STRING Simms
4557: PPUSH
4558: CALL_OW 28
4562: PUSH
4563: LD_STRING Simms
4565: PPUSH
4566: CALL_OW 29
4570: AND
4571: IFFALSE 4602
// begin Simms := CreateCharacter ( Simms ) ;
4573: LD_ADDR_EXP 50
4577: PUSH
4578: LD_STRING Simms
4580: PPUSH
4581: CALL_OW 34
4585: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Simms ;
4586: LD_ADDR_EXP 59
4590: PUSH
4591: LD_EXP 59
4595: PUSH
4596: LD_EXP 50
4600: ADD
4601: ST_TO_ADDR
// end ; if TestCharacters ( VanHouten ) and CheckCharacterSet ( VanHouten ) then
4602: LD_STRING VanHouten
4604: PPUSH
4605: CALL_OW 28
4609: PUSH
4610: LD_STRING VanHouten
4612: PPUSH
4613: CALL_OW 29
4617: AND
4618: IFFALSE 4649
// begin VanHouten := CreateCharacter ( VanHouten ) ;
4620: LD_ADDR_EXP 51
4624: PUSH
4625: LD_STRING VanHouten
4627: PPUSH
4628: CALL_OW 34
4632: ST_TO_ADDR
// aliance_forces := aliance_forces ^ VanHouten ;
4633: LD_ADDR_EXP 59
4637: PUSH
4638: LD_EXP 59
4642: PUSH
4643: LD_EXP 51
4647: ADD
4648: ST_TO_ADDR
// end ; if TestCharacters ( Yamoko ) and CheckCharacterSet ( Yamoko ) then
4649: LD_STRING Yamoko
4651: PPUSH
4652: CALL_OW 28
4656: PUSH
4657: LD_STRING Yamoko
4659: PPUSH
4660: CALL_OW 29
4664: AND
4665: IFFALSE 4696
// begin Yamoko := CreateCharacter ( Yamoko ) ;
4667: LD_ADDR_EXP 52
4671: PUSH
4672: LD_STRING Yamoko
4674: PPUSH
4675: CALL_OW 34
4679: ST_TO_ADDR
// aliance_forces := aliance_forces ^ Yamoko ;
4680: LD_ADDR_EXP 59
4684: PUSH
4685: LD_EXP 59
4689: PUSH
4690: LD_EXP 52
4694: ADD
4695: ST_TO_ADDR
// end ; if CheckCharacterSet ( survivors5 ) then
4696: LD_STRING survivors5
4698: PPUSH
4699: CALL_OW 29
4703: IFFALSE 4734
// begin survivors5 = CreateCharacterSet ( survivors5 ) ;
4705: LD_ADDR_EXP 36
4709: PUSH
4710: LD_STRING survivors5
4712: PPUSH
4713: CALL_OW 31
4717: ST_TO_ADDR
// aliance_forces := aliance_forces ^ survivors5 ;
4718: LD_ADDR_EXP 59
4722: PUSH
4723: LD_EXP 59
4727: PUSH
4728: LD_EXP 36
4732: ADD
4733: ST_TO_ADDR
// end ; DisableAllBazookers ;
4734: CALL 4866 0 0
// if camp = 4 then
4738: LD_EXP 7
4742: PUSH
4743: LD_INT 4
4745: EQUAL
4746: IFFALSE 4752
// sort_aliance_by_the_nation ;
4748: CALL 4757 0 0
// end ;
4752: LD_VAR 0 1
4756: RET
// function sort_aliance_by_the_nation ; var un , us_list , ru_list ; begin
4757: LD_INT 0
4759: PPUSH
4760: PPUSH
4761: PPUSH
4762: PPUSH
// us_list := [ ] ;
4763: LD_ADDR_VAR 0 3
4767: PUSH
4768: EMPTY
4769: ST_TO_ADDR
// ru_list := [ ] ;
4770: LD_ADDR_VAR 0 4
4774: PUSH
4775: EMPTY
4776: ST_TO_ADDR
// for un in aliance_forces do
4777: LD_ADDR_VAR 0 2
4781: PUSH
4782: LD_EXP 59
4786: PUSH
4787: FOR_IN
4788: IFFALSE 4843
// if GetNation ( un ) = us then
4790: LD_VAR 0 2
4794: PPUSH
4795: CALL_OW 248
4799: PUSH
4800: LD_EXP 3
4804: EQUAL
4805: IFFALSE 4825
// us_list := us_list ^ un else
4807: LD_ADDR_VAR 0 3
4811: PUSH
4812: LD_VAR 0 3
4816: PUSH
4817: LD_VAR 0 2
4821: ADD
4822: ST_TO_ADDR
4823: GO 4841
// ru_list := ru_list ^ un ;
4825: LD_ADDR_VAR 0 4
4829: PUSH
4830: LD_VAR 0 4
4834: PUSH
4835: LD_VAR 0 2
4839: ADD
4840: ST_TO_ADDR
4841: GO 4787
4843: POP
4844: POP
// aliance_forces := us_list ^ ru_list ;
4845: LD_ADDR_EXP 59
4849: PUSH
4850: LD_VAR 0 3
4854: PUSH
4855: LD_VAR 0 4
4859: ADD
4860: ST_TO_ADDR
// end ;
4861: LD_VAR 0 1
4865: RET
// function DisableAllBazookers ; var list , un ; begin
4866: LD_INT 0
4868: PPUSH
4869: PPUSH
4870: PPUSH
// list := [ ] ;
4871: LD_ADDR_VAR 0 2
4875: PUSH
4876: EMPTY
4877: ST_TO_ADDR
// for un in aliance_forces do
4878: LD_ADDR_VAR 0 3
4882: PUSH
4883: LD_EXP 59
4887: PUSH
4888: FOR_IN
4889: IFFALSE 4936
// begin if GetClass ( un ) = class_bazooker then
4891: LD_VAR 0 3
4895: PPUSH
4896: CALL_OW 257
4900: PUSH
4901: LD_INT 9
4903: EQUAL
4904: IFFALSE 4918
// SetClass ( un , class_soldier ) ;
4906: LD_VAR 0 3
4910: PPUSH
4911: LD_INT 1
4913: PPUSH
4914: CALL_OW 336
// list := list ^ un ;
4918: LD_ADDR_VAR 0 2
4922: PUSH
4923: LD_VAR 0 2
4927: PUSH
4928: LD_VAR 0 3
4932: ADD
4933: ST_TO_ADDR
// end ;
4934: GO 4888
4936: POP
4937: POP
// aliance_forces := list ;
4938: LD_ADDR_EXP 59
4942: PUSH
4943: LD_VAR 0 2
4947: ST_TO_ADDR
// end ; end_of_file
4948: LD_VAR 0 1
4952: RET
// var cpu_side , cpu_nation , cpu_base ; export function create_russians ; var un , class_list , members ; begin
4953: LD_INT 0
4955: PPUSH
4956: PPUSH
4957: PPUSH
4958: PPUSH
// cpu_side := ru ;
4959: LD_ADDR_LOC 1
4963: PUSH
4964: LD_EXP 2
4968: ST_TO_ADDR
// cpu_nation := nation_russian ;
4969: LD_ADDR_LOC 2
4973: PUSH
4974: LD_INT 3
4976: ST_TO_ADDR
// cpu_base := ru_create ;
4977: LD_ADDR_LOC 3
4981: PUSH
4982: LD_INT 17
4984: ST_TO_ADDR
// members := difficulty * 2 ;
4985: LD_ADDR_VAR 0 4
4989: PUSH
4990: LD_OWVAR 67
4994: PUSH
4995: LD_INT 2
4997: MUL
4998: ST_TO_ADDR
// class_list := [ class_soldier , class_mechanic , class_scientistic , class_engineer ] ;
4999: LD_ADDR_VAR 0 3
5003: PUSH
5004: LD_INT 1
5006: PUSH
5007: LD_INT 3
5009: PUSH
5010: LD_INT 4
5012: PUSH
5013: LD_INT 2
5015: PUSH
5016: EMPTY
5017: LIST
5018: LIST
5019: LIST
5020: LIST
5021: ST_TO_ADDR
// for un in class_list do
5022: LD_ADDR_VAR 0 2
5026: PUSH
5027: LD_VAR 0 3
5031: PUSH
5032: FOR_IN
5033: IFFALSE 5066
// create_units ( cpu_side , cpu_nation , un , members , cpu_base ) ;
5035: LD_LOC 1
5039: PPUSH
5040: LD_LOC 2
5044: PPUSH
5045: LD_VAR 0 2
5049: PPUSH
5050: LD_VAR 0 4
5054: PPUSH
5055: LD_LOC 3
5059: PPUSH
5060: CALL 7104 0 5
5064: GO 5032
5066: POP
5067: POP
// place_all_soldiers ;
5068: CALL 5085 0 0
// place_all_scientistics ;
5072: CALL 5293 0 0
// place_all_mechanics ;
5076: CALL 5482 0 0
// end ;
5080: LD_VAR 0 1
5084: RET
// function place_all_soldiers ; var un , i , max , units , buildings ; begin
5085: LD_INT 0
5087: PPUSH
5088: PPUSH
5089: PPUSH
5090: PPUSH
5091: PPUSH
5092: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_btype , b_bunker ] ] ) ;
5093: LD_ADDR_VAR 0 6
5097: PUSH
5098: LD_INT 22
5100: PUSH
5101: LD_LOC 1
5105: PUSH
5106: EMPTY
5107: LIST
5108: LIST
5109: PUSH
5110: LD_INT 30
5112: PUSH
5113: LD_INT 32
5115: PUSH
5116: EMPTY
5117: LIST
5118: LIST
5119: PUSH
5120: EMPTY
5121: LIST
5122: LIST
5123: PPUSH
5124: CALL_OW 69
5128: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_soldier ] ] ) ;
5129: LD_ADDR_VAR 0 5
5133: PUSH
5134: LD_INT 22
5136: PUSH
5137: LD_LOC 1
5141: PUSH
5142: EMPTY
5143: LIST
5144: LIST
5145: PUSH
5146: LD_INT 25
5148: PUSH
5149: LD_INT 1
5151: PUSH
5152: EMPTY
5153: LIST
5154: LIST
5155: PUSH
5156: EMPTY
5157: LIST
5158: LIST
5159: PPUSH
5160: CALL_OW 69
5164: ST_TO_ADDR
// if buildings >= units then
5165: LD_VAR 0 6
5169: PUSH
5170: LD_VAR 0 5
5174: GREATEREQUAL
5175: IFFALSE 5193
// max := 0 + units else
5177: LD_ADDR_VAR 0 4
5181: PUSH
5182: LD_INT 0
5184: PUSH
5185: LD_VAR 0 5
5189: PLUS
5190: ST_TO_ADDR
5191: GO 5207
// max := 0 + buildings ;
5193: LD_ADDR_VAR 0 4
5197: PUSH
5198: LD_INT 0
5200: PUSH
5201: LD_VAR 0 6
5205: PLUS
5206: ST_TO_ADDR
// i = 1 ;
5207: LD_ADDR_VAR 0 3
5211: PUSH
5212: LD_INT 1
5214: ST_TO_ADDR
// for un in units do
5215: LD_ADDR_VAR 0 2
5219: PUSH
5220: LD_VAR 0 5
5224: PUSH
5225: FOR_IN
5226: IFFALSE 5286
// begin if i <= max then
5228: LD_VAR 0 3
5232: PUSH
5233: LD_VAR 0 4
5237: LESSEQUAL
5238: IFFALSE 5270
// ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
5240: LD_VAR 0 2
5244: PPUSH
5245: LD_VAR 0 6
5249: PUSH
5250: LD_VAR 0 3
5254: PUSH
5255: LD_VAR 0 6
5259: MOD
5260: PUSH
5261: LD_INT 1
5263: PLUS
5264: ARRAY
5265: PPUSH
5266: CALL_OW 120
// i := i + 1 ;
5270: LD_ADDR_VAR 0 3
5274: PUSH
5275: LD_VAR 0 3
5279: PUSH
5280: LD_INT 1
5282: PLUS
5283: ST_TO_ADDR
// end ;
5284: GO 5225
5286: POP
5287: POP
// end ;
5288: LD_VAR 0 1
5292: RET
// function place_all_scientistics ; var un , i , units , buildings ; begin
5293: LD_INT 0
5295: PPUSH
5296: PPUSH
5297: PPUSH
5298: PPUSH
5299: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab ] ] ] ) ;
5300: LD_ADDR_VAR 0 5
5304: PUSH
5305: LD_INT 22
5307: PUSH
5308: LD_LOC 1
5312: PUSH
5313: EMPTY
5314: LIST
5315: LIST
5316: PUSH
5317: LD_INT 2
5319: PUSH
5320: LD_INT 30
5322: PUSH
5323: LD_INT 8
5325: PUSH
5326: EMPTY
5327: LIST
5328: LIST
5329: PUSH
5330: LD_INT 30
5332: PUSH
5333: LD_INT 6
5335: PUSH
5336: EMPTY
5337: LIST
5338: LIST
5339: PUSH
5340: EMPTY
5341: LIST
5342: LIST
5343: LIST
5344: PUSH
5345: EMPTY
5346: LIST
5347: LIST
5348: PPUSH
5349: CALL_OW 69
5353: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_scientistic ] ] ) ;
5354: LD_ADDR_VAR 0 4
5358: PUSH
5359: LD_INT 22
5361: PUSH
5362: LD_LOC 1
5366: PUSH
5367: EMPTY
5368: LIST
5369: LIST
5370: PUSH
5371: LD_INT 25
5373: PUSH
5374: LD_INT 4
5376: PUSH
5377: EMPTY
5378: LIST
5379: LIST
5380: PUSH
5381: EMPTY
5382: LIST
5383: LIST
5384: PPUSH
5385: CALL_OW 69
5389: ST_TO_ADDR
// i = 1 ;
5390: LD_ADDR_VAR 0 3
5394: PUSH
5395: LD_INT 1
5397: ST_TO_ADDR
// for un in units do
5398: LD_ADDR_VAR 0 2
5402: PUSH
5403: LD_VAR 0 4
5407: PUSH
5408: FOR_IN
5409: IFFALSE 5475
// begin ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
5411: LD_VAR 0 2
5415: PPUSH
5416: LD_VAR 0 5
5420: PUSH
5421: LD_VAR 0 3
5425: PUSH
5426: LD_VAR 0 5
5430: MOD
5431: PUSH
5432: LD_INT 1
5434: PLUS
5435: ARRAY
5436: PPUSH
5437: CALL_OW 120
// i := i + 1 ;
5441: LD_ADDR_VAR 0 3
5445: PUSH
5446: LD_VAR 0 3
5450: PUSH
5451: LD_INT 1
5453: PLUS
5454: ST_TO_ADDR
// if i > ( units div 2 ) then
5455: LD_VAR 0 3
5459: PUSH
5460: LD_VAR 0 4
5464: PUSH
5465: LD_INT 2
5467: DIV
5468: GREATER
5469: IFFALSE 5473
// break ;
5471: GO 5475
// end ;
5473: GO 5408
5475: POP
5476: POP
// end ;
5477: LD_VAR 0 1
5481: RET
// function place_all_mechanics ; var un , i , units , buildings ; begin
5482: LD_INT 0
5484: PPUSH
5485: PPUSH
5486: PPUSH
5487: PPUSH
5488: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ;
5489: LD_ADDR_VAR 0 5
5493: PUSH
5494: LD_INT 22
5496: PUSH
5497: LD_LOC 1
5501: PUSH
5502: EMPTY
5503: LIST
5504: LIST
5505: PUSH
5506: LD_INT 2
5508: PUSH
5509: LD_INT 30
5511: PUSH
5512: LD_INT 2
5514: PUSH
5515: EMPTY
5516: LIST
5517: LIST
5518: PUSH
5519: LD_INT 30
5521: PUSH
5522: LD_INT 3
5524: PUSH
5525: EMPTY
5526: LIST
5527: LIST
5528: PUSH
5529: EMPTY
5530: LIST
5531: LIST
5532: LIST
5533: PUSH
5534: EMPTY
5535: LIST
5536: LIST
5537: PPUSH
5538: CALL_OW 69
5542: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_mechanic ] ] ) ;
5543: LD_ADDR_VAR 0 4
5547: PUSH
5548: LD_INT 22
5550: PUSH
5551: LD_LOC 1
5555: PUSH
5556: EMPTY
5557: LIST
5558: LIST
5559: PUSH
5560: LD_INT 25
5562: PUSH
5563: LD_INT 3
5565: PUSH
5566: EMPTY
5567: LIST
5568: LIST
5569: PUSH
5570: EMPTY
5571: LIST
5572: LIST
5573: PPUSH
5574: CALL_OW 69
5578: ST_TO_ADDR
// i = 1 ;
5579: LD_ADDR_VAR 0 3
5583: PUSH
5584: LD_INT 1
5586: ST_TO_ADDR
// for un in units do
5587: LD_ADDR_VAR 0 2
5591: PUSH
5592: LD_VAR 0 4
5596: PUSH
5597: FOR_IN
5598: IFFALSE 5646
// begin ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
5600: LD_VAR 0 2
5604: PPUSH
5605: LD_VAR 0 5
5609: PUSH
5610: LD_VAR 0 3
5614: PUSH
5615: LD_VAR 0 5
5619: MOD
5620: PUSH
5621: LD_INT 1
5623: PLUS
5624: ARRAY
5625: PPUSH
5626: CALL_OW 120
// i := i + 1 ;
5630: LD_ADDR_VAR 0 3
5634: PUSH
5635: LD_VAR 0 3
5639: PUSH
5640: LD_INT 1
5642: PLUS
5643: ST_TO_ADDR
// end ;
5644: GO 5597
5646: POP
5647: POP
// end ; end_of_file
5648: LD_VAR 0 1
5652: RET
// var cpu_side , cpu_nation , cpu_base ; export function create_americans ; var un , class_list , members ; begin
5653: LD_INT 0
5655: PPUSH
5656: PPUSH
5657: PPUSH
5658: PPUSH
// cpu_side := us ;
5659: LD_ADDR_LOC 4
5663: PUSH
5664: LD_EXP 3
5668: ST_TO_ADDR
// cpu_nation := nation_american ;
5669: LD_ADDR_LOC 5
5673: PUSH
5674: LD_INT 1
5676: ST_TO_ADDR
// cpu_base := us_create ;
5677: LD_ADDR_LOC 6
5681: PUSH
5682: LD_INT 18
5684: ST_TO_ADDR
// members := difficulty * 2 ;
5685: LD_ADDR_VAR 0 4
5689: PUSH
5690: LD_OWVAR 67
5694: PUSH
5695: LD_INT 2
5697: MUL
5698: ST_TO_ADDR
// class_list := [ class_soldier , class_mechanic , class_scientistic , class_engineer ] ;
5699: LD_ADDR_VAR 0 3
5703: PUSH
5704: LD_INT 1
5706: PUSH
5707: LD_INT 3
5709: PUSH
5710: LD_INT 4
5712: PUSH
5713: LD_INT 2
5715: PUSH
5716: EMPTY
5717: LIST
5718: LIST
5719: LIST
5720: LIST
5721: ST_TO_ADDR
// for un in class_list do
5722: LD_ADDR_VAR 0 2
5726: PUSH
5727: LD_VAR 0 3
5731: PUSH
5732: FOR_IN
5733: IFFALSE 5766
// create_units ( cpu_side , cpu_nation , un , members , cpu_base ) ;
5735: LD_LOC 4
5739: PPUSH
5740: LD_LOC 5
5744: PPUSH
5745: LD_VAR 0 2
5749: PPUSH
5750: LD_VAR 0 4
5754: PPUSH
5755: LD_LOC 6
5759: PPUSH
5760: CALL 7104 0 5
5764: GO 5732
5766: POP
5767: POP
// create_units ( cpu_side , cpu_nation , class_mechanic , 2 , cpu_base ) ;
5768: LD_LOC 4
5772: PPUSH
5773: LD_LOC 5
5777: PPUSH
5778: LD_INT 3
5780: PPUSH
5781: LD_INT 2
5783: PPUSH
5784: LD_LOC 6
5788: PPUSH
5789: CALL 7104 0 5
// SetResourceVisibility ( 43 , 81 , 1 ) ;
5793: LD_INT 43
5795: PPUSH
5796: LD_INT 81
5798: PPUSH
5799: LD_INT 1
5801: PPUSH
5802: CALL_OW 441
// SetResourceVisibility ( 30 , 49 , 1 ) ;
5806: LD_INT 30
5808: PPUSH
5809: LD_INT 49
5811: PPUSH
5812: LD_INT 1
5814: PPUSH
5815: CALL_OW 441
// place_all_soldiers ;
5819: CALL 5836 0 0
// place_all_scientistics ;
5823: CALL 6044 0 0
// place_all_mechanics ;
5827: CALL 6233 0 0
// end ;
5831: LD_VAR 0 1
5835: RET
// function place_all_soldiers ; var un , i , max , units , buildings ; begin
5836: LD_INT 0
5838: PPUSH
5839: PPUSH
5840: PPUSH
5841: PPUSH
5842: PPUSH
5843: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_btype , b_bunker ] ] ) ;
5844: LD_ADDR_VAR 0 6
5848: PUSH
5849: LD_INT 22
5851: PUSH
5852: LD_LOC 4
5856: PUSH
5857: EMPTY
5858: LIST
5859: LIST
5860: PUSH
5861: LD_INT 30
5863: PUSH
5864: LD_INT 32
5866: PUSH
5867: EMPTY
5868: LIST
5869: LIST
5870: PUSH
5871: EMPTY
5872: LIST
5873: LIST
5874: PPUSH
5875: CALL_OW 69
5879: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_soldier ] ] ) ;
5880: LD_ADDR_VAR 0 5
5884: PUSH
5885: LD_INT 22
5887: PUSH
5888: LD_LOC 4
5892: PUSH
5893: EMPTY
5894: LIST
5895: LIST
5896: PUSH
5897: LD_INT 25
5899: PUSH
5900: LD_INT 1
5902: PUSH
5903: EMPTY
5904: LIST
5905: LIST
5906: PUSH
5907: EMPTY
5908: LIST
5909: LIST
5910: PPUSH
5911: CALL_OW 69
5915: ST_TO_ADDR
// if buildings >= units then
5916: LD_VAR 0 6
5920: PUSH
5921: LD_VAR 0 5
5925: GREATEREQUAL
5926: IFFALSE 5944
// max := 0 + units else
5928: LD_ADDR_VAR 0 4
5932: PUSH
5933: LD_INT 0
5935: PUSH
5936: LD_VAR 0 5
5940: PLUS
5941: ST_TO_ADDR
5942: GO 5958
// max := 0 + buildings ;
5944: LD_ADDR_VAR 0 4
5948: PUSH
5949: LD_INT 0
5951: PUSH
5952: LD_VAR 0 6
5956: PLUS
5957: ST_TO_ADDR
// i = 1 ;
5958: LD_ADDR_VAR 0 3
5962: PUSH
5963: LD_INT 1
5965: ST_TO_ADDR
// for un in units do
5966: LD_ADDR_VAR 0 2
5970: PUSH
5971: LD_VAR 0 5
5975: PUSH
5976: FOR_IN
5977: IFFALSE 6037
// begin if i <= max then
5979: LD_VAR 0 3
5983: PUSH
5984: LD_VAR 0 4
5988: LESSEQUAL
5989: IFFALSE 6021
// ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
5991: LD_VAR 0 2
5995: PPUSH
5996: LD_VAR 0 6
6000: PUSH
6001: LD_VAR 0 3
6005: PUSH
6006: LD_VAR 0 6
6010: MOD
6011: PUSH
6012: LD_INT 1
6014: PLUS
6015: ARRAY
6016: PPUSH
6017: CALL_OW 120
// i := i + 1 ;
6021: LD_ADDR_VAR 0 3
6025: PUSH
6026: LD_VAR 0 3
6030: PUSH
6031: LD_INT 1
6033: PLUS
6034: ST_TO_ADDR
// end ;
6035: GO 5976
6037: POP
6038: POP
// end ;
6039: LD_VAR 0 1
6043: RET
// function place_all_scientistics ; var un , i , units , buildings ; begin
6044: LD_INT 0
6046: PPUSH
6047: PPUSH
6048: PPUSH
6049: PPUSH
6050: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab ] ] ] ) ;
6051: LD_ADDR_VAR 0 5
6055: PUSH
6056: LD_INT 22
6058: PUSH
6059: LD_LOC 4
6063: PUSH
6064: EMPTY
6065: LIST
6066: LIST
6067: PUSH
6068: LD_INT 2
6070: PUSH
6071: LD_INT 30
6073: PUSH
6074: LD_INT 8
6076: PUSH
6077: EMPTY
6078: LIST
6079: LIST
6080: PUSH
6081: LD_INT 30
6083: PUSH
6084: LD_INT 6
6086: PUSH
6087: EMPTY
6088: LIST
6089: LIST
6090: PUSH
6091: EMPTY
6092: LIST
6093: LIST
6094: LIST
6095: PUSH
6096: EMPTY
6097: LIST
6098: LIST
6099: PPUSH
6100: CALL_OW 69
6104: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_scientistic ] ] ) ;
6105: LD_ADDR_VAR 0 4
6109: PUSH
6110: LD_INT 22
6112: PUSH
6113: LD_LOC 4
6117: PUSH
6118: EMPTY
6119: LIST
6120: LIST
6121: PUSH
6122: LD_INT 25
6124: PUSH
6125: LD_INT 4
6127: PUSH
6128: EMPTY
6129: LIST
6130: LIST
6131: PUSH
6132: EMPTY
6133: LIST
6134: LIST
6135: PPUSH
6136: CALL_OW 69
6140: ST_TO_ADDR
// i = 1 ;
6141: LD_ADDR_VAR 0 3
6145: PUSH
6146: LD_INT 1
6148: ST_TO_ADDR
// for un in units do
6149: LD_ADDR_VAR 0 2
6153: PUSH
6154: LD_VAR 0 4
6158: PUSH
6159: FOR_IN
6160: IFFALSE 6226
// begin ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
6162: LD_VAR 0 2
6166: PPUSH
6167: LD_VAR 0 5
6171: PUSH
6172: LD_VAR 0 3
6176: PUSH
6177: LD_VAR 0 5
6181: MOD
6182: PUSH
6183: LD_INT 1
6185: PLUS
6186: ARRAY
6187: PPUSH
6188: CALL_OW 120
// i := i + 1 ;
6192: LD_ADDR_VAR 0 3
6196: PUSH
6197: LD_VAR 0 3
6201: PUSH
6202: LD_INT 1
6204: PLUS
6205: ST_TO_ADDR
// if i > ( units div 2 ) then
6206: LD_VAR 0 3
6210: PUSH
6211: LD_VAR 0 4
6215: PUSH
6216: LD_INT 2
6218: DIV
6219: GREATER
6220: IFFALSE 6224
// break ;
6222: GO 6226
// end ;
6224: GO 6159
6226: POP
6227: POP
// end ;
6228: LD_VAR 0 1
6232: RET
// function place_all_mechanics ; var un , i , units , buildings ; begin
6233: LD_INT 0
6235: PPUSH
6236: PPUSH
6237: PPUSH
6238: PPUSH
6239: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ;
6240: LD_ADDR_VAR 0 5
6244: PUSH
6245: LD_INT 22
6247: PUSH
6248: LD_LOC 4
6252: PUSH
6253: EMPTY
6254: LIST
6255: LIST
6256: PUSH
6257: LD_INT 2
6259: PUSH
6260: LD_INT 30
6262: PUSH
6263: LD_INT 2
6265: PUSH
6266: EMPTY
6267: LIST
6268: LIST
6269: PUSH
6270: LD_INT 30
6272: PUSH
6273: LD_INT 3
6275: PUSH
6276: EMPTY
6277: LIST
6278: LIST
6279: PUSH
6280: EMPTY
6281: LIST
6282: LIST
6283: LIST
6284: PUSH
6285: EMPTY
6286: LIST
6287: LIST
6288: PPUSH
6289: CALL_OW 69
6293: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_mechanic ] ] ) ;
6294: LD_ADDR_VAR 0 4
6298: PUSH
6299: LD_INT 22
6301: PUSH
6302: LD_LOC 4
6306: PUSH
6307: EMPTY
6308: LIST
6309: LIST
6310: PUSH
6311: LD_INT 25
6313: PUSH
6314: LD_INT 3
6316: PUSH
6317: EMPTY
6318: LIST
6319: LIST
6320: PUSH
6321: EMPTY
6322: LIST
6323: LIST
6324: PPUSH
6325: CALL_OW 69
6329: ST_TO_ADDR
// i = 1 ;
6330: LD_ADDR_VAR 0 3
6334: PUSH
6335: LD_INT 1
6337: ST_TO_ADDR
// for un in units do
6338: LD_ADDR_VAR 0 2
6342: PUSH
6343: LD_VAR 0 4
6347: PUSH
6348: FOR_IN
6349: IFFALSE 6397
// begin ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
6351: LD_VAR 0 2
6355: PPUSH
6356: LD_VAR 0 5
6360: PUSH
6361: LD_VAR 0 3
6365: PUSH
6366: LD_VAR 0 5
6370: MOD
6371: PUSH
6372: LD_INT 1
6374: PLUS
6375: ARRAY
6376: PPUSH
6377: CALL_OW 120
// i := i + 1 ;
6381: LD_ADDR_VAR 0 3
6385: PUSH
6386: LD_VAR 0 3
6390: PUSH
6391: LD_INT 1
6393: PLUS
6394: ST_TO_ADDR
// end ;
6395: GO 6348
6397: POP
6398: POP
// end ; end_of_file
6399: LD_VAR 0 1
6403: RET
// var cpu_side , cpu_nation , cpu_base ; export function create_arabians ; var un , class_list , members ; begin
6404: LD_INT 0
6406: PPUSH
6407: PPUSH
6408: PPUSH
6409: PPUSH
// cpu_side := ar ;
6410: LD_ADDR_LOC 7
6414: PUSH
6415: LD_EXP 4
6419: ST_TO_ADDR
// cpu_nation := nation_arabian ;
6420: LD_ADDR_LOC 8
6424: PUSH
6425: LD_INT 2
6427: ST_TO_ADDR
// cpu_base := ar_create ;
6428: LD_ADDR_LOC 9
6432: PUSH
6433: LD_INT 19
6435: ST_TO_ADDR
// members := difficulty + 1 ;
6436: LD_ADDR_VAR 0 4
6440: PUSH
6441: LD_OWVAR 67
6445: PUSH
6446: LD_INT 1
6448: PLUS
6449: ST_TO_ADDR
// class_list := [ class_soldier , class_mechanic , class_scientistic , class_engineer ] ;
6450: LD_ADDR_VAR 0 3
6454: PUSH
6455: LD_INT 1
6457: PUSH
6458: LD_INT 3
6460: PUSH
6461: LD_INT 4
6463: PUSH
6464: LD_INT 2
6466: PUSH
6467: EMPTY
6468: LIST
6469: LIST
6470: LIST
6471: LIST
6472: ST_TO_ADDR
// for un in class_list do
6473: LD_ADDR_VAR 0 2
6477: PUSH
6478: LD_VAR 0 3
6482: PUSH
6483: FOR_IN
6484: IFFALSE 6517
// create_units ( cpu_side , cpu_nation , un , members , cpu_base ) ;
6486: LD_LOC 7
6490: PPUSH
6491: LD_LOC 8
6495: PPUSH
6496: LD_VAR 0 2
6500: PPUSH
6501: LD_VAR 0 4
6505: PPUSH
6506: LD_LOC 9
6510: PPUSH
6511: CALL 7104 0 5
6515: GO 6483
6517: POP
6518: POP
// place_all_soldiers ;
6519: CALL 6536 0 0
// place_all_scientistics ;
6523: CALL 6744 0 0
// place_all_mechanics ;
6527: CALL 6933 0 0
// end ;
6531: LD_VAR 0 1
6535: RET
// function place_all_soldiers ; var un , i , max , units , buildings ; begin
6536: LD_INT 0
6538: PPUSH
6539: PPUSH
6540: PPUSH
6541: PPUSH
6542: PPUSH
6543: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_btype , b_bunker ] ] ) ;
6544: LD_ADDR_VAR 0 6
6548: PUSH
6549: LD_INT 22
6551: PUSH
6552: LD_LOC 7
6556: PUSH
6557: EMPTY
6558: LIST
6559: LIST
6560: PUSH
6561: LD_INT 30
6563: PUSH
6564: LD_INT 32
6566: PUSH
6567: EMPTY
6568: LIST
6569: LIST
6570: PUSH
6571: EMPTY
6572: LIST
6573: LIST
6574: PPUSH
6575: CALL_OW 69
6579: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_soldier ] ] ) ;
6580: LD_ADDR_VAR 0 5
6584: PUSH
6585: LD_INT 22
6587: PUSH
6588: LD_LOC 7
6592: PUSH
6593: EMPTY
6594: LIST
6595: LIST
6596: PUSH
6597: LD_INT 25
6599: PUSH
6600: LD_INT 1
6602: PUSH
6603: EMPTY
6604: LIST
6605: LIST
6606: PUSH
6607: EMPTY
6608: LIST
6609: LIST
6610: PPUSH
6611: CALL_OW 69
6615: ST_TO_ADDR
// if buildings >= units then
6616: LD_VAR 0 6
6620: PUSH
6621: LD_VAR 0 5
6625: GREATEREQUAL
6626: IFFALSE 6644
// max := 0 + units else
6628: LD_ADDR_VAR 0 4
6632: PUSH
6633: LD_INT 0
6635: PUSH
6636: LD_VAR 0 5
6640: PLUS
6641: ST_TO_ADDR
6642: GO 6658
// max := 0 + buildings ;
6644: LD_ADDR_VAR 0 4
6648: PUSH
6649: LD_INT 0
6651: PUSH
6652: LD_VAR 0 6
6656: PLUS
6657: ST_TO_ADDR
// i = 1 ;
6658: LD_ADDR_VAR 0 3
6662: PUSH
6663: LD_INT 1
6665: ST_TO_ADDR
// for un in units do
6666: LD_ADDR_VAR 0 2
6670: PUSH
6671: LD_VAR 0 5
6675: PUSH
6676: FOR_IN
6677: IFFALSE 6737
// begin if i <= max then
6679: LD_VAR 0 3
6683: PUSH
6684: LD_VAR 0 4
6688: LESSEQUAL
6689: IFFALSE 6721
// ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
6691: LD_VAR 0 2
6695: PPUSH
6696: LD_VAR 0 6
6700: PUSH
6701: LD_VAR 0 3
6705: PUSH
6706: LD_VAR 0 6
6710: MOD
6711: PUSH
6712: LD_INT 1
6714: PLUS
6715: ARRAY
6716: PPUSH
6717: CALL_OW 120
// i := i + 1 ;
6721: LD_ADDR_VAR 0 3
6725: PUSH
6726: LD_VAR 0 3
6730: PUSH
6731: LD_INT 1
6733: PLUS
6734: ST_TO_ADDR
// end ;
6735: GO 6676
6737: POP
6738: POP
// end ;
6739: LD_VAR 0 1
6743: RET
// function place_all_scientistics ; var un , i , units , buildings ; begin
6744: LD_INT 0
6746: PPUSH
6747: PPUSH
6748: PPUSH
6749: PPUSH
6750: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab ] ] ] ) ;
6751: LD_ADDR_VAR 0 5
6755: PUSH
6756: LD_INT 22
6758: PUSH
6759: LD_LOC 7
6763: PUSH
6764: EMPTY
6765: LIST
6766: LIST
6767: PUSH
6768: LD_INT 2
6770: PUSH
6771: LD_INT 30
6773: PUSH
6774: LD_INT 8
6776: PUSH
6777: EMPTY
6778: LIST
6779: LIST
6780: PUSH
6781: LD_INT 30
6783: PUSH
6784: LD_INT 6
6786: PUSH
6787: EMPTY
6788: LIST
6789: LIST
6790: PUSH
6791: EMPTY
6792: LIST
6793: LIST
6794: LIST
6795: PUSH
6796: EMPTY
6797: LIST
6798: LIST
6799: PPUSH
6800: CALL_OW 69
6804: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_scientistic ] ] ) ;
6805: LD_ADDR_VAR 0 4
6809: PUSH
6810: LD_INT 22
6812: PUSH
6813: LD_LOC 7
6817: PUSH
6818: EMPTY
6819: LIST
6820: LIST
6821: PUSH
6822: LD_INT 25
6824: PUSH
6825: LD_INT 4
6827: PUSH
6828: EMPTY
6829: LIST
6830: LIST
6831: PUSH
6832: EMPTY
6833: LIST
6834: LIST
6835: PPUSH
6836: CALL_OW 69
6840: ST_TO_ADDR
// i = 1 ;
6841: LD_ADDR_VAR 0 3
6845: PUSH
6846: LD_INT 1
6848: ST_TO_ADDR
// for un in units do
6849: LD_ADDR_VAR 0 2
6853: PUSH
6854: LD_VAR 0 4
6858: PUSH
6859: FOR_IN
6860: IFFALSE 6926
// begin ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
6862: LD_VAR 0 2
6866: PPUSH
6867: LD_VAR 0 5
6871: PUSH
6872: LD_VAR 0 3
6876: PUSH
6877: LD_VAR 0 5
6881: MOD
6882: PUSH
6883: LD_INT 1
6885: PLUS
6886: ARRAY
6887: PPUSH
6888: CALL_OW 120
// i := i + 1 ;
6892: LD_ADDR_VAR 0 3
6896: PUSH
6897: LD_VAR 0 3
6901: PUSH
6902: LD_INT 1
6904: PLUS
6905: ST_TO_ADDR
// if i > ( units div 2 ) then
6906: LD_VAR 0 3
6910: PUSH
6911: LD_VAR 0 4
6915: PUSH
6916: LD_INT 2
6918: DIV
6919: GREATER
6920: IFFALSE 6924
// break ;
6922: GO 6926
// end ;
6924: GO 6859
6926: POP
6927: POP
// end ;
6928: LD_VAR 0 1
6932: RET
// function place_all_mechanics ; var un , i , units , buildings ; begin
6933: LD_INT 0
6935: PPUSH
6936: PPUSH
6937: PPUSH
6938: PPUSH
6939: PPUSH
// buildings := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ;
6940: LD_ADDR_VAR 0 5
6944: PUSH
6945: LD_INT 22
6947: PUSH
6948: LD_LOC 7
6952: PUSH
6953: EMPTY
6954: LIST
6955: LIST
6956: PUSH
6957: LD_INT 2
6959: PUSH
6960: LD_INT 30
6962: PUSH
6963: LD_INT 2
6965: PUSH
6966: EMPTY
6967: LIST
6968: LIST
6969: PUSH
6970: LD_INT 30
6972: PUSH
6973: LD_INT 3
6975: PUSH
6976: EMPTY
6977: LIST
6978: LIST
6979: PUSH
6980: EMPTY
6981: LIST
6982: LIST
6983: LIST
6984: PUSH
6985: EMPTY
6986: LIST
6987: LIST
6988: PPUSH
6989: CALL_OW 69
6993: ST_TO_ADDR
// units := FilterAllUnits ( [ [ f_side , cpu_side ] , [ f_class , class_mechanic ] ] ) ;
6994: LD_ADDR_VAR 0 4
6998: PUSH
6999: LD_INT 22
7001: PUSH
7002: LD_LOC 7
7006: PUSH
7007: EMPTY
7008: LIST
7009: LIST
7010: PUSH
7011: LD_INT 25
7013: PUSH
7014: LD_INT 3
7016: PUSH
7017: EMPTY
7018: LIST
7019: LIST
7020: PUSH
7021: EMPTY
7022: LIST
7023: LIST
7024: PPUSH
7025: CALL_OW 69
7029: ST_TO_ADDR
// i = 1 ;
7030: LD_ADDR_VAR 0 3
7034: PUSH
7035: LD_INT 1
7037: ST_TO_ADDR
// for un in units do
7038: LD_ADDR_VAR 0 2
7042: PUSH
7043: LD_VAR 0 4
7047: PUSH
7048: FOR_IN
7049: IFFALSE 7097
// begin ComEnterUnit ( un , buildings [ ( i mod buildings ) + 1 ] ) ;
7051: LD_VAR 0 2
7055: PPUSH
7056: LD_VAR 0 5
7060: PUSH
7061: LD_VAR 0 3
7065: PUSH
7066: LD_VAR 0 5
7070: MOD
7071: PUSH
7072: LD_INT 1
7074: PLUS
7075: ARRAY
7076: PPUSH
7077: CALL_OW 120
// i := i + 1 ;
7081: LD_ADDR_VAR 0 3
7085: PUSH
7086: LD_VAR 0 3
7090: PUSH
7091: LD_INT 1
7093: PLUS
7094: ST_TO_ADDR
// end ;
7095: GO 7048
7097: POP
7098: POP
// end ; end_of_file
7099: LD_VAR 0 1
7103: RET
// export function create_units ( side , nation , class_n , num , area ) ; var i , un , lev ; begin
7104: LD_INT 0
7106: PPUSH
7107: PPUSH
7108: PPUSH
7109: PPUSH
// if class_n = class_scientistic then
7110: LD_VAR 0 3
7114: PUSH
7115: LD_INT 4
7117: EQUAL
7118: IFFALSE 7172
// begin lev := [ 3 , 6 , 10 ] [ difficulty ] ;
7120: LD_ADDR_VAR 0 9
7124: PUSH
7125: LD_INT 3
7127: PUSH
7128: LD_INT 6
7130: PUSH
7131: LD_INT 10
7133: PUSH
7134: EMPTY
7135: LIST
7136: LIST
7137: LIST
7138: PUSH
7139: LD_OWVAR 67
7143: ARRAY
7144: ST_TO_ADDR
// num := [ 2 , 4 , 6 ] [ difficulty ] ;
7145: LD_ADDR_VAR 0 4
7149: PUSH
7150: LD_INT 2
7152: PUSH
7153: LD_INT 4
7155: PUSH
7156: LD_INT 6
7158: PUSH
7159: EMPTY
7160: LIST
7161: LIST
7162: LIST
7163: PUSH
7164: LD_OWVAR 67
7168: ARRAY
7169: ST_TO_ADDR
// end else
7170: GO 7242
// if class_n = class_soldier then
7172: LD_VAR 0 3
7176: PUSH
7177: LD_INT 1
7179: EQUAL
7180: IFFALSE 7217
// begin lev := [ 5 , 7 , 10 ] [ difficulty ] ;
7182: LD_ADDR_VAR 0 9
7186: PUSH
7187: LD_INT 5
7189: PUSH
7190: LD_INT 7
7192: PUSH
7193: LD_INT 10
7195: PUSH
7196: EMPTY
7197: LIST
7198: LIST
7199: LIST
7200: PUSH
7201: LD_OWVAR 67
7205: ARRAY
7206: ST_TO_ADDR
// num := 6 ;
7207: LD_ADDR_VAR 0 4
7211: PUSH
7212: LD_INT 6
7214: ST_TO_ADDR
// end else
7215: GO 7242
// lev := [ 4 , 6 , 10 ] [ difficulty ] ;
7217: LD_ADDR_VAR 0 9
7221: PUSH
7222: LD_INT 4
7224: PUSH
7225: LD_INT 6
7227: PUSH
7228: LD_INT 10
7230: PUSH
7231: EMPTY
7232: LIST
7233: LIST
7234: LIST
7235: PUSH
7236: LD_OWVAR 67
7240: ARRAY
7241: ST_TO_ADDR
// uc_side := side ;
7242: LD_ADDR_OWVAR 20
7246: PUSH
7247: LD_VAR 0 1
7251: ST_TO_ADDR
// uc_nation := nation ;
7252: LD_ADDR_OWVAR 21
7256: PUSH
7257: LD_VAR 0 2
7261: ST_TO_ADDR
// for i = 1 to num do
7262: LD_ADDR_VAR 0 7
7266: PUSH
7267: DOUBLE
7268: LD_INT 1
7270: DEC
7271: ST_TO_ADDR
7272: LD_VAR 0 4
7276: PUSH
7277: FOR_TO
7278: IFFALSE 7423
// begin uc_direction := Rand ( 0 , 5 ) ;
7280: LD_ADDR_OWVAR 24
7284: PUSH
7285: LD_INT 0
7287: PPUSH
7288: LD_INT 5
7290: PPUSH
7291: CALL_OW 12
7295: ST_TO_ADDR
// case class_n of 1 :
7296: LD_VAR 0 3
7300: PUSH
7301: LD_INT 1
7303: DOUBLE
7304: EQUAL
7305: IFTRUE 7309
7307: GO 7324
7309: POP
// PrepareSoldier ( 0 , lev ) ; 2 :
7310: LD_INT 0
7312: PPUSH
7313: LD_VAR 0 9
7317: PPUSH
7318: CALL_OW 381
7322: GO 7394
7324: LD_INT 2
7326: DOUBLE
7327: EQUAL
7328: IFTRUE 7332
7330: GO 7347
7332: POP
// PrepareEngineer ( 0 , lev ) ; 3 :
7333: LD_INT 0
7335: PPUSH
7336: LD_VAR 0 9
7340: PPUSH
7341: CALL_OW 382
7345: GO 7394
7347: LD_INT 3
7349: DOUBLE
7350: EQUAL
7351: IFTRUE 7355
7353: GO 7370
7355: POP
// PrepareMechanic ( 0 , lev ) ; 4 :
7356: LD_INT 0
7358: PPUSH
7359: LD_VAR 0 9
7363: PPUSH
7364: CALL_OW 383
7368: GO 7394
7370: LD_INT 4
7372: DOUBLE
7373: EQUAL
7374: IFTRUE 7378
7376: GO 7393
7378: POP
// PrepareScientist ( 0 , lev ) ; end ;
7379: LD_INT 0
7381: PPUSH
7382: LD_VAR 0 9
7386: PPUSH
7387: CALL_OW 384
7391: GO 7394
7393: POP
// un := CreateHuman ;
7394: LD_ADDR_VAR 0 8
7398: PUSH
7399: CALL_OW 44
7403: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7404: LD_VAR 0 8
7408: PPUSH
7409: LD_VAR 0 5
7413: PPUSH
7414: LD_INT 0
7416: PPUSH
7417: CALL_OW 49
// end ;
7421: GO 7277
7423: POP
7424: POP
// end ;
7425: LD_VAR 0 6
7429: RET
// export function prepare_apemans ; var ape , i ; begin
7430: LD_INT 0
7432: PPUSH
7433: PPUSH
7434: PPUSH
// for i = 1 to ( 6 - difficulty ) do
7435: LD_ADDR_VAR 0 3
7439: PUSH
7440: DOUBLE
7441: LD_INT 1
7443: DEC
7444: ST_TO_ADDR
7445: LD_INT 6
7447: PUSH
7448: LD_OWVAR 67
7452: MINUS
7453: PUSH
7454: FOR_TO
7455: IFFALSE 7655
// begin uc_side := neutral ;
7457: LD_ADDR_OWVAR 20
7461: PUSH
7462: LD_EXP 6
7466: ST_TO_ADDR
// uc_nation := nation_nature ;
7467: LD_ADDR_OWVAR 21
7471: PUSH
7472: LD_INT 0
7474: ST_TO_ADDR
// hc_class := class_apeman ;
7475: LD_ADDR_OWVAR 28
7479: PUSH
7480: LD_INT 12
7482: ST_TO_ADDR
// hc_basic_skills := [ Rand ( 1 , 2 ) , Rand ( 1 , 2 ) , Rand ( 1 , 2 ) , Rand ( 1 , 2 ) ] ;
7483: LD_ADDR_OWVAR 30
7487: PUSH
7488: LD_INT 1
7490: PPUSH
7491: LD_INT 2
7493: PPUSH
7494: CALL_OW 12
7498: PUSH
7499: LD_INT 1
7501: PPUSH
7502: LD_INT 2
7504: PPUSH
7505: CALL_OW 12
7509: PUSH
7510: LD_INT 1
7512: PPUSH
7513: LD_INT 2
7515: PPUSH
7516: CALL_OW 12
7520: PUSH
7521: LD_INT 1
7523: PPUSH
7524: LD_INT 2
7526: PPUSH
7527: CALL_OW 12
7531: PUSH
7532: EMPTY
7533: LIST
7534: LIST
7535: LIST
7536: LIST
7537: ST_TO_ADDR
// hc_skills := [ 3 , 3 , 3 , 3 ] ;
7538: LD_ADDR_OWVAR 31
7542: PUSH
7543: LD_INT 3
7545: PUSH
7546: LD_INT 3
7548: PUSH
7549: LD_INT 3
7551: PUSH
7552: LD_INT 3
7554: PUSH
7555: EMPTY
7556: LIST
7557: LIST
7558: LIST
7559: LIST
7560: ST_TO_ADDR
// hc_attr := [ 10 , 12 ] ;
7561: LD_ADDR_OWVAR 29
7565: PUSH
7566: LD_INT 10
7568: PUSH
7569: LD_INT 12
7571: PUSH
7572: EMPTY
7573: LIST
7574: LIST
7575: ST_TO_ADDR
// hc_sex := [ sex_female , sex_male ] [ Rand ( 1 , 2 ) ] ;
7576: LD_ADDR_OWVAR 27
7580: PUSH
7581: LD_INT 2
7583: PUSH
7584: LD_INT 1
7586: PUSH
7587: EMPTY
7588: LIST
7589: LIST
7590: PUSH
7591: LD_INT 1
7593: PPUSH
7594: LD_INT 2
7596: PPUSH
7597: CALL_OW 12
7601: ARRAY
7602: ST_TO_ADDR
// hc_importance := 0 ;
7603: LD_ADDR_OWVAR 32
7607: PUSH
7608: LD_INT 0
7610: ST_TO_ADDR
// hc_agressivity := Rand ( - 20 , 20 ) ;
7611: LD_ADDR_OWVAR 35
7615: PUSH
7616: LD_INT 20
7618: NEG
7619: PPUSH
7620: LD_INT 20
7622: PPUSH
7623: CALL_OW 12
7627: ST_TO_ADDR
// ape := CreateHuman ;
7628: LD_ADDR_VAR 0 2
7632: PUSH
7633: CALL_OW 44
7637: ST_TO_ADDR
// PlaceUnitArea ( ape , apeman_forest , false ) ;
7638: LD_VAR 0 2
7642: PPUSH
7643: LD_INT 32
7645: PPUSH
7646: LD_INT 0
7648: PPUSH
7649: CALL_OW 49
// end ;
7653: GO 7454
7655: POP
7656: POP
// end ; end_of_file
7657: LD_VAR 0 1
7661: RET
// var alien_tower_spoted ; export function starting_scene ; var check_time ; begin
7662: LD_INT 0
7664: PPUSH
7665: PPUSH
// CenterNowOnXY ( 75 , 27 ) ;
7666: LD_INT 75
7668: PPUSH
7669: LD_INT 27
7671: PPUSH
7672: CALL_OW 86
// wait ( 0 0$1 ) ;
7676: LD_INT 35
7678: PPUSH
7679: CALL_OW 67
// InGameOn ;
7683: CALL_OW 8
// ComMoveToArea ( IsInUnit ( Burlak ) , burlak_panorama_area ) ;
7687: LD_EXP 12
7691: PPUSH
7692: CALL_OW 310
7696: PPUSH
7697: LD_INT 8
7699: PPUSH
7700: CALL_OW 113
// ComMoveToArea ( IsInUnit ( MacMillan ) , jmm_panorama_area ) ;
7704: LD_EXP 13
7708: PPUSH
7709: CALL_OW 310
7713: PPUSH
7714: LD_INT 28
7716: PPUSH
7717: CALL_OW 113
// CenterOnUnits ( [ MacMillan , Burlak ] ) ;
7721: LD_EXP 13
7725: PUSH
7726: LD_EXP 12
7730: PUSH
7731: EMPTY
7732: LIST
7733: LIST
7734: PPUSH
7735: CALL_OW 85
// repeat wait ( 20 ) ;
7739: LD_INT 20
7741: PPUSH
7742: CALL_OW 67
// until IsInArea ( Burlak , burlak_panorama_area ) and IsInArea ( MacMillan , jmm_panorama_area ) ;
7746: LD_EXP 12
7750: PPUSH
7751: LD_INT 8
7753: PPUSH
7754: CALL_OW 308
7758: PUSH
7759: LD_EXP 13
7763: PPUSH
7764: LD_INT 28
7766: PPUSH
7767: CALL_OW 308
7771: AND
7772: IFFALSE 7739
// ComExitVehicle ( [ Burlak , MacMillan ] ) ;
7774: LD_EXP 12
7778: PUSH
7779: LD_EXP 13
7783: PUSH
7784: EMPTY
7785: LIST
7786: LIST
7787: PPUSH
7788: CALL_OW 121
// while IsInUnit ( Burlak ) or IsInUnit ( MacMillan ) do
7792: LD_EXP 12
7796: PPUSH
7797: CALL_OW 310
7801: PUSH
7802: LD_EXP 13
7806: PPUSH
7807: CALL_OW 310
7811: OR
7812: IFFALSE 7823
// wait ( 5 ) ;
7814: LD_INT 5
7816: PPUSH
7817: CALL_OW 67
7821: GO 7792
// wait ( 10 ) ;
7823: LD_INT 10
7825: PPUSH
7826: CALL_OW 67
// ComMoveToArea ( Burlak , burlak_talking_panorama ) ;
7830: LD_EXP 12
7834: PPUSH
7835: LD_INT 9
7837: PPUSH
7838: CALL_OW 113
// ComMoveToArea ( MacMillan , jmm_talking_panorama ) ;
7842: LD_EXP 13
7846: PPUSH
7847: LD_INT 29
7849: PPUSH
7850: CALL_OW 113
// check_time := TICK ;
7854: LD_ADDR_VAR 0 2
7858: PUSH
7859: LD_OWVAR 1
7863: ST_TO_ADDR
// repeat ComHold ( FilterUnitsInArea ( burlak_talking_panorama , [ [ f_side , you ] ] ) ) ;
7864: LD_INT 9
7866: PPUSH
7867: LD_INT 22
7869: PUSH
7870: LD_EXP 1
7874: PUSH
7875: EMPTY
7876: LIST
7877: LIST
7878: PUSH
7879: EMPTY
7880: LIST
7881: PPUSH
7882: CALL_OW 70
7886: PPUSH
7887: CALL_OW 140
// ComHold ( FilterUnitsInArea ( jmm_talking_panorama , [ [ f_side , you ] ] ) ) ;
7891: LD_INT 29
7893: PPUSH
7894: LD_INT 22
7896: PUSH
7897: LD_EXP 1
7901: PUSH
7902: EMPTY
7903: LIST
7904: LIST
7905: PUSH
7906: EMPTY
7907: LIST
7908: PPUSH
7909: CALL_OW 70
7913: PPUSH
7914: CALL_OW 140
// wait ( 0 0$1 ) ;
7918: LD_INT 35
7920: PPUSH
7921: CALL_OW 67
// until ( IsInArea ( Burlak , burlak_talking_panorama ) and IsInArea ( MacMillan , jmm_talking_panorama ) ) or ( check_time < ( TICK - 0 0$4 ) ) ;
7925: LD_EXP 12
7929: PPUSH
7930: LD_INT 9
7932: PPUSH
7933: CALL_OW 308
7937: PUSH
7938: LD_EXP 13
7942: PPUSH
7943: LD_INT 29
7945: PPUSH
7946: CALL_OW 308
7950: AND
7951: PUSH
7952: LD_VAR 0 2
7956: PUSH
7957: LD_OWVAR 1
7961: PUSH
7962: LD_INT 140
7964: MINUS
7965: LESS
7966: OR
7967: IFFALSE 7864
// ComTurnUnit ( MacMillan , Burlak ) ;
7969: LD_EXP 13
7973: PPUSH
7974: LD_EXP 12
7978: PPUSH
7979: CALL_OW 119
// ComTurnUnit ( Burlak , MacMillan ) ;
7983: LD_EXP 12
7987: PPUSH
7988: LD_EXP 13
7992: PPUSH
7993: CALL_OW 119
// CenterOnXY ( 77 , 31 ) ;
7997: LD_INT 77
7999: PPUSH
8000: LD_INT 31
8002: PPUSH
8003: CALL_OW 84
// wait ( 10 ) ;
8007: LD_INT 10
8009: PPUSH
8010: CALL_OW 67
// InGameOff ;
8014: CALL_OW 9
// DialogueOn ;
8018: CALL_OW 6
// interface_hidden := true ;
8022: LD_ADDR_OWVAR 54
8026: PUSH
8027: LD_INT 1
8029: ST_TO_ADDR
// case camp of 4 :
8030: LD_EXP 7
8034: PUSH
8035: LD_INT 4
8037: DOUBLE
8038: EQUAL
8039: IFTRUE 8043
8041: GO 8094
8043: POP
// begin Say ( MacMillan , DStart-JMM-JMM-1 ) ;
8044: LD_EXP 13
8048: PPUSH
8049: LD_STRING DStart-JMM-JMM-1
8051: PPUSH
8052: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
8056: LD_EXP 12
8060: PPUSH
8061: LD_STRING DStart-JMM-Bur-1
8063: PPUSH
8064: CALL_OW 88
// Say ( MacMillan , DStart-JMM-JMM-2 ) ;
8068: LD_EXP 13
8072: PPUSH
8073: LD_STRING DStart-JMM-JMM-2
8075: PPUSH
8076: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
8080: LD_EXP 12
8084: PPUSH
8085: LD_STRING DStart-JMM-Bur-2
8087: PPUSH
8088: CALL_OW 88
// end ; 6 :
8092: GO 8142
8094: LD_INT 6
8096: DOUBLE
8097: EQUAL
8098: IFTRUE 8102
8100: GO 8141
8102: POP
// begin Say ( Burlak , DStart-Burlak-Bur-1 ) ;
8103: LD_EXP 12
8107: PPUSH
8108: LD_STRING DStart-Burlak-Bur-1
8110: PPUSH
8111: CALL_OW 88
// Say ( Macmillan , DStart-Burlak-JMM-1 ) ;
8115: LD_EXP 13
8119: PPUSH
8120: LD_STRING DStart-Burlak-JMM-1
8122: PPUSH
8123: CALL_OW 88
// Say ( Burlak , DStart-Burlak-Bur-2 ) ;
8127: LD_EXP 12
8131: PPUSH
8132: LD_STRING DStart-Burlak-Bur-2
8134: PPUSH
8135: CALL_OW 88
// end ; end ;
8139: GO 8142
8141: POP
// SaveForQuickRestart ;
8142: CALL_OW 22
// wait ( 20 ) ;
8146: LD_INT 20
8148: PPUSH
8149: CALL_OW 67
// ChangeMissionObjectives ( MStart ) ;
8153: LD_STRING MStart
8155: PPUSH
8156: CALL_OW 337
// interface_hidden := false ;
8160: LD_ADDR_OWVAR 54
8164: PUSH
8165: LD_INT 0
8167: ST_TO_ADDR
// DialogueOff ;
8168: CALL_OW 7
// us_researched := false ;
8172: LD_ADDR_EXP 63
8176: PUSH
8177: LD_INT 0
8179: ST_TO_ADDR
// us_researched := true ;
8180: LD_ADDR_EXP 63
8184: PUSH
8185: LD_INT 1
8187: ST_TO_ADDR
// omar_in_contact := false ;
8188: LD_ADDR_EXP 66
8192: PUSH
8193: LD_INT 0
8195: ST_TO_ADDR
// alien_tower_spoted := false ;
8196: LD_ADDR_LOC 10
8200: PUSH
8201: LD_INT 0
8203: ST_TO_ADDR
// one_enabled := false ;
8204: LD_ADDR_EXP 65
8208: PUSH
8209: LD_INT 0
8211: ST_TO_ADDR
// end ;
8212: LD_VAR 0 1
8216: RET
// every 0 0$2.3 trigger See ( you , al_tower ) do var un , sol , sci ;
8217: LD_EXP 1
8221: PPUSH
8222: LD_INT 108
8224: PPUSH
8225: CALL_OW 292
8229: IFFALSE 8735
8231: GO 8233
8233: DISABLE
8234: LD_INT 0
8236: PPUSH
8237: PPUSH
8238: PPUSH
// begin repeat wait ( 0 0$1 ) ;
8239: LD_INT 35
8241: PPUSH
8242: CALL_OW 67
// until not FilterAllUnits ( [ [ f_side , ar ] , [ f_type , unit_human ] , [ f_ok ] , f_not , [ f_inside ] ] ) ;
8246: LD_INT 22
8248: PUSH
8249: LD_EXP 4
8253: PUSH
8254: EMPTY
8255: LIST
8256: LIST
8257: PUSH
8258: LD_INT 21
8260: PUSH
8261: LD_INT 1
8263: PUSH
8264: EMPTY
8265: LIST
8266: LIST
8267: PUSH
8268: LD_INT 50
8270: PUSH
8271: EMPTY
8272: LIST
8273: PUSH
8274: LD_INT 3
8276: PUSH
8277: LD_INT 54
8279: PUSH
8280: EMPTY
8281: LIST
8282: PUSH
8283: EMPTY
8284: LIST
8285: LIST
8286: LIST
8287: LIST
8288: LIST
8289: PPUSH
8290: CALL_OW 69
8294: NOT
8295: IFFALSE 8239
// wait ( 0 0$1 ) ;
8297: LD_INT 35
8299: PPUSH
8300: CALL_OW 67
// cpu_list := cpu_list diff ar ;
8304: LD_ADDR_EXP 8
8308: PUSH
8309: LD_EXP 8
8313: PUSH
8314: LD_EXP 4
8318: DIFF
8319: ST_TO_ADDR
// un := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_male ] ] ) diff [ MacMillan , Burlak , Roth , Gossudarov , 0 ] ;
8320: LD_ADDR_VAR 0 1
8324: PUSH
8325: LD_INT 22
8327: PUSH
8328: LD_EXP 1
8332: PUSH
8333: EMPTY
8334: LIST
8335: LIST
8336: PUSH
8337: LD_INT 26
8339: PUSH
8340: LD_INT 1
8342: PUSH
8343: EMPTY
8344: LIST
8345: LIST
8346: PUSH
8347: EMPTY
8348: LIST
8349: LIST
8350: PPUSH
8351: CALL_OW 69
8355: PUSH
8356: LD_EXP 13
8360: PUSH
8361: LD_EXP 12
8365: PUSH
8366: LD_EXP 14
8370: PUSH
8371: LD_EXP 15
8375: PUSH
8376: LD_INT 0
8378: PUSH
8379: EMPTY
8380: LIST
8381: LIST
8382: LIST
8383: LIST
8384: LIST
8385: DIFF
8386: ST_TO_ADDR
// if un then
8387: LD_VAR 0 1
8391: IFFALSE 8411
// sol := FindMaxSkill ( un , skill_combat ) ;
8393: LD_ADDR_VAR 0 2
8397: PUSH
8398: LD_VAR 0 1
8402: PPUSH
8403: LD_INT 1
8405: PPUSH
8406: CALL_OW 433
8410: ST_TO_ADDR
// un := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_male ] ] ) diff [ MacMillan , Burlak , Roth , Gossudarov , sol , 0 ] ;
8411: LD_ADDR_VAR 0 1
8415: PUSH
8416: LD_INT 22
8418: PUSH
8419: LD_EXP 1
8423: PUSH
8424: EMPTY
8425: LIST
8426: LIST
8427: PUSH
8428: LD_INT 26
8430: PUSH
8431: LD_INT 1
8433: PUSH
8434: EMPTY
8435: LIST
8436: LIST
8437: PUSH
8438: EMPTY
8439: LIST
8440: LIST
8441: PPUSH
8442: CALL_OW 69
8446: PUSH
8447: LD_EXP 13
8451: PUSH
8452: LD_EXP 12
8456: PUSH
8457: LD_EXP 14
8461: PUSH
8462: LD_EXP 15
8466: PUSH
8467: LD_VAR 0 2
8471: PUSH
8472: LD_INT 0
8474: PUSH
8475: EMPTY
8476: LIST
8477: LIST
8478: LIST
8479: LIST
8480: LIST
8481: LIST
8482: DIFF
8483: ST_TO_ADDR
// if un then
8484: LD_VAR 0 1
8488: IFFALSE 8508
// sci := FindMaxSkill ( un , skill_scientistic ) ;
8490: LD_ADDR_VAR 0 3
8494: PUSH
8495: LD_VAR 0 1
8499: PPUSH
8500: LD_INT 4
8502: PPUSH
8503: CALL_OW 433
8507: ST_TO_ADDR
// PlaceSeeing ( 248 , 183 , you , 10 ) ;
8508: LD_INT 248
8510: PPUSH
8511: LD_INT 183
8513: PPUSH
8514: LD_EXP 1
8518: PPUSH
8519: LD_INT 10
8521: PPUSH
8522: CALL_OW 330
// CenterOnUnits ( al_tower ) ;
8526: LD_INT 108
8528: PPUSH
8529: CALL_OW 85
// DialogueOn ;
8533: CALL_OW 6
// interface_hidden := true ;
8537: LD_ADDR_OWVAR 54
8541: PUSH
8542: LD_INT 1
8544: ST_TO_ADDR
// Say ( sol , DAlienBase-Rsol1-1 ) ;
8545: LD_VAR 0 2
8549: PPUSH
8550: LD_STRING DAlienBase-Rsol1-1
8552: PPUSH
8553: CALL_OW 88
// case camp of 4 :
8557: LD_EXP 7
8561: PUSH
8562: LD_INT 4
8564: DOUBLE
8565: EQUAL
8566: IFTRUE 8570
8568: GO 8621
8570: POP
// begin Say ( MacMillan , DAlienBase-JMM-1 ) ;
8571: LD_EXP 13
8575: PPUSH
8576: LD_STRING DAlienBase-JMM-1
8578: PPUSH
8579: CALL_OW 88
// Say ( Roth , DAlienBase-Roth-1 ) ;
8583: LD_EXP 14
8587: PPUSH
8588: LD_STRING DAlienBase-Roth-1
8590: PPUSH
8591: CALL_OW 88
// if not IsOK ( Roth ) then
8595: LD_EXP 14
8599: PPUSH
8600: CALL_OW 302
8604: NOT
8605: IFFALSE 8619
// Say ( sci , DAlienBase-Sci1-1 ) ;
8607: LD_VAR 0 3
8611: PPUSH
8612: LD_STRING DAlienBase-Sci1-1
8614: PPUSH
8615: CALL_OW 88
// end ; 6 :
8619: GO 8681
8621: LD_INT 6
8623: DOUBLE
8624: EQUAL
8625: IFTRUE 8629
8627: GO 8680
8629: POP
// begin Say ( Burlak , DAlienBase-Bur-1 ) ;
8630: LD_EXP 12
8634: PPUSH
8635: LD_STRING DAlienBase-Bur-1
8637: PPUSH
8638: CALL_OW 88
// Say ( Gossudarov , DAlienBase-Gos-1 ) ;
8642: LD_EXP 15
8646: PPUSH
8647: LD_STRING DAlienBase-Gos-1
8649: PPUSH
8650: CALL_OW 88
// if not IsOK ( Gossudarov ) then
8654: LD_EXP 15
8658: PPUSH
8659: CALL_OW 302
8663: NOT
8664: IFFALSE 8678
// Say ( sci , DAlienBase-Sci1-1 ) ;
8666: LD_VAR 0 3
8670: PPUSH
8671: LD_STRING DAlienBase-Sci1-1
8673: PPUSH
8674: CALL_OW 88
// end ; end ;
8678: GO 8681
8680: POP
// SetSide ( al_tower , you ) ;
8681: LD_INT 108
8683: PPUSH
8684: LD_EXP 1
8688: PPUSH
8689: CALL_OW 235
// RemoveSeeing ( 248 , 183 , you ) ;
8693: LD_INT 248
8695: PPUSH
8696: LD_INT 183
8698: PPUSH
8699: LD_EXP 1
8703: PPUSH
8704: CALL_OW 331
// interface_hidden := false ;
8708: LD_ADDR_OWVAR 54
8712: PUSH
8713: LD_INT 0
8715: ST_TO_ADDR
// DialogueOff ;
8716: CALL_OW 7
// Hint ( ArtefactBuilding ) ;
8720: LD_STRING ArtefactBuilding
8722: PPUSH
8723: CALL_OW 339
// alien_tower_spoted := true ;
8727: LD_ADDR_LOC 10
8731: PUSH
8732: LD_INT 1
8734: ST_TO_ADDR
// end ;
8735: PPOPN 3
8737: END
// every 0 0$4.6 trigger FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] , [ f_lives , 1000 ] ] ) and alien_tower_spoted do var un , sci ;
8738: LD_INT 22
8740: PUSH
8741: LD_EXP 1
8745: PUSH
8746: EMPTY
8747: LIST
8748: LIST
8749: PUSH
8750: LD_INT 2
8752: PUSH
8753: LD_INT 30
8755: PUSH
8756: LD_INT 6
8758: PUSH
8759: EMPTY
8760: LIST
8761: LIST
8762: PUSH
8763: LD_INT 30
8765: PUSH
8766: LD_INT 7
8768: PUSH
8769: EMPTY
8770: LIST
8771: LIST
8772: PUSH
8773: EMPTY
8774: LIST
8775: LIST
8776: LIST
8777: PUSH
8778: LD_INT 24
8780: PUSH
8781: LD_INT 1000
8783: PUSH
8784: EMPTY
8785: LIST
8786: LIST
8787: PUSH
8788: EMPTY
8789: LIST
8790: LIST
8791: LIST
8792: PPUSH
8793: CALL_OW 69
8797: PUSH
8798: LD_LOC 10
8802: AND
8803: IFFALSE 9071
8805: GO 8807
8807: DISABLE
8808: LD_INT 0
8810: PPUSH
8811: PPUSH
// begin un := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_male ] ] ) diff [ MacMillan , Burlak , Roth , Gossudarov , 0 ] ;
8812: LD_ADDR_VAR 0 1
8816: PUSH
8817: LD_INT 22
8819: PUSH
8820: LD_EXP 1
8824: PUSH
8825: EMPTY
8826: LIST
8827: LIST
8828: PUSH
8829: LD_INT 26
8831: PUSH
8832: LD_INT 1
8834: PUSH
8835: EMPTY
8836: LIST
8837: LIST
8838: PUSH
8839: EMPTY
8840: LIST
8841: LIST
8842: PPUSH
8843: CALL_OW 69
8847: PUSH
8848: LD_EXP 13
8852: PUSH
8853: LD_EXP 12
8857: PUSH
8858: LD_EXP 14
8862: PUSH
8863: LD_EXP 15
8867: PUSH
8868: LD_INT 0
8870: PUSH
8871: EMPTY
8872: LIST
8873: LIST
8874: LIST
8875: LIST
8876: LIST
8877: DIFF
8878: ST_TO_ADDR
// if un then
8879: LD_VAR 0 1
8883: IFFALSE 8903
// sci := FindMaxSkill ( un , skill_scientistic ) ;
8885: LD_ADDR_VAR 0 2
8889: PUSH
8890: LD_VAR 0 1
8894: PPUSH
8895: LD_INT 4
8897: PPUSH
8898: CALL_OW 433
8902: ST_TO_ADDR
// CenterOnUnits ( al_tower ) ;
8903: LD_INT 108
8905: PPUSH
8906: CALL_OW 85
// DialogueOn ;
8910: CALL_OW 6
// interface_hidden := true ;
8914: LD_ADDR_OWVAR 54
8918: PUSH
8919: LD_INT 1
8921: ST_TO_ADDR
// case camp of 4 :
8922: LD_EXP 7
8926: PUSH
8927: LD_INT 4
8929: DOUBLE
8930: EQUAL
8931: IFTRUE 8935
8933: GO 8975
8935: POP
// if IsOK ( Gossudarov ) then
8936: LD_EXP 15
8940: PPUSH
8941: CALL_OW 302
8945: IFFALSE 8961
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
8947: LD_EXP 15
8951: PPUSH
8952: LD_STRING DAlieBaseNotReady-Gos-1
8954: PPUSH
8955: CALL_OW 88
8959: GO 8973
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) ; 6 :
8961: LD_EXP 14
8965: PPUSH
8966: LD_STRING DAlieBaseNotReady-Roth-1
8968: PPUSH
8969: CALL_OW 88
8973: GO 9024
8975: LD_INT 6
8977: DOUBLE
8978: EQUAL
8979: IFTRUE 8983
8981: GO 9023
8983: POP
// if IsOK ( Roth ) then
8984: LD_EXP 14
8988: PPUSH
8989: CALL_OW 302
8993: IFFALSE 9009
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
8995: LD_EXP 14
8999: PPUSH
9000: LD_STRING DAlieBaseNotReady-Roth-1
9002: PPUSH
9003: CALL_OW 88
9007: GO 9021
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) ; end ;
9009: LD_EXP 15
9013: PPUSH
9014: LD_STRING DAlieBaseNotReady-Gos-1
9016: PPUSH
9017: CALL_OW 88
9021: GO 9024
9023: POP
// if not ( IsOK ( Gossudarov ) or IsOK ( Roth ) ) then
9024: LD_EXP 15
9028: PPUSH
9029: CALL_OW 302
9033: PUSH
9034: LD_EXP 14
9038: PPUSH
9039: CALL_OW 302
9043: OR
9044: NOT
9045: IFFALSE 9059
// Say ( sci , DAlieBaseNotReady-RSci1-1 ) ;
9047: LD_VAR 0 2
9051: PPUSH
9052: LD_STRING DAlieBaseNotReady-RSci1-1
9054: PPUSH
9055: CALL_OW 88
// interface_hidden := false ;
9059: LD_ADDR_OWVAR 54
9063: PUSH
9064: LD_INT 0
9066: ST_TO_ADDR
// DialogueOff ;
9067: CALL_OW 7
// end ;
9071: PPOPN 2
9073: END
// every 0 0$8.7 trigger GetTech ( tech_Artifact , you ) = state_researched do var un , lab , list ;
9074: LD_INT 24
9076: PPUSH
9077: LD_EXP 1
9081: PPUSH
9082: CALL_OW 321
9086: PUSH
9087: LD_INT 2
9089: EQUAL
9090: IFFALSE 9228
9092: GO 9094
9094: DISABLE
9095: LD_INT 0
9097: PPUSH
9098: PPUSH
9099: PPUSH
// begin list := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ;
9100: LD_ADDR_VAR 0 3
9104: PUSH
9105: LD_INT 22
9107: PUSH
9108: LD_EXP 1
9112: PUSH
9113: EMPTY
9114: LIST
9115: LIST
9116: PUSH
9117: LD_INT 2
9119: PUSH
9120: LD_INT 30
9122: PUSH
9123: LD_INT 6
9125: PUSH
9126: EMPTY
9127: LIST
9128: LIST
9129: PUSH
9130: LD_INT 30
9132: PUSH
9133: LD_INT 7
9135: PUSH
9136: EMPTY
9137: LIST
9138: LIST
9139: PUSH
9140: LD_INT 30
9142: PUSH
9143: LD_INT 8
9145: PUSH
9146: EMPTY
9147: LIST
9148: LIST
9149: PUSH
9150: EMPTY
9151: LIST
9152: LIST
9153: LIST
9154: LIST
9155: PUSH
9156: EMPTY
9157: LIST
9158: LIST
9159: PPUSH
9160: CALL_OW 69
9164: ST_TO_ADDR
// lab := false ;
9165: LD_ADDR_VAR 0 2
9169: PUSH
9170: LD_INT 0
9172: ST_TO_ADDR
// for un in list do
9173: LD_ADDR_VAR 0 1
9177: PUSH
9178: LD_VAR 0 3
9182: PUSH
9183: FOR_IN
9184: IFFALSE 9213
// if GetLives ( un ) = 1000 then
9186: LD_VAR 0 1
9190: PPUSH
9191: CALL_OW 256
9195: PUSH
9196: LD_INT 1000
9198: EQUAL
9199: IFFALSE 9211
// lab := un ;
9201: LD_ADDR_VAR 0 2
9205: PUSH
9206: LD_VAR 0 1
9210: ST_TO_ADDR
9211: GO 9183
9213: POP
9214: POP
// if lab then
9215: LD_VAR 0 2
9219: IFFALSE 9227
// begin Talking_About_Artefact ;
9221: CALL 9231 0 0
// exit ;
9225: GO 9228
// end ; enable ;
9227: ENABLE
// end ;
9228: PPOPN 3
9230: END
// export function Talking_About_Artefact ; var un , ru_sci , us_sci , your_depot ; begin
9231: LD_INT 0
9233: PPUSH
9234: PPUSH
9235: PPUSH
9236: PPUSH
9237: PPUSH
// un := FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_russian ] , [ f_sex , sex_male ] ] ) ;
9238: LD_ADDR_VAR 0 2
9242: PUSH
9243: LD_INT 22
9245: PUSH
9246: LD_EXP 1
9250: PUSH
9251: EMPTY
9252: LIST
9253: LIST
9254: PUSH
9255: LD_INT 23
9257: PUSH
9258: LD_INT 3
9260: PUSH
9261: EMPTY
9262: LIST
9263: LIST
9264: PUSH
9265: LD_INT 26
9267: PUSH
9268: LD_INT 1
9270: PUSH
9271: EMPTY
9272: LIST
9273: LIST
9274: PUSH
9275: EMPTY
9276: LIST
9277: LIST
9278: LIST
9279: PPUSH
9280: CALL_OW 69
9284: ST_TO_ADDR
// un := un diff [ MacMillan , Burlak , Roth , Gossudarov , 0 ] ;
9285: LD_ADDR_VAR 0 2
9289: PUSH
9290: LD_VAR 0 2
9294: PUSH
9295: LD_EXP 13
9299: PUSH
9300: LD_EXP 12
9304: PUSH
9305: LD_EXP 14
9309: PUSH
9310: LD_EXP 15
9314: PUSH
9315: LD_INT 0
9317: PUSH
9318: EMPTY
9319: LIST
9320: LIST
9321: LIST
9322: LIST
9323: LIST
9324: DIFF
9325: ST_TO_ADDR
// if un then
9326: LD_VAR 0 2
9330: IFFALSE 9350
// ru_sci := FindMaxSkill ( un , skill_scientistic ) ;
9332: LD_ADDR_VAR 0 3
9336: PUSH
9337: LD_VAR 0 2
9341: PPUSH
9342: LD_INT 4
9344: PPUSH
9345: CALL_OW 433
9349: ST_TO_ADDR
// un := FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_american ] , [ f_sex , sex_male ] ] ) ;
9350: LD_ADDR_VAR 0 2
9354: PUSH
9355: LD_INT 22
9357: PUSH
9358: LD_EXP 1
9362: PUSH
9363: EMPTY
9364: LIST
9365: LIST
9366: PUSH
9367: LD_INT 23
9369: PUSH
9370: LD_INT 1
9372: PUSH
9373: EMPTY
9374: LIST
9375: LIST
9376: PUSH
9377: LD_INT 26
9379: PUSH
9380: LD_INT 1
9382: PUSH
9383: EMPTY
9384: LIST
9385: LIST
9386: PUSH
9387: EMPTY
9388: LIST
9389: LIST
9390: LIST
9391: PPUSH
9392: CALL_OW 69
9396: ST_TO_ADDR
// un := un diff [ MacMillan , Burlak , Roth , Gossudarov , 0 ] ;
9397: LD_ADDR_VAR 0 2
9401: PUSH
9402: LD_VAR 0 2
9406: PUSH
9407: LD_EXP 13
9411: PUSH
9412: LD_EXP 12
9416: PUSH
9417: LD_EXP 14
9421: PUSH
9422: LD_EXP 15
9426: PUSH
9427: LD_INT 0
9429: PUSH
9430: EMPTY
9431: LIST
9432: LIST
9433: LIST
9434: LIST
9435: LIST
9436: DIFF
9437: ST_TO_ADDR
// if un then
9438: LD_VAR 0 2
9442: IFFALSE 9462
// us_sci := FindMaxSkill ( un , skill_scientistic ) ;
9444: LD_ADDR_VAR 0 4
9448: PUSH
9449: LD_VAR 0 2
9453: PPUSH
9454: LD_INT 4
9456: PPUSH
9457: CALL_OW 433
9461: ST_TO_ADDR
// un := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
9462: LD_ADDR_VAR 0 2
9466: PUSH
9467: LD_INT 22
9469: PUSH
9470: LD_EXP 1
9474: PUSH
9475: EMPTY
9476: LIST
9477: LIST
9478: PUSH
9479: LD_INT 2
9481: PUSH
9482: LD_INT 30
9484: PUSH
9485: LD_INT 0
9487: PUSH
9488: EMPTY
9489: LIST
9490: LIST
9491: PUSH
9492: LD_INT 30
9494: PUSH
9495: LD_INT 1
9497: PUSH
9498: EMPTY
9499: LIST
9500: LIST
9501: PUSH
9502: EMPTY
9503: LIST
9504: LIST
9505: LIST
9506: PUSH
9507: EMPTY
9508: LIST
9509: LIST
9510: PPUSH
9511: CALL_OW 69
9515: ST_TO_ADDR
// if un then
9516: LD_VAR 0 2
9520: IFFALSE 9536
// your_depot := un [ 1 ] ;
9522: LD_ADDR_VAR 0 5
9526: PUSH
9527: LD_VAR 0 2
9531: PUSH
9532: LD_INT 1
9534: ARRAY
9535: ST_TO_ADDR
// CenterOnUnits ( Burlak ) ;
9536: LD_EXP 12
9540: PPUSH
9541: CALL_OW 85
// DialogueOn ;
9545: CALL_OW 6
// interface_hidden := true ;
9549: LD_ADDR_OWVAR 54
9553: PUSH
9554: LD_INT 1
9556: ST_TO_ADDR
// Say ( ru_sci , DArtefTechnology-RSci1-1 ) ;
9557: LD_VAR 0 3
9561: PPUSH
9562: LD_STRING DArtefTechnology-RSci1-1
9564: PPUSH
9565: CALL_OW 88
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
9569: LD_EXP 12
9573: PPUSH
9574: LD_STRING DArtefTechnology-Bur-1
9576: PPUSH
9577: CALL_OW 88
// Say ( ru_sci , DArtefTechnology-RSci1-2 ) ;
9581: LD_VAR 0 3
9585: PPUSH
9586: LD_STRING DArtefTechnology-RSci1-2
9588: PPUSH
9589: CALL_OW 88
// Say ( us_sci , DArtefTechnology-Sci1-2 ) ;
9593: LD_VAR 0 4
9597: PPUSH
9598: LD_STRING DArtefTechnology-Sci1-2
9600: PPUSH
9601: CALL_OW 88
// case camp of 4 :
9605: LD_EXP 7
9609: PUSH
9610: LD_INT 4
9612: DOUBLE
9613: EQUAL
9614: IFTRUE 9618
9616: GO 9633
9618: POP
// Say ( MacMillan , DArtefTechnology-JMM-2 ) ; 6 :
9619: LD_EXP 13
9623: PPUSH
9624: LD_STRING DArtefTechnology-JMM-2
9626: PPUSH
9627: CALL_OW 88
9631: GO 9657
9633: LD_INT 6
9635: DOUBLE
9636: EQUAL
9637: IFTRUE 9641
9639: GO 9656
9641: POP
// Say ( Burlak , DArtefTechnology-Bur-2 ) ; end ;
9642: LD_EXP 12
9646: PPUSH
9647: LD_STRING DArtefTechnology-Bur-2
9649: PPUSH
9650: CALL_OW 88
9654: GO 9657
9656: POP
// Say ( ru_sci , DArtefTechnology-RSci1-3 ) ;
9657: LD_VAR 0 3
9661: PPUSH
9662: LD_STRING DArtefTechnology-RSci1-3
9664: PPUSH
9665: CALL_OW 88
// if GetDistUnits ( your_depot , al_tower ) < 30 then
9669: LD_VAR 0 5
9673: PPUSH
9674: LD_INT 108
9676: PPUSH
9677: CALL_OW 296
9681: PUSH
9682: LD_INT 30
9684: LESS
9685: IFFALSE 9701
// Say ( us_sci , DArtefTechnology-Sci1-3 ) else
9687: LD_VAR 0 4
9691: PPUSH
9692: LD_STRING DArtefTechnology-Sci1-3
9694: PPUSH
9695: CALL_OW 88
9699: GO 9713
// Say ( us_sci , DArtefTechnology-Sci1-3a ) ;
9701: LD_VAR 0 4
9705: PPUSH
9706: LD_STRING DArtefTechnology-Sci1-3a
9708: PPUSH
9709: CALL_OW 88
// interface_hidden := false ;
9713: LD_ADDR_OWVAR 54
9717: PUSH
9718: LD_INT 0
9720: ST_TO_ADDR
// DialogueOff ;
9721: CALL_OW 7
// end ; end_of_file
9725: LD_VAR 0 1
9729: RET
// export us_researched , ru_researched ; export one_enabled ; every 0 0$1.1 do var un , sci ;
9730: GO 9732
9732: DISABLE
9733: LD_INT 0
9735: PPUSH
9736: PPUSH
// begin exit ;
9737: GO 9983
// un := FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_american ] , [ f_sex , sex_male ] ] ) ;
9739: LD_ADDR_VAR 0 1
9743: PUSH
9744: LD_INT 22
9746: PUSH
9747: LD_EXP 1
9751: PUSH
9752: EMPTY
9753: LIST
9754: LIST
9755: PUSH
9756: LD_INT 23
9758: PUSH
9759: LD_INT 1
9761: PUSH
9762: EMPTY
9763: LIST
9764: LIST
9765: PUSH
9766: LD_INT 26
9768: PUSH
9769: LD_INT 1
9771: PUSH
9772: EMPTY
9773: LIST
9774: LIST
9775: PUSH
9776: EMPTY
9777: LIST
9778: LIST
9779: LIST
9780: PPUSH
9781: CALL_OW 69
9785: ST_TO_ADDR
// un := un diff [ MacMillan , Burlak , Roth , Gossudarov , 0 ] ;
9786: LD_ADDR_VAR 0 1
9790: PUSH
9791: LD_VAR 0 1
9795: PUSH
9796: LD_EXP 13
9800: PUSH
9801: LD_EXP 12
9805: PUSH
9806: LD_EXP 14
9810: PUSH
9811: LD_EXP 15
9815: PUSH
9816: LD_INT 0
9818: PUSH
9819: EMPTY
9820: LIST
9821: LIST
9822: LIST
9823: LIST
9824: LIST
9825: DIFF
9826: ST_TO_ADDR
// if un then
9827: LD_VAR 0 1
9831: IFFALSE 9851
// sci := FindMaxSkill ( un , skill_scientistic ) ;
9833: LD_ADDR_VAR 0 2
9837: PUSH
9838: LD_VAR 0 1
9842: PPUSH
9843: LD_INT 4
9845: PPUSH
9846: CALL_OW 433
9850: ST_TO_ADDR
// CenterOnUnits ( [ MacMillan , Burlak ] ) ;
9851: LD_EXP 13
9855: PUSH
9856: LD_EXP 12
9860: PUSH
9861: EMPTY
9862: LIST
9863: LIST
9864: PPUSH
9865: CALL_OW 85
// DialogueOn ;
9869: CALL_OW 6
// interface_hidden := true ;
9873: LD_ADDR_OWVAR 54
9877: PUSH
9878: LD_INT 1
9880: ST_TO_ADDR
// Say ( sci , DArtefTechnologyAm-Sci1-1 ) ;
9881: LD_VAR 0 2
9885: PPUSH
9886: LD_STRING DArtefTechnologyAm-Sci1-1
9888: PPUSH
9889: CALL_OW 88
// case camp of 4 :
9893: LD_EXP 7
9897: PUSH
9898: LD_INT 4
9900: DOUBLE
9901: EQUAL
9902: IFTRUE 9906
9904: GO 9921
9906: POP
// Say ( MacMillan , DArtefTechnologyAm-JMM-1 ) ; 6 :
9907: LD_EXP 13
9911: PPUSH
9912: LD_STRING DArtefTechnologyAm-JMM-1
9914: PPUSH
9915: CALL_OW 88
9919: GO 9945
9921: LD_INT 6
9923: DOUBLE
9924: EQUAL
9925: IFTRUE 9929
9927: GO 9944
9929: POP
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ; end ;
9930: LD_EXP 12
9934: PPUSH
9935: LD_STRING DArtefTechnologyAm-Bur-1
9937: PPUSH
9938: CALL_OW 88
9942: GO 9945
9944: POP
// interface_hidden := false ;
9945: LD_ADDR_OWVAR 54
9949: PUSH
9950: LD_INT 0
9952: ST_TO_ADDR
// DialogueOff ;
9953: CALL_OW 7
// if not one_enabled then
9957: LD_EXP 65
9961: NOT
9962: IFFALSE 9975
// begin enable ( 1 ) ;
9964: LD_INT 1
9966: ENABLE_MARKED
// one_enabled := true ;
9967: LD_ADDR_EXP 65
9971: PUSH
9972: LD_INT 1
9974: ST_TO_ADDR
// end ; us_researched := true ;
9975: LD_ADDR_EXP 63
9979: PUSH
9980: LD_INT 1
9982: ST_TO_ADDR
// end ;
9983: PPOPN 2
9985: END
// every 0 0$1.3 do var un , sci ;
9986: GO 9988
9988: DISABLE
9989: LD_INT 0
9991: PPUSH
9992: PPUSH
// begin exit ;
9993: GO 10251
// un := FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_russian ] , [ f_sex , sex_male ] ] ) ;
9995: LD_ADDR_VAR 0 1
9999: PUSH
10000: LD_INT 22
10002: PUSH
10003: LD_EXP 1
10007: PUSH
10008: EMPTY
10009: LIST
10010: LIST
10011: PUSH
10012: LD_INT 23
10014: PUSH
10015: LD_INT 3
10017: PUSH
10018: EMPTY
10019: LIST
10020: LIST
10021: PUSH
10022: LD_INT 26
10024: PUSH
10025: LD_INT 1
10027: PUSH
10028: EMPTY
10029: LIST
10030: LIST
10031: PUSH
10032: EMPTY
10033: LIST
10034: LIST
10035: LIST
10036: PPUSH
10037: CALL_OW 69
10041: ST_TO_ADDR
// un := un diff [ MacMillan , Burlak , Roth , Gossudarov , 0 ] ;
10042: LD_ADDR_VAR 0 1
10046: PUSH
10047: LD_VAR 0 1
10051: PUSH
10052: LD_EXP 13
10056: PUSH
10057: LD_EXP 12
10061: PUSH
10062: LD_EXP 14
10066: PUSH
10067: LD_EXP 15
10071: PUSH
10072: LD_INT 0
10074: PUSH
10075: EMPTY
10076: LIST
10077: LIST
10078: LIST
10079: LIST
10080: LIST
10081: DIFF
10082: ST_TO_ADDR
// if un then
10083: LD_VAR 0 1
10087: IFFALSE 10107
// sci := FindMaxSkill ( un , skill_scientistic ) ;
10089: LD_ADDR_VAR 0 2
10093: PUSH
10094: LD_VAR 0 1
10098: PPUSH
10099: LD_INT 4
10101: PPUSH
10102: CALL_OW 433
10106: ST_TO_ADDR
// CenterOnUnits ( [ MacMillan , sci ] ) ;
10107: LD_EXP 13
10111: PUSH
10112: LD_VAR 0 2
10116: PUSH
10117: EMPTY
10118: LIST
10119: LIST
10120: PPUSH
10121: CALL_OW 85
// DialogueOn ;
10125: CALL_OW 6
// interface_hidden := true ;
10129: LD_ADDR_OWVAR 54
10133: PUSH
10134: LD_INT 1
10136: ST_TO_ADDR
// Say ( sci , DArtefTechnologyRu-RSci1-1 ) ;
10137: LD_VAR 0 2
10141: PPUSH
10142: LD_STRING DArtefTechnologyRu-RSci1-1
10144: PPUSH
10145: CALL_OW 88
// case camp of 4 :
10149: LD_EXP 7
10153: PUSH
10154: LD_INT 4
10156: DOUBLE
10157: EQUAL
10158: IFTRUE 10162
10160: GO 10177
10162: POP
// Say ( MacMillan , DArtefTechnologyRu-JMM-1 ) ; 6 :
10163: LD_EXP 13
10167: PPUSH
10168: LD_STRING DArtefTechnologyRu-JMM-1
10170: PPUSH
10171: CALL_OW 88
10175: GO 10201
10177: LD_INT 6
10179: DOUBLE
10180: EQUAL
10181: IFTRUE 10185
10183: GO 10200
10185: POP
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ; end ;
10186: LD_EXP 12
10190: PPUSH
10191: LD_STRING DArtefTechnologyRu-Bur-1
10193: PPUSH
10194: CALL_OW 88
10198: GO 10201
10200: POP
// Say ( sci , DArtefTechnologyRu-RSci1-2 ) ;
10201: LD_VAR 0 2
10205: PPUSH
10206: LD_STRING DArtefTechnologyRu-RSci1-2
10208: PPUSH
10209: CALL_OW 88
// interface_hidden := false ;
10213: LD_ADDR_OWVAR 54
10217: PUSH
10218: LD_INT 0
10220: ST_TO_ADDR
// DialogueOff ;
10221: CALL_OW 7
// if not one_enabled then
10225: LD_EXP 65
10229: NOT
10230: IFFALSE 10243
// begin enable ( 1 ) ;
10232: LD_INT 1
10234: ENABLE_MARKED
// one_enabled := true ;
10235: LD_ADDR_EXP 65
10239: PUSH
10240: LD_INT 1
10242: ST_TO_ADDR
// end ; ru_researched := true ;
10243: LD_ADDR_EXP 64
10247: PUSH
10248: LD_INT 1
10250: ST_TO_ADDR
// end ;
10251: PPOPN 2
10253: END
// every 0 0$5.3 trigger ( GetSide ( al_tower ) = you ) and ( GetTag ( 81 ) or GetTag ( 181 ) ) marked 1 do var un , sci ;
10254: LD_INT 108
10256: PPUSH
10257: CALL_OW 255
10261: PUSH
10262: LD_EXP 1
10266: EQUAL
10267: PUSH
10268: LD_INT 81
10270: PPUSH
10271: CALL_OW 110
10275: PUSH
10276: LD_INT 181
10278: PPUSH
10279: CALL_OW 110
10283: OR
10284: AND
10285: IFFALSE 10529
10287: GO 10289
10289: DISABLE
10290: LD_INT 0
10292: PPUSH
10293: PPUSH
// begin un := [ ] ;
10294: LD_ADDR_VAR 0 1
10298: PUSH
10299: EMPTY
10300: ST_TO_ADDR
// if us_researched then
10301: LD_EXP 63
10305: IFFALSE 10360
// un := un ^ FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_american ] , [ f_sex , sex_male ] ] ) ;
10307: LD_ADDR_VAR 0 1
10311: PUSH
10312: LD_VAR 0 1
10316: PUSH
10317: LD_INT 22
10319: PUSH
10320: LD_EXP 1
10324: PUSH
10325: EMPTY
10326: LIST
10327: LIST
10328: PUSH
10329: LD_INT 23
10331: PUSH
10332: LD_INT 1
10334: PUSH
10335: EMPTY
10336: LIST
10337: LIST
10338: PUSH
10339: LD_INT 26
10341: PUSH
10342: LD_INT 1
10344: PUSH
10345: EMPTY
10346: LIST
10347: LIST
10348: PUSH
10349: EMPTY
10350: LIST
10351: LIST
10352: LIST
10353: PPUSH
10354: CALL_OW 69
10358: ADD
10359: ST_TO_ADDR
// if ru_researched then
10360: LD_EXP 64
10364: IFFALSE 10419
// un := un ^ FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_russian ] , [ f_sex , sex_male ] ] ) ;
10366: LD_ADDR_VAR 0 1
10370: PUSH
10371: LD_VAR 0 1
10375: PUSH
10376: LD_INT 22
10378: PUSH
10379: LD_EXP 1
10383: PUSH
10384: EMPTY
10385: LIST
10386: LIST
10387: PUSH
10388: LD_INT 23
10390: PUSH
10391: LD_INT 3
10393: PUSH
10394: EMPTY
10395: LIST
10396: LIST
10397: PUSH
10398: LD_INT 26
10400: PUSH
10401: LD_INT 1
10403: PUSH
10404: EMPTY
10405: LIST
10406: LIST
10407: PUSH
10408: EMPTY
10409: LIST
10410: LIST
10411: LIST
10412: PPUSH
10413: CALL_OW 69
10417: ADD
10418: ST_TO_ADDR
// un := un diff [ MacMillan , Burlak , Roth , Gossudarov , 0 ] ;
10419: LD_ADDR_VAR 0 1
10423: PUSH
10424: LD_VAR 0 1
10428: PUSH
10429: LD_EXP 13
10433: PUSH
10434: LD_EXP 12
10438: PUSH
10439: LD_EXP 14
10443: PUSH
10444: LD_EXP 15
10448: PUSH
10449: LD_INT 0
10451: PUSH
10452: EMPTY
10453: LIST
10454: LIST
10455: LIST
10456: LIST
10457: LIST
10458: DIFF
10459: ST_TO_ADDR
// if un then
10460: LD_VAR 0 1
10464: IFFALSE 10484
// sci := FindMaxSkill ( un , skill_scientistic ) ;
10466: LD_ADDR_VAR 0 2
10470: PUSH
10471: LD_VAR 0 1
10475: PPUSH
10476: LD_INT 4
10478: PPUSH
10479: CALL_OW 433
10483: ST_TO_ADDR
// CenterOnUnits ( sci ) ;
10484: LD_VAR 0 2
10488: PPUSH
10489: CALL_OW 85
// DialogueOn ;
10493: CALL_OW 6
// interface_hidden := true ;
10497: LD_ADDR_OWVAR 54
10501: PUSH
10502: LD_INT 1
10504: ST_TO_ADDR
// Say ( sci , DArtefTechnologyArStart-Sci1-1 ) ;
10505: LD_VAR 0 2
10509: PPUSH
10510: LD_STRING DArtefTechnologyArStart-Sci1-1
10512: PPUSH
10513: CALL_OW 88
// interface_hidden := false ;
10517: LD_ADDR_OWVAR 54
10521: PUSH
10522: LD_INT 0
10524: ST_TO_ADDR
// DialogueOff ;
10525: CALL_OW 7
// end ;
10529: PPOPN 2
10531: END
// every 0 0$3.9 trigger GetTag ( 281 ) do var un , sci ;
10532: LD_INT 281
10534: PPUSH
10535: CALL_OW 110
10539: IFFALSE 10900
10541: GO 10543
10543: DISABLE
10544: LD_INT 0
10546: PPUSH
10547: PPUSH
// begin un := FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_russian ] , [ f_sex , sex_male ] ] ) ;
10548: LD_ADDR_VAR 0 1
10552: PUSH
10553: LD_INT 22
10555: PUSH
10556: LD_EXP 1
10560: PUSH
10561: EMPTY
10562: LIST
10563: LIST
10564: PUSH
10565: LD_INT 23
10567: PUSH
10568: LD_INT 3
10570: PUSH
10571: EMPTY
10572: LIST
10573: LIST
10574: PUSH
10575: LD_INT 26
10577: PUSH
10578: LD_INT 1
10580: PUSH
10581: EMPTY
10582: LIST
10583: LIST
10584: PUSH
10585: EMPTY
10586: LIST
10587: LIST
10588: LIST
10589: PPUSH
10590: CALL_OW 69
10594: ST_TO_ADDR
// un := un diff [ MacMillan , Burlak , Roth , Gossudarov , 0 ] ;
10595: LD_ADDR_VAR 0 1
10599: PUSH
10600: LD_VAR 0 1
10604: PUSH
10605: LD_EXP 13
10609: PUSH
10610: LD_EXP 12
10614: PUSH
10615: LD_EXP 14
10619: PUSH
10620: LD_EXP 15
10624: PUSH
10625: LD_INT 0
10627: PUSH
10628: EMPTY
10629: LIST
10630: LIST
10631: LIST
10632: LIST
10633: LIST
10634: DIFF
10635: ST_TO_ADDR
// if un then
10636: LD_VAR 0 1
10640: IFFALSE 10662
// sci := FindMaxSkill ( un , skill_scientistic ) else
10642: LD_ADDR_VAR 0 2
10646: PUSH
10647: LD_VAR 0 1
10651: PPUSH
10652: LD_INT 4
10654: PPUSH
10655: CALL_OW 433
10659: ST_TO_ADDR
10660: GO 10664
// exit ;
10662: GO 10900
// CenterOnUnits ( [ MacMillan , Burlak , sci ] ) ;
10664: LD_EXP 13
10668: PUSH
10669: LD_EXP 12
10673: PUSH
10674: LD_VAR 0 2
10678: PUSH
10679: EMPTY
10680: LIST
10681: LIST
10682: LIST
10683: PPUSH
10684: CALL_OW 85
// DialogueOn ;
10688: CALL_OW 6
// interface_hidden := true ;
10692: LD_ADDR_OWVAR 54
10696: PUSH
10697: LD_INT 1
10699: ST_TO_ADDR
// Say ( sci , DArtefTechnologyAr-RSci1-1 ) ;
10700: LD_VAR 0 2
10704: PPUSH
10705: LD_STRING DArtefTechnologyAr-RSci1-1
10707: PPUSH
10708: CALL_OW 88
// case camp of 4 :
10712: LD_EXP 7
10716: PUSH
10717: LD_INT 4
10719: DOUBLE
10720: EQUAL
10721: IFTRUE 10725
10723: GO 10740
10725: POP
// Say ( MacMillan , DArtefTechnologyAr-JMM-1 ) ; 6 :
10726: LD_EXP 13
10730: PPUSH
10731: LD_STRING DArtefTechnologyAr-JMM-1
10733: PPUSH
10734: CALL_OW 88
10738: GO 10764
10740: LD_INT 6
10742: DOUBLE
10743: EQUAL
10744: IFTRUE 10748
10746: GO 10763
10748: POP
// Say ( Burlak , DArtefTechnologyAr-Bur-1 ) ; end ;
10749: LD_EXP 12
10753: PPUSH
10754: LD_STRING DArtefTechnologyAr-Bur-1
10756: PPUSH
10757: CALL_OW 88
10761: GO 10764
10763: POP
// Say ( sci , DArtefTechnologyAr-RSci1-2 ) ;
10764: LD_VAR 0 2
10768: PPUSH
10769: LD_STRING DArtefTechnologyAr-RSci1-2
10771: PPUSH
10772: CALL_OW 88
// case camp of 4 :
10776: LD_EXP 7
10780: PUSH
10781: LD_INT 4
10783: DOUBLE
10784: EQUAL
10785: IFTRUE 10789
10787: GO 10804
10789: POP
// Say ( MacMillan , DArtefTechnologyAr-JMM-2 ) ; 6 :
10790: LD_EXP 13
10794: PPUSH
10795: LD_STRING DArtefTechnologyAr-JMM-2
10797: PPUSH
10798: CALL_OW 88
10802: GO 10828
10804: LD_INT 6
10806: DOUBLE
10807: EQUAL
10808: IFTRUE 10812
10810: GO 10827
10812: POP
// Say ( Burlak , DArtefTechnologyAr-Bur-2 ) ; end ;
10813: LD_EXP 12
10817: PPUSH
10818: LD_STRING DArtefTechnologyAr-Bur-2
10820: PPUSH
10821: CALL_OW 88
10825: GO 10828
10827: POP
// Say ( sci , DArtefTechnologyAr-RSci1-3 ) ;
10828: LD_VAR 0 2
10832: PPUSH
10833: LD_STRING DArtefTechnologyAr-RSci1-3
10835: PPUSH
10836: CALL_OW 88
// Say ( MacMillan , DArtefTechnologyAr-JMM-3 ) ;
10840: LD_EXP 13
10844: PPUSH
10845: LD_STRING DArtefTechnologyAr-JMM-3
10847: PPUSH
10848: CALL_OW 88
// Say ( sci , DArtefTechnologyAr-RSci1-4 ) ;
10852: LD_VAR 0 2
10856: PPUSH
10857: LD_STRING DArtefTechnologyAr-RSci1-4
10859: PPUSH
10860: CALL_OW 88
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
10864: LD_EXP 12
10868: PPUSH
10869: LD_STRING DArtefTechnologyAr-Bur-4
10871: PPUSH
10872: CALL_OW 88
// Say ( MacMillan , DArtefTechnologyAr-JMM-4 ) ;
10876: LD_EXP 13
10880: PPUSH
10881: LD_STRING DArtefTechnologyAr-JMM-4
10883: PPUSH
10884: CALL_OW 88
// interface_hidden := false ;
10888: LD_ADDR_OWVAR 54
10892: PUSH
10893: LD_INT 0
10895: ST_TO_ADDR
// DialogueOff ;
10896: CALL_OW 7
// end ; end_of_file
10900: PPOPN 2
10902: END
// export omar_in_contact ; var sib_list ; every 0 0$2 + 0 0$0.4 trigger FilterAllUnits ( [ [ f_side , ar ] , [ f_type , unit_human ] , [ f_ok ] ] ) = 0 marked 2 do var answer ;
10903: LD_INT 22
10905: PUSH
10906: LD_EXP 4
10910: PUSH
10911: EMPTY
10912: LIST
10913: LIST
10914: PUSH
10915: LD_INT 21
10917: PUSH
10918: LD_INT 1
10920: PUSH
10921: EMPTY
10922: LIST
10923: LIST
10924: PUSH
10925: LD_INT 50
10927: PUSH
10928: EMPTY
10929: LIST
10930: PUSH
10931: EMPTY
10932: LIST
10933: LIST
10934: LIST
10935: PPUSH
10936: CALL_OW 69
10940: PUSH
10941: LD_INT 0
10943: EQUAL
10944: IFFALSE 11375
10946: GO 10948
10948: DISABLE
10949: LD_INT 0
10951: PPUSH
// begin Omar_Arrive ;
10952: CALL 11378 0 0
// CenterOnUnits ( Omar ) ;
10956: LD_EXP 53
10960: PPUSH
10961: CALL_OW 85
// DialogueOn ;
10965: CALL_OW 6
// interface_hidden := true ;
10969: LD_ADDR_OWVAR 54
10973: PUSH
10974: LD_INT 1
10976: ST_TO_ADDR
// Say ( Omar , DOmar-Omar-1 ) ;
10977: LD_EXP 53
10981: PPUSH
10982: LD_STRING DOmar-Omar-1
10984: PPUSH
10985: CALL_OW 88
// case camp of 4 :
10989: LD_EXP 7
10993: PUSH
10994: LD_INT 4
10996: DOUBLE
10997: EQUAL
10998: IFTRUE 11002
11000: GO 11017
11002: POP
// Say ( MacMillan , DOmar-JMM-1 ) ; 6 :
11003: LD_EXP 13
11007: PPUSH
11008: LD_STRING DOmar-JMM-1
11010: PPUSH
11011: CALL_OW 88
11015: GO 11041
11017: LD_INT 6
11019: DOUBLE
11020: EQUAL
11021: IFTRUE 11025
11023: GO 11040
11025: POP
// Say ( Burlak , DOmar-Bur-1 ) ; end ;
11026: LD_EXP 12
11030: PPUSH
11031: LD_STRING DOmar-Bur-1
11033: PPUSH
11034: CALL_OW 88
11038: GO 11041
11040: POP
// Say ( Omar , DOmar-Omar-2 ) ;
11041: LD_EXP 53
11045: PPUSH
11046: LD_STRING DOmar-Omar-2
11048: PPUSH
11049: CALL_OW 88
// case camp of 4 :
11053: LD_EXP 7
11057: PUSH
11058: LD_INT 4
11060: DOUBLE
11061: EQUAL
11062: IFTRUE 11066
11064: GO 11081
11066: POP
// Say ( MacMillan , DOmar-JMM-2 ) ; 6 :
11067: LD_EXP 13
11071: PPUSH
11072: LD_STRING DOmar-JMM-2
11074: PPUSH
11075: CALL_OW 88
11079: GO 11105
11081: LD_INT 6
11083: DOUBLE
11084: EQUAL
11085: IFTRUE 11089
11087: GO 11104
11089: POP
// Say ( Burlak , DOmar-Bur-2 ) ; end ;
11090: LD_EXP 12
11094: PPUSH
11095: LD_STRING DOmar-Bur-2
11097: PPUSH
11098: CALL_OW 88
11102: GO 11105
11104: POP
// Say ( Omar , DOmar-Omar-3 ) ;
11105: LD_EXP 53
11109: PPUSH
11110: LD_STRING DOmar-Omar-3
11112: PPUSH
11113: CALL_OW 88
// case camp of 4 :
11117: LD_EXP 7
11121: PUSH
11122: LD_INT 4
11124: DOUBLE
11125: EQUAL
11126: IFTRUE 11130
11128: GO 11145
11130: POP
// Say ( MacMillan , DOmar-JMM-3 ) ; 6 :
11131: LD_EXP 13
11135: PPUSH
11136: LD_STRING DOmar-JMM-3
11138: PPUSH
11139: CALL_OW 88
11143: GO 11169
11145: LD_INT 6
11147: DOUBLE
11148: EQUAL
11149: IFTRUE 11153
11151: GO 11168
11153: POP
// Say ( Burlak , DOmar-Bur-3 ) ; end ;
11154: LD_EXP 12
11158: PPUSH
11159: LD_STRING DOmar-Bur-3
11161: PPUSH
11162: CALL_OW 88
11166: GO 11169
11168: POP
// Say ( Omar , DOmar-Omar-4 ) ;
11169: LD_EXP 53
11173: PPUSH
11174: LD_STRING DOmar-Omar-4
11176: PPUSH
11177: CALL_OW 88
// answer = Query ( QAccept ) ;
11181: LD_ADDR_VAR 0 1
11185: PUSH
11186: LD_STRING QAccept
11188: PPUSH
11189: CALL_OW 97
11193: ST_TO_ADDR
// case answer of 1 :
11194: LD_VAR 0 1
11198: PUSH
11199: LD_INT 1
11201: DOUBLE
11202: EQUAL
11203: IFTRUE 11207
11205: GO 11285
11207: POP
// begin case camp of 4 :
11208: LD_EXP 7
11212: PUSH
11213: LD_INT 4
11215: DOUBLE
11216: EQUAL
11217: IFTRUE 11221
11219: GO 11236
11221: POP
// Say ( MacMillan , DQrAccept#1-JMM-1 ) ; 6 :
11222: LD_EXP 13
11226: PPUSH
11227: LD_STRING DQrAccept#1-JMM-1
11229: PPUSH
11230: CALL_OW 88
11234: GO 11260
11236: LD_INT 6
11238: DOUBLE
11239: EQUAL
11240: IFTRUE 11244
11242: GO 11259
11244: POP
// Say ( Burlak , DQrAccept#1-Bur-1 ) ; end ;
11245: LD_EXP 12
11249: PPUSH
11250: LD_STRING DQrAccept#1-Bur-1
11252: PPUSH
11253: CALL_OW 88
11257: GO 11260
11259: POP
// SetSide ( Omar , you ) ;
11260: LD_EXP 53
11264: PPUSH
11265: LD_EXP 1
11269: PPUSH
11270: CALL_OW 235
// ComStop ( Omar ) ;
11274: LD_EXP 53
11278: PPUSH
11279: CALL_OW 141
// end ; 2 :
11283: GO 11349
11285: LD_INT 2
11287: DOUBLE
11288: EQUAL
11289: IFTRUE 11293
11291: GO 11348
11293: POP
// begin case camp of 4 :
11294: LD_EXP 7
11298: PUSH
11299: LD_INT 4
11301: DOUBLE
11302: EQUAL
11303: IFTRUE 11307
11305: GO 11322
11307: POP
// Say ( MacMillan , DQrAccept#2-JMM-1 ) ; 6 :
11308: LD_EXP 13
11312: PPUSH
11313: LD_STRING DQrAccept#2-JMM-1
11315: PPUSH
11316: CALL_OW 88
11320: GO 11346
11322: LD_INT 6
11324: DOUBLE
11325: EQUAL
11326: IFTRUE 11330
11328: GO 11345
11330: POP
// Say ( Burlak , DQrAccept#2-Bur-1 ) ; end ;
11331: LD_EXP 12
11335: PPUSH
11336: LD_STRING DQrAccept#2-Bur-1
11338: PPUSH
11339: CALL_OW 88
11343: GO 11346
11345: POP
// end ; end ;
11346: GO 11349
11348: POP
// interface_hidden := false ;
11349: LD_ADDR_OWVAR 54
11353: PUSH
11354: LD_INT 0
11356: ST_TO_ADDR
// DialogueOff ;
11357: CALL_OW 7
// if answer = 2 then
11361: LD_VAR 0 1
11365: PUSH
11366: LD_INT 2
11368: EQUAL
11369: IFFALSE 11375
// Omar_Leave ;
11371: CALL 11427 0 0
// end ;
11375: PPOPN 1
11377: END
// function Omar_Arrive ; var un ; begin
11378: LD_INT 0
11380: PPUSH
11381: PPUSH
// PlaceUnitArea ( Omar , omar_place , false ) ;
11382: LD_EXP 53
11386: PPUSH
11387: LD_INT 4
11389: PPUSH
11390: LD_INT 0
11392: PPUSH
11393: CALL_OW 49
// repeat ComMoveToArea ( Omar , teleport_area ) ;
11397: LD_EXP 53
11401: PPUSH
11402: LD_INT 24
11404: PPUSH
11405: CALL_OW 113
// wait ( 0 0$1 ) ;
11409: LD_INT 35
11411: PPUSH
11412: CALL_OW 67
// until omar_in_contact ;
11416: LD_EXP 66
11420: IFFALSE 11397
// end ;
11422: LD_VAR 0 1
11426: RET
// function Omar_Leave ; begin
11427: LD_INT 0
11429: PPUSH
// repeat ComMoveToArea ( Omar , omar_place ) ;
11430: LD_EXP 53
11434: PPUSH
11435: LD_INT 4
11437: PPUSH
11438: CALL_OW 113
// wait ( 0 0$1 ) ;
11442: LD_INT 35
11444: PPUSH
11445: CALL_OW 67
// until IsInArea ( Omar , omar_place ) ;
11449: LD_EXP 53
11453: PPUSH
11454: LD_INT 4
11456: PPUSH
11457: CALL_OW 308
11461: IFFALSE 11430
// RemoveUnit ( Omar ) ;
11463: LD_EXP 53
11467: PPUSH
11468: CALL_OW 64
// end ;
11472: LD_VAR 0 1
11476: RET
// every 0 0$3.7 trigger OmarWillTryContaminateMotherlode and ( FilterAllUnits ( [ [ f_side , ru ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) = 0 or finalize = 2 ) do var best_sib , see_him ;
11477: LD_EXP 56
11481: PUSH
11482: LD_INT 22
11484: PUSH
11485: LD_EXP 2
11489: PUSH
11490: EMPTY
11491: LIST
11492: LIST
11493: PUSH
11494: LD_INT 2
11496: PUSH
11497: LD_INT 30
11499: PUSH
11500: LD_INT 0
11502: PUSH
11503: EMPTY
11504: LIST
11505: LIST
11506: PUSH
11507: LD_INT 30
11509: PUSH
11510: LD_INT 1
11512: PUSH
11513: EMPTY
11514: LIST
11515: LIST
11516: PUSH
11517: EMPTY
11518: LIST
11519: LIST
11520: LIST
11521: PUSH
11522: EMPTY
11523: LIST
11524: LIST
11525: PPUSH
11526: CALL_OW 69
11530: PUSH
11531: LD_INT 0
11533: EQUAL
11534: PUSH
11535: LD_EXP 60
11539: PUSH
11540: LD_INT 2
11542: EQUAL
11543: OR
11544: AND
11545: IFFALSE 11695
11547: GO 11549
11549: DISABLE
11550: LD_INT 0
11552: PPUSH
11553: PPUSH
// begin sib_list := get_sib_list ;
11554: LD_ADDR_LOC 11
11558: PUSH
11559: CALL 11940 0 0
11563: ST_TO_ADDR
// SetClass ( Omar , class_scientistic ) ;
11564: LD_EXP 53
11568: PPUSH
11569: LD_INT 4
11571: PPUSH
11572: CALL_OW 336
// PlaceUnitArea ( Omar , omar_infested , false ) ;
11576: LD_EXP 53
11580: PPUSH
11581: LD_INT 5
11583: PPUSH
11584: LD_INT 0
11586: PPUSH
11587: CALL_OW 49
// see_him := false ;
11591: LD_ADDR_VAR 0 2
11595: PUSH
11596: LD_INT 0
11598: ST_TO_ADDR
// repeat best_sib := get_best_sib ( sib_list ) ;
11599: LD_ADDR_VAR 0 1
11603: PUSH
11604: LD_LOC 11
11608: PPUSH
11609: CALL 12080 0 1
11613: ST_TO_ADDR
// ComContaminate ( Omar , best_sib [ 1 ] , best_sib [ 2 ] ) ;
11614: LD_EXP 53
11618: PPUSH
11619: LD_VAR 0 1
11623: PUSH
11624: LD_INT 1
11626: ARRAY
11627: PPUSH
11628: LD_VAR 0 1
11632: PUSH
11633: LD_INT 2
11635: ARRAY
11636: PPUSH
11637: CALL_OW 158
// if ( not see_him ) and See ( you , Omar ) then
11641: LD_VAR 0 2
11645: NOT
11646: PUSH
11647: LD_EXP 1
11651: PPUSH
11652: LD_EXP 53
11656: PPUSH
11657: CALL_OW 292
11661: AND
11662: IFFALSE 11676
// begin talking_to_omar ;
11664: CALL 11698 0 0
// see_him := true ;
11668: LD_ADDR_VAR 0 2
11672: PUSH
11673: LD_INT 1
11675: ST_TO_ADDR
// end ; wait ( 0 0$1 ) ;
11676: LD_INT 35
11678: PPUSH
11679: CALL_OW 67
// until not IsLive ( Omar ) ;
11683: LD_EXP 53
11687: PPUSH
11688: CALL_OW 300
11692: NOT
11693: IFFALSE 11599
// end ;
11695: PPOPN 2
11697: END
// function talking_to_omar ; begin
11698: LD_INT 0
11700: PPUSH
// CenterOnUnits ( Omar ) ;
11701: LD_EXP 53
11705: PPUSH
11706: CALL_OW 85
// DialogueOn ;
11710: CALL_OW 6
// interface_hidden := true ;
11714: LD_ADDR_OWVAR 54
11718: PUSH
11719: LD_INT 1
11721: ST_TO_ADDR
// case camp of 4 :
11722: LD_EXP 7
11726: PUSH
11727: LD_INT 4
11729: DOUBLE
11730: EQUAL
11731: IFTRUE 11735
11733: GO 11750
11735: POP
// Say ( MacMillan , DOmarContam-JMM-1 ) ; 6 :
11736: LD_EXP 13
11740: PPUSH
11741: LD_STRING DOmarContam-JMM-1
11743: PPUSH
11744: CALL_OW 88
11748: GO 11774
11750: LD_INT 6
11752: DOUBLE
11753: EQUAL
11754: IFTRUE 11758
11756: GO 11773
11758: POP
// Say ( Burlak , DOmarContam-Bur-1 ) ; end ;
11759: LD_EXP 12
11763: PPUSH
11764: LD_STRING DOmarContam-Bur-1
11766: PPUSH
11767: CALL_OW 88
11771: GO 11774
11773: POP
// Say ( Omar , DOmarContam-Omar-1 ) ;
11774: LD_EXP 53
11778: PPUSH
11779: LD_STRING DOmarContam-Omar-1
11781: PPUSH
11782: CALL_OW 88
// case camp of 4 :
11786: LD_EXP 7
11790: PUSH
11791: LD_INT 4
11793: DOUBLE
11794: EQUAL
11795: IFTRUE 11799
11797: GO 11814
11799: POP
// Say ( MacMillan , DOmarContam-JMM-2 ) ; 6 :
11800: LD_EXP 13
11804: PPUSH
11805: LD_STRING DOmarContam-JMM-2
11807: PPUSH
11808: CALL_OW 88
11812: GO 11838
11814: LD_INT 6
11816: DOUBLE
11817: EQUAL
11818: IFTRUE 11822
11820: GO 11837
11822: POP
// Say ( Burlak , DOmarContam-Bur-2 ) ; end ;
11823: LD_EXP 12
11827: PPUSH
11828: LD_STRING DOmarContam-Bur-2
11830: PPUSH
11831: CALL_OW 88
11835: GO 11838
11837: POP
// interface_hidden := false ;
11838: LD_ADDR_OWVAR 54
11842: PUSH
11843: LD_INT 0
11845: ST_TO_ADDR
// DialogueOff ;
11846: CALL_OW 7
// end ;
11850: LD_VAR 0 1
11854: RET
// on SibDepositContaminated ( sib , x , y ) do var list , un ;
11855: LD_INT 0
11857: PPUSH
11858: PPUSH
// begin InGameOn ;
11859: CALL_OW 8
// CenterOnXY ( x , y ) ;
11863: LD_VAR 0 2
11867: PPUSH
11868: LD_VAR 0 3
11872: PPUSH
11873: CALL_OW 84
// PlaceSeeing ( x , y , you , - 10 ) ;
11877: LD_VAR 0 2
11881: PPUSH
11882: LD_VAR 0 3
11886: PPUSH
11887: LD_EXP 1
11891: PPUSH
11892: LD_INT 10
11894: NEG
11895: PPUSH
11896: CALL_OW 330
// wait ( 0 0$7 ) ;
11900: LD_INT 245
11902: PPUSH
11903: CALL_OW 67
// Mission_Failed ( 5 ) ;
11907: LD_INT 5
11909: PPUSH
11910: CALL 14164 0 1
// RemoveSeeing ( x , y , you ) ;
11914: LD_VAR 0 2
11918: PPUSH
11919: LD_VAR 0 3
11923: PPUSH
11924: LD_EXP 1
11928: PPUSH
11929: CALL_OW 331
// InGameOff ;
11933: CALL_OW 9
// end ;
11937: PPOPN 5
11939: END
// function get_sib_list ; var list , un , vysledek ; begin
11940: LD_INT 0
11942: PPUSH
11943: PPUSH
11944: PPUSH
11945: PPUSH
// vysledek := [ ] ;
11946: LD_ADDR_VAR 0 4
11950: PUSH
11951: EMPTY
11952: ST_TO_ADDR
// list := GetListOfResourcesInArea ( ru_base ) ;
11953: LD_ADDR_VAR 0 2
11957: PUSH
11958: LD_INT 12
11960: PPUSH
11961: CALL_OW 442
11965: ST_TO_ADDR
// for un = 1 to ( list div 3 ) do
11966: LD_ADDR_VAR 0 3
11970: PUSH
11971: DOUBLE
11972: LD_INT 1
11974: DEC
11975: ST_TO_ADDR
11976: LD_VAR 0 2
11980: PUSH
11981: LD_INT 3
11983: DIV
11984: PUSH
11985: FOR_TO
11986: IFFALSE 12063
// if list [ ( un * 3 ) ] = source_siberium then
11988: LD_VAR 0 2
11992: PUSH
11993: LD_VAR 0 3
11997: PUSH
11998: LD_INT 3
12000: MUL
12001: ARRAY
12002: PUSH
12003: LD_INT 2
12005: EQUAL
12006: IFFALSE 12061
// vysledek := vysledek ^ [ list [ ( un * 3 ) - 2 ] , list [ ( un * 3 ) - 1 ] ] ;
12008: LD_ADDR_VAR 0 4
12012: PUSH
12013: LD_VAR 0 4
12017: PUSH
12018: LD_VAR 0 2
12022: PUSH
12023: LD_VAR 0 3
12027: PUSH
12028: LD_INT 3
12030: MUL
12031: PUSH
12032: LD_INT 2
12034: MINUS
12035: ARRAY
12036: PUSH
12037: LD_VAR 0 2
12041: PUSH
12042: LD_VAR 0 3
12046: PUSH
12047: LD_INT 3
12049: MUL
12050: PUSH
12051: LD_INT 1
12053: MINUS
12054: ARRAY
12055: PUSH
12056: EMPTY
12057: LIST
12058: LIST
12059: ADD
12060: ST_TO_ADDR
12061: GO 11985
12063: POP
12064: POP
// result := vysledek ;
12065: LD_ADDR_VAR 0 1
12069: PUSH
12070: LD_VAR 0 4
12074: ST_TO_ADDR
// end ;
12075: LD_VAR 0 1
12079: RET
// function get_best_sib ( sib_list ) ; var un , min , x , y , dist , vysledek , b ; begin
12080: LD_INT 0
12082: PPUSH
12083: PPUSH
12084: PPUSH
12085: PPUSH
12086: PPUSH
12087: PPUSH
12088: PPUSH
12089: PPUSH
// min := [ - 1 , - 1 , - 1 ] ;
12090: LD_ADDR_VAR 0 4
12094: PUSH
12095: LD_INT 1
12097: NEG
12098: PUSH
12099: LD_INT 1
12101: NEG
12102: PUSH
12103: LD_INT 1
12105: NEG
12106: PUSH
12107: EMPTY
12108: LIST
12109: LIST
12110: LIST
12111: ST_TO_ADDR
// for un = 1 to ( sib_list div 2 ) do
12112: LD_ADDR_VAR 0 3
12116: PUSH
12117: DOUBLE
12118: LD_INT 1
12120: DEC
12121: ST_TO_ADDR
12122: LD_VAR 0 1
12126: PUSH
12127: LD_INT 2
12129: DIV
12130: PUSH
12131: FOR_TO
12132: IFFALSE 12305
// begin x := sib_list [ ( un * 2 ) - 1 ] ;
12134: LD_ADDR_VAR 0 5
12138: PUSH
12139: LD_VAR 0 1
12143: PUSH
12144: LD_VAR 0 3
12148: PUSH
12149: LD_INT 2
12151: MUL
12152: PUSH
12153: LD_INT 1
12155: MINUS
12156: ARRAY
12157: ST_TO_ADDR
// y := sib_list [ ( un * 2 ) ] ;
12158: LD_ADDR_VAR 0 6
12162: PUSH
12163: LD_VAR 0 1
12167: PUSH
12168: LD_VAR 0 3
12172: PUSH
12173: LD_INT 2
12175: MUL
12176: ARRAY
12177: ST_TO_ADDR
// dist := GetDistUnitXY ( Omar , x , y ) ;
12178: LD_ADDR_VAR 0 7
12182: PUSH
12183: LD_EXP 53
12187: PPUSH
12188: LD_VAR 0 5
12192: PPUSH
12193: LD_VAR 0 6
12197: PPUSH
12198: CALL_OW 297
12202: ST_TO_ADDR
// b = HexInfo ( x , y ) ;
12203: LD_ADDR_VAR 0 9
12207: PUSH
12208: LD_VAR 0 5
12212: PPUSH
12213: LD_VAR 0 6
12217: PPUSH
12218: CALL_OW 428
12222: ST_TO_ADDR
// if ( ( min [ 3 ] < 0 ) or ( dist < min [ 3 ] ) ) and ( b = 0 or GetBType ( b ) = b_siberite_mine ) then
12223: LD_VAR 0 4
12227: PUSH
12228: LD_INT 3
12230: ARRAY
12231: PUSH
12232: LD_INT 0
12234: LESS
12235: PUSH
12236: LD_VAR 0 7
12240: PUSH
12241: LD_VAR 0 4
12245: PUSH
12246: LD_INT 3
12248: ARRAY
12249: LESS
12250: OR
12251: PUSH
12252: LD_VAR 0 9
12256: PUSH
12257: LD_INT 0
12259: EQUAL
12260: PUSH
12261: LD_VAR 0 9
12265: PPUSH
12266: CALL_OW 266
12270: PUSH
12271: LD_INT 30
12273: EQUAL
12274: OR
12275: AND
12276: IFFALSE 12303
// min := [ x , y , dist ] ;
12278: LD_ADDR_VAR 0 4
12282: PUSH
12283: LD_VAR 0 5
12287: PUSH
12288: LD_VAR 0 6
12292: PUSH
12293: LD_VAR 0 7
12297: PUSH
12298: EMPTY
12299: LIST
12300: LIST
12301: LIST
12302: ST_TO_ADDR
// end ;
12303: GO 12131
12305: POP
12306: POP
// vysledek := [ min [ 1 ] , min [ 2 ] ] ;
12307: LD_ADDR_VAR 0 8
12311: PUSH
12312: LD_VAR 0 4
12316: PUSH
12317: LD_INT 1
12319: ARRAY
12320: PUSH
12321: LD_VAR 0 4
12325: PUSH
12326: LD_INT 2
12328: ARRAY
12329: PUSH
12330: EMPTY
12331: LIST
12332: LIST
12333: ST_TO_ADDR
// result := vysledek ;
12334: LD_ADDR_VAR 0 2
12338: PUSH
12339: LD_VAR 0 8
12343: ST_TO_ADDR
// end ; end_of_file
12344: LD_VAR 0 2
12348: RET
// on ResearchComplete ( tech , lab ) do begin if tech = tech_SibFiss then
12349: LD_VAR 0 1
12353: PUSH
12354: LD_INT 25
12356: EQUAL
12357: IFFALSE 12398
// case GetSide ( lab ) of 1 :
12359: LD_VAR 0 2
12363: PPUSH
12364: CALL_OW 255
12368: PUSH
12369: LD_INT 1
12371: DOUBLE
12372: EQUAL
12373: IFTRUE 12377
12375: GO 12383
12377: POP
// enable ( 4 ) ; 3 :
12378: LD_INT 4
12380: ENABLE_MARKED
12381: GO 12398
12383: LD_INT 3
12385: DOUBLE
12386: EQUAL
12387: IFTRUE 12391
12389: GO 12397
12391: POP
// enable ( 5 ) ; end ;
12392: LD_INT 5
12394: ENABLE_MARKED
12395: GO 12398
12397: POP
// wait ( 10 ) ;
12398: LD_INT 10
12400: PPUSH
12401: CALL_OW 67
// if not IsBusy ( lab ) then
12405: LD_VAR 0 2
12409: PPUSH
12410: CALL_OW 315
12414: NOT
12415: IFFALSE 12442
// begin labs_in_use := labs_in_use diff lab ;
12417: LD_ADDR_EXP 81
12421: PUSH
12422: LD_EXP 81
12426: PUSH
12427: LD_VAR 0 2
12431: DIFF
12432: ST_TO_ADDR
// Update_Artefact ( lab ) ;
12433: LD_VAR 0 2
12437: PPUSH
12438: CALL 40493 0 1
// end ; end ;
12442: PPOPN 2
12444: END
// on ResearchStarted ( tech , lab ) do var un , side ;
12445: LD_INT 0
12447: PPUSH
12448: PPUSH
// begin labs_in_use := labs_in_use ^ lab ;
12449: LD_ADDR_EXP 81
12453: PUSH
12454: LD_EXP 81
12458: PUSH
12459: LD_VAR 0 2
12463: ADD
12464: ST_TO_ADDR
// side := GetSide ( lab ) ;
12465: LD_ADDR_VAR 0 4
12469: PUSH
12470: LD_VAR 0 2
12474: PPUSH
12475: CALL_OW 255
12479: ST_TO_ADDR
// for un = 0 to ( artefact_number - 1 ) do
12480: LD_ADDR_VAR 0 3
12484: PUSH
12485: DOUBLE
12486: LD_INT 0
12488: DEC
12489: ST_TO_ADDR
12490: LD_EXP 78
12494: PUSH
12495: LD_INT 1
12497: MINUS
12498: PUSH
12499: FOR_TO
12500: IFFALSE 12579
// if lab in [ GetTag ( un * 100 + 11 ) , GetTag ( un * 100 + side * 10 + 15 ) ] then
12502: LD_VAR 0 2
12506: PUSH
12507: LD_VAR 0 3
12511: PUSH
12512: LD_INT 100
12514: MUL
12515: PUSH
12516: LD_INT 11
12518: PLUS
12519: PPUSH
12520: CALL_OW 110
12524: PUSH
12525: LD_VAR 0 3
12529: PUSH
12530: LD_INT 100
12532: MUL
12533: PUSH
12534: LD_VAR 0 4
12538: PUSH
12539: LD_INT 10
12541: MUL
12542: PLUS
12543: PUSH
12544: LD_INT 15
12546: PLUS
12547: PPUSH
12548: CALL_OW 110
12552: PUSH
12553: EMPTY
12554: LIST
12555: LIST
12556: IN
12557: IFFALSE 12577
// DeInit_Lab ( side , un + 1 ) ;
12559: LD_VAR 0 4
12563: PPUSH
12564: LD_VAR 0 3
12568: PUSH
12569: LD_INT 1
12571: PLUS
12572: PPUSH
12573: CALL 40354 0 2
12577: GO 12499
12579: POP
12580: POP
// end ;
12581: PPOPN 4
12583: END
// on ResearchCancel ( tech , lab ) do begin wait ( 10 ) ;
12584: LD_INT 10
12586: PPUSH
12587: CALL_OW 67
// if not IsBusy ( lab ) then
12591: LD_VAR 0 2
12595: PPUSH
12596: CALL_OW 315
12600: NOT
12601: IFFALSE 12628
// begin labs_in_use := labs_in_use diff lab ;
12603: LD_ADDR_EXP 81
12607: PUSH
12608: LD_EXP 81
12612: PUSH
12613: LD_VAR 0 2
12617: DIFF
12618: ST_TO_ADDR
// Update_Artefact ( lab ) ;
12619: LD_VAR 0 2
12623: PPUSH
12624: CALL 40493 0 1
// end ; end ;
12628: PPOPN 2
12630: END
// on UnitDestroyed ( un ) do begin if un = MacMillan then
12631: LD_VAR 0 1
12635: PUSH
12636: LD_EXP 13
12640: EQUAL
12641: IFFALSE 12650
// Mission_failed ( 1 ) ;
12643: LD_INT 1
12645: PPUSH
12646: CALL 14164 0 1
// if un = Burlak then
12650: LD_VAR 0 1
12654: PUSH
12655: LD_EXP 12
12659: EQUAL
12660: IFFALSE 12669
// Mission_failed ( 2 ) ;
12662: LD_INT 2
12664: PPUSH
12665: CALL 14164 0 1
// Update_defend ( un ) ;
12669: LD_VAR 0 1
12673: PPUSH
12674: CALL 21088 0 1
// end ;
12678: PPOPN 1
12680: END
// on UnitGoesToRed ( un ) do begin if ( un = MacMillan ) and not Doctors_available ( MacMillan ) then
12681: LD_VAR 0 1
12685: PUSH
12686: LD_EXP 13
12690: EQUAL
12691: PUSH
12692: LD_EXP 13
12696: PPUSH
12697: CALL 12833 0 1
12701: NOT
12702: AND
12703: IFFALSE 12712
// Mission_failed ( 1 ) ;
12705: LD_INT 1
12707: PPUSH
12708: CALL 14164 0 1
// if ( un = Burlak ) and not Doctors_available ( Burlak ) then
12712: LD_VAR 0 1
12716: PUSH
12717: LD_EXP 12
12721: EQUAL
12722: PUSH
12723: LD_EXP 12
12727: PPUSH
12728: CALL 12833 0 1
12732: NOT
12733: AND
12734: IFFALSE 12743
// Mission_failed ( 2 ) ;
12736: LD_INT 2
12738: PPUSH
12739: CALL 14164 0 1
// if ( GetSide ( un ) = us ) and ( GetControl ( un ) = control_remote ) then
12743: LD_VAR 0 1
12747: PPUSH
12748: CALL_OW 255
12752: PUSH
12753: LD_EXP 3
12757: EQUAL
12758: PUSH
12759: LD_VAR 0 1
12763: PPUSH
12764: CALL_OW 263
12768: PUSH
12769: LD_INT 2
12771: EQUAL
12772: AND
12773: IFFALSE 12791
// begin ComUnlink ( un ) ;
12775: LD_VAR 0 1
12779: PPUSH
12780: CALL_OW 136
// check_remote ( 0 ) ;
12784: LD_INT 0
12786: PPUSH
12787: CALL 35607 0 1
// end ; if GetUnitMc ( un ) then
12791: LD_VAR 0 1
12795: PPUSH
12796: CALL_OW 388
12800: IFFALSE 12821
// RemoveMcUnits ( GetUnitMc ( un ) , un ) ;
12802: LD_VAR 0 1
12806: PPUSH
12807: CALL_OW 388
12811: PPUSH
12812: LD_VAR 0 1
12816: PPUSH
12817: CALL_OW 391
// Update_defend ( un ) ;
12821: LD_VAR 0 1
12825: PPUSH
12826: CALL 21088 0 1
// end ;
12830: PPOPN 1
12832: END
// function Doctors_available ( geroj ) ; var list , un , vysledek ; begin
12833: LD_INT 0
12835: PPUSH
12836: PPUSH
12837: PPUSH
12838: PPUSH
// vysledek := false ;
12839: LD_ADDR_VAR 0 5
12843: PUSH
12844: LD_INT 0
12846: ST_TO_ADDR
// list := FilterAllUnits ( [ [ f_side , you ] , [ f_class , class_scientistic ] ] ) ;
12847: LD_ADDR_VAR 0 3
12851: PUSH
12852: LD_INT 22
12854: PUSH
12855: LD_EXP 1
12859: PUSH
12860: EMPTY
12861: LIST
12862: LIST
12863: PUSH
12864: LD_INT 25
12866: PUSH
12867: LD_INT 4
12869: PUSH
12870: EMPTY
12871: LIST
12872: LIST
12873: PUSH
12874: EMPTY
12875: LIST
12876: LIST
12877: PPUSH
12878: CALL_OW 69
12882: ST_TO_ADDR
// if list then
12883: LD_VAR 0 3
12887: IFFALSE 12897
// vysledek := true ;
12889: LD_ADDR_VAR 0 5
12893: PUSH
12894: LD_INT 1
12896: ST_TO_ADDR
// if ( not vysledek ) and ( IsInArea ( geroj , ar_crates ) ) and ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] ] ) ) and ( FilterAllUnits ( [ [ f_side , you ] , [ f_btype , b_lab ] ] ) ) then
12897: LD_VAR 0 5
12901: NOT
12902: PUSH
12903: LD_VAR 0 1
12907: PPUSH
12908: LD_INT 3
12910: PPUSH
12911: CALL_OW 308
12915: AND
12916: PUSH
12917: LD_INT 22
12919: PUSH
12920: LD_EXP 1
12924: PUSH
12925: EMPTY
12926: LIST
12927: LIST
12928: PUSH
12929: LD_INT 21
12931: PUSH
12932: LD_INT 1
12934: PUSH
12935: EMPTY
12936: LIST
12937: LIST
12938: PUSH
12939: EMPTY
12940: LIST
12941: LIST
12942: PPUSH
12943: CALL_OW 69
12947: AND
12948: PUSH
12949: LD_INT 22
12951: PUSH
12952: LD_EXP 1
12956: PUSH
12957: EMPTY
12958: LIST
12959: LIST
12960: PUSH
12961: LD_INT 30
12963: PUSH
12964: LD_INT 6
12966: PUSH
12967: EMPTY
12968: LIST
12969: LIST
12970: PUSH
12971: EMPTY
12972: LIST
12973: LIST
12974: PPUSH
12975: CALL_OW 69
12979: AND
12980: IFFALSE 12990
// vysledek := true ;
12982: LD_ADDR_VAR 0 5
12986: PUSH
12987: LD_INT 1
12989: ST_TO_ADDR
// result := vysledek ;
12990: LD_ADDR_VAR 0 2
12994: PUSH
12995: LD_VAR 0 5
12999: ST_TO_ADDR
// end ;
13000: LD_VAR 0 2
13004: RET
// on Contact ( side1 , side2 ) do begin if ( side1 in [ ar_al , you ] ) and ( side2 in [ ar_al , you ] ) then
13005: LD_VAR 0 1
13009: PUSH
13010: LD_EXP 5
13014: PUSH
13015: LD_EXP 1
13019: PUSH
13020: EMPTY
13021: LIST
13022: LIST
13023: IN
13024: PUSH
13025: LD_VAR 0 2
13029: PUSH
13030: LD_EXP 5
13034: PUSH
13035: LD_EXP 1
13039: PUSH
13040: EMPTY
13041: LIST
13042: LIST
13043: IN
13044: AND
13045: IFFALSE 13055
// omar_in_contact := true ;
13047: LD_ADDR_EXP 66
13051: PUSH
13052: LD_INT 1
13054: ST_TO_ADDR
// end ;
13055: PPOPN 2
13057: END
// on DestinationUnreachable ( un ) do begin ComStop ( un ) ;
13058: LD_VAR 0 1
13062: PPUSH
13063: CALL_OW 141
// if ( GetType ( un ) = unit_vehicle ) and ( GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay ] ) then
13067: LD_VAR 0 1
13071: PPUSH
13072: CALL_OW 247
13076: PUSH
13077: LD_INT 2
13079: EQUAL
13080: PUSH
13081: LD_VAR 0 1
13085: PPUSH
13086: CALL_OW 264
13090: PUSH
13091: LD_INT 12
13093: PUSH
13094: LD_INT 51
13096: PUSH
13097: LD_INT 32
13099: PUSH
13100: EMPTY
13101: LIST
13102: LIST
13103: LIST
13104: IN
13105: AND
13106: IFFALSE 13122
// remove_bad_crates ( GetSide ( un ) ) ;
13108: LD_VAR 0 1
13112: PPUSH
13113: CALL_OW 255
13117: PPUSH
13118: CALL 34914 0 1
// end ;
13122: PPOPN 1
13124: END
// on VehicleConstructed ( veh , fac ) do var side , list , tower ;
13125: LD_INT 0
13127: PPUSH
13128: PPUSH
13129: PPUSH
// begin side := GetSide ( fac ) ;
13130: LD_ADDR_VAR 0 3
13134: PUSH
13135: LD_VAR 0 2
13139: PPUSH
13140: CALL_OW 255
13144: ST_TO_ADDR
// case side of 1 :
13145: LD_VAR 0 3
13149: PUSH
13150: LD_INT 1
13152: DOUBLE
13153: EQUAL
13154: IFTRUE 13158
13156: GO 13284
13158: POP
// begin check_remote ( veh ) ;
13159: LD_VAR 0 1
13163: PPUSH
13164: CALL 35607 0 1
// list := ready_forces [ side ] ^ veh ;
13168: LD_ADDR_VAR 0 4
13172: PUSH
13173: LD_EXP 67
13177: PUSH
13178: LD_VAR 0 3
13182: ARRAY
13183: PUSH
13184: LD_VAR 0 1
13188: ADD
13189: ST_TO_ADDR
// ready_forces := Replace ( ready_forces , side , list ) ;
13190: LD_ADDR_EXP 67
13194: PUSH
13195: LD_EXP 67
13199: PPUSH
13200: LD_VAR 0 3
13204: PPUSH
13205: LD_VAR 0 4
13209: PPUSH
13210: CALL_OW 1
13214: ST_TO_ADDR
// tower := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_control_tower ] ] ) ;
13215: LD_ADDR_VAR 0 5
13219: PUSH
13220: LD_INT 22
13222: PUSH
13223: LD_VAR 0 3
13227: PUSH
13228: EMPTY
13229: LIST
13230: LIST
13231: PUSH
13232: LD_INT 30
13234: PUSH
13235: LD_INT 36
13237: PUSH
13238: EMPTY
13239: LIST
13240: LIST
13241: PUSH
13242: EMPTY
13243: LIST
13244: LIST
13245: PPUSH
13246: CALL_OW 69
13250: ST_TO_ADDR
// AddComMoveToArea ( veh , us_parking ) ;
13251: LD_VAR 0 1
13255: PPUSH
13256: LD_INT 22
13258: PPUSH
13259: CALL_OW 173
// if GetWeapon ( veh ) = us_siberium_rocket then
13263: LD_VAR 0 1
13267: PPUSH
13268: CALL_OW 264
13272: PUSH
13273: LD_INT 8
13275: EQUAL
13276: IFFALSE 13282
// US_Wins ;
13278: CALL 13445 0 0
// end ; 2 :
13282: GO 13442
13284: LD_INT 2
13286: DOUBLE
13287: EQUAL
13288: IFTRUE 13292
13290: GO 13307
13292: POP
// ComMoveToArea ( veh , ar_parking ) ; 3 :
13293: LD_VAR 0 1
13297: PPUSH
13298: LD_INT 23
13300: PPUSH
13301: CALL_OW 113
13305: GO 13442
13307: LD_INT 3
13309: DOUBLE
13310: EQUAL
13311: IFTRUE 13315
13313: GO 13441
13315: POP
// begin if GetWeapon ( veh ) = ru_siberium_rocket then
13316: LD_VAR 0 1
13320: PPUSH
13321: CALL_OW 264
13325: PUSH
13326: LD_INT 48
13328: EQUAL
13329: IFFALSE 13360
// begin if us in cpu_list then
13331: LD_EXP 3
13335: PUSH
13336: LD_EXP 8
13340: IN
13341: IFFALSE 13354
// send_sib_to_US ( veh ) else
13343: LD_VAR 0 1
13347: PPUSH
13348: CALL 37023 0 1
13352: GO 13358
// RU_Wins ;
13354: CALL 13635 0 0
// end else
13358: GO 13439
// begin list := ready_forces [ side ] ^ veh ;
13360: LD_ADDR_VAR 0 4
13364: PUSH
13365: LD_EXP 67
13369: PUSH
13370: LD_VAR 0 3
13374: ARRAY
13375: PUSH
13376: LD_VAR 0 1
13380: ADD
13381: ST_TO_ADDR
// ready_forces := Delete ( ready_forces , side ) ;
13382: LD_ADDR_EXP 67
13386: PUSH
13387: LD_EXP 67
13391: PPUSH
13392: LD_VAR 0 3
13396: PPUSH
13397: CALL_OW 3
13401: ST_TO_ADDR
// ready_forces := Insert ( ready_forces , side , list ) ;
13402: LD_ADDR_EXP 67
13406: PUSH
13407: LD_EXP 67
13411: PPUSH
13412: LD_VAR 0 3
13416: PPUSH
13417: LD_VAR 0 4
13421: PPUSH
13422: CALL_OW 2
13426: ST_TO_ADDR
// ComMoveToArea ( veh , ru_parking ) ;
13427: LD_VAR 0 1
13431: PPUSH
13432: LD_INT 21
13434: PPUSH
13435: CALL_OW 113
// end ; end ; end ;
13439: GO 13442
13441: POP
// end ; end_of_file
13442: PPOPN 5
13444: END
// export function US_Wins ; begin
13445: LD_INT 0
13447: PPUSH
// DialogueOn ;
13448: CALL_OW 6
// if camp = 6 then
13452: LD_EXP 7
13456: PUSH
13457: LD_INT 6
13459: EQUAL
13460: IFFALSE 13473
// CenterOnUnits ( Burlak ) else
13462: LD_EXP 12
13466: PPUSH
13467: CALL_OW 85
13471: GO 13482
// CenterOnUnits ( MacMillan ) ;
13473: LD_EXP 13
13477: PPUSH
13478: CALL_OW 85
// wait ( 0 0$1 ) ;
13482: LD_INT 35
13484: PPUSH
13485: CALL_OW 67
// interface_hidden := true ;
13489: LD_ADDR_OWVAR 54
13493: PUSH
13494: LD_INT 1
13496: ST_TO_ADDR
// Say ( Powell , DWinAmericans-Pow-1 ) ;
13497: LD_EXP 57
13501: PPUSH
13502: LD_STRING DWinAmericans-Pow-1
13504: PPUSH
13505: CALL_OW 88
// case camp of 4 :
13509: LD_EXP 7
13513: PUSH
13514: LD_INT 4
13516: DOUBLE
13517: EQUAL
13518: IFTRUE 13522
13520: GO 13562
13522: POP
// if IsOK ( MacMillan ) then
13523: LD_EXP 13
13527: PPUSH
13528: CALL_OW 302
13532: IFFALSE 13548
// Say ( MacMillan , DWinAmericans-JMM-1 ) else
13534: LD_EXP 13
13538: PPUSH
13539: LD_STRING DWinAmericans-JMM-1
13541: PPUSH
13542: CALL_OW 88
13546: GO 13560
// Say ( Burlak , DWinAmericans-Bur-1 ) ; 6 :
13548: LD_EXP 12
13552: PPUSH
13553: LD_STRING DWinAmericans-Bur-1
13555: PPUSH
13556: CALL_OW 88
13560: GO 13611
13562: LD_INT 6
13564: DOUBLE
13565: EQUAL
13566: IFTRUE 13570
13568: GO 13610
13570: POP
// if IsOK ( Burlak ) then
13571: LD_EXP 12
13575: PPUSH
13576: CALL_OW 302
13580: IFFALSE 13596
// Say ( Burlak , DWinAmericans-Bur-1 ) else
13582: LD_EXP 12
13586: PPUSH
13587: LD_STRING DWinAmericans-Bur-1
13589: PPUSH
13590: CALL_OW 88
13594: GO 13608
// Say ( MacMillan , DWinAmericans-JMM-1 ) ; end ;
13596: LD_EXP 13
13600: PPUSH
13601: LD_STRING DWinAmericans-JMM-1
13603: PPUSH
13604: CALL_OW 88
13608: GO 13611
13610: POP
// interface_hidden := false ;
13611: LD_ADDR_OWVAR 54
13615: PUSH
13616: LD_INT 0
13618: ST_TO_ADDR
// DialogueOff ;
13619: CALL_OW 7
// Mission_failed ( 3 ) ;
13623: LD_INT 3
13625: PPUSH
13626: CALL 14164 0 1
// end ;
13630: LD_VAR 0 1
13634: RET
// export function RU_Wins ; begin
13635: LD_INT 0
13637: PPUSH
// if camp = 6 then
13638: LD_EXP 7
13642: PUSH
13643: LD_INT 6
13645: EQUAL
13646: IFFALSE 13659
// CenterOnUnits ( Burlak ) else
13648: LD_EXP 12
13652: PPUSH
13653: CALL_OW 85
13657: GO 13668
// CenterOnUnits ( MacMillan ) ;
13659: LD_EXP 13
13663: PPUSH
13664: CALL_OW 85
// DialogueOn ;
13668: CALL_OW 6
// InGameOn ;
13672: CALL_OW 8
// wait ( 0 0$1 ) ;
13676: LD_INT 35
13678: PPUSH
13679: CALL_OW 67
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
13683: LD_EXP 58
13687: PPUSH
13688: LD_STRING DWinRussians-Pla-1
13690: PPUSH
13691: CALL_OW 94
// case camp of 4 :
13695: LD_EXP 7
13699: PUSH
13700: LD_INT 4
13702: DOUBLE
13703: EQUAL
13704: IFTRUE 13708
13706: GO 13748
13708: POP
// if IsOK ( MacMillan ) then
13709: LD_EXP 13
13713: PPUSH
13714: CALL_OW 302
13718: IFFALSE 13734
// Say ( MacMillan , DWinRussians-JMM-1 ) else
13720: LD_EXP 13
13724: PPUSH
13725: LD_STRING DWinRussians-JMM-1
13727: PPUSH
13728: CALL_OW 88
13732: GO 13746
// Say ( Burlak , DWinRussians-Bur-1 ) ; 6 :
13734: LD_EXP 12
13738: PPUSH
13739: LD_STRING DWinRussians-Bur-1
13741: PPUSH
13742: CALL_OW 88
13746: GO 13797
13748: LD_INT 6
13750: DOUBLE
13751: EQUAL
13752: IFTRUE 13756
13754: GO 13796
13756: POP
// if IsOK ( Burlak ) then
13757: LD_EXP 12
13761: PPUSH
13762: CALL_OW 302
13766: IFFALSE 13782
// Say ( Burlak , DWinRussians-Bur-1 ) else
13768: LD_EXP 12
13772: PPUSH
13773: LD_STRING DWinRussians-Bur-1
13775: PPUSH
13776: CALL_OW 88
13780: GO 13794
// Say ( MacMillan , DWinRussians-JMM-1 ) ; end ;
13782: LD_EXP 13
13786: PPUSH
13787: LD_STRING DWinRussians-JMM-1
13789: PPUSH
13790: CALL_OW 88
13794: GO 13797
13796: POP
// DialogueOff ;
13797: CALL_OW 7
// InGameOff ;
13801: CALL_OW 9
// Mission_failed ( 4 ) ;
13805: LD_INT 4
13807: PPUSH
13808: CALL 14164 0 1
// end ;
13812: LD_VAR 0 1
13816: RET
// on SiberiteRocketExploded ( un , x , y ) do begin InGameOn ;
13817: CALL_OW 8
// siberite_rocket_send := true ;
13821: LD_ADDR_EXP 62
13825: PUSH
13826: LD_INT 1
13828: ST_TO_ADDR
// wait ( 0 0$7 ) ;
13829: LD_INT 245
13831: PPUSH
13832: CALL_OW 67
// RU_Wins ;
13836: CALL 13635 0 0
// end ; end_of_file
13840: PPOPN 3
13842: END
// every 0 0$1 trigger finalize = 2 and ( not OmarWillTryContaminateMotherlode or GetLives ( Omar ) = 0 ) do
13843: LD_EXP 60
13847: PUSH
13848: LD_INT 2
13850: EQUAL
13851: PUSH
13852: LD_EXP 56
13856: NOT
13857: PUSH
13858: LD_EXP 53
13862: PPUSH
13863: CALL_OW 256
13867: PUSH
13868: LD_INT 0
13870: EQUAL
13871: OR
13872: AND
13873: IFFALSE 13889
13875: GO 13877
13877: DISABLE
// begin wait ( 0 0$1 ) ;
13878: LD_INT 35
13880: PPUSH
13881: CALL_OW 67
// Konec_Mise ;
13885: CALL 13890 0 0
// end ;
13889: END
// function Konec_Mise ; var campaign_loading , campaign_lost , another_campaign , medal1 , medal2 , medal3 ; begin
13890: LD_INT 0
13892: PPUSH
13893: PPUSH
13894: PPUSH
13895: PPUSH
13896: PPUSH
13897: PPUSH
13898: PPUSH
// lets_talking ;
13899: CALL 16542 0 0
// another_campaign := true ;
13903: LD_ADDR_VAR 0 4
13907: PUSH
13908: LD_INT 1
13910: ST_TO_ADDR
// gained_medals := [ ] ;
13911: LD_ADDR_OWVAR 61
13915: PUSH
13916: EMPTY
13917: ST_TO_ADDR
// missing_medals := [ ] ;
13918: LD_ADDR_OWVAR 62
13922: PUSH
13923: EMPTY
13924: ST_TO_ADDR
// medal1 := true ;
13925: LD_ADDR_VAR 0 5
13929: PUSH
13930: LD_INT 1
13932: ST_TO_ADDR
// medal2 := ( camp = 4 and IsOk ( Burlak ) ) or ( camp = 6 and IsOk ( MacMillan ) ) ;
13933: LD_ADDR_VAR 0 6
13937: PUSH
13938: LD_EXP 7
13942: PUSH
13943: LD_INT 4
13945: EQUAL
13946: PUSH
13947: LD_EXP 12
13951: PPUSH
13952: CALL_OW 302
13956: AND
13957: PUSH
13958: LD_EXP 7
13962: PUSH
13963: LD_INT 6
13965: EQUAL
13966: PUSH
13967: LD_EXP 13
13971: PPUSH
13972: CALL_OW 302
13976: AND
13977: OR
13978: ST_TO_ADDR
// medal3 := GetTag ( 81 ) and GetTag ( 181 ) and GetTag ( 281 ) ;
13979: LD_ADDR_VAR 0 7
13983: PUSH
13984: LD_INT 81
13986: PPUSH
13987: CALL_OW 110
13991: PUSH
13992: LD_INT 181
13994: PPUSH
13995: CALL_OW 110
13999: AND
14000: PUSH
14001: LD_INT 281
14003: PPUSH
14004: CALL_OW 110
14008: AND
14009: ST_TO_ADDR
// AddMedal ( Hero , another_campaign ) ;
14010: LD_STRING Hero
14012: PPUSH
14013: LD_VAR 0 4
14017: PPUSH
14018: CALL_OW 101
// AddMedal ( Artefact , GetTag ( 81 ) and GetTag ( 181 ) and GetTag ( 281 ) ) ;
14022: LD_STRING Artefact
14024: PPUSH
14025: LD_INT 81
14027: PPUSH
14028: CALL_OW 110
14032: PUSH
14033: LD_INT 181
14035: PPUSH
14036: CALL_OW 110
14040: AND
14041: PUSH
14042: LD_INT 281
14044: PPUSH
14045: CALL_OW 110
14049: AND
14050: PPUSH
14051: CALL_OW 101
// case camp of 4 :
14055: LD_EXP 7
14059: PUSH
14060: LD_INT 4
14062: DOUBLE
14063: EQUAL
14064: IFTRUE 14068
14066: GO 14088
14068: POP
// AddMedal ( ReconcileBurlak , IsOK ( Burlak ) ) ; 6 :
14069: LD_STRING ReconcileBurlak
14071: PPUSH
14072: LD_EXP 12
14076: PPUSH
14077: CALL_OW 302
14081: PPUSH
14082: CALL_OW 101
14086: GO 14117
14088: LD_INT 6
14090: DOUBLE
14091: EQUAL
14092: IFTRUE 14096
14094: GO 14116
14096: POP
// AddMedal ( ReconcileJMM , IsOK ( MacMillan ) ) ; end ;
14097: LD_STRING ReconcileJMM
14099: PPUSH
14100: LD_EXP 13
14104: PPUSH
14105: CALL_OW 302
14109: PPUSH
14110: CALL_OW 101
14114: GO 14117
14116: POP
// SA_OnMissionComplete ;
14117: CALL 42744 0 0
// SA_EndMission ( 4 , 4 , medal1 , medal2 , medal3 ) ;
14121: LD_INT 4
14123: PPUSH
14124: LD_INT 4
14126: PPUSH
14127: LD_VAR 0 5
14131: PPUSH
14132: LD_VAR 0 6
14136: PPUSH
14137: LD_VAR 0 7
14141: PPUSH
14142: CALL 42759 0 5
// GiveMedals ( Main ) ;
14146: LD_STRING Main
14148: PPUSH
14149: CALL_OW 102
// YouWin ;
14153: CALL_OW 103
// exit ;
14157: GO 14159
// end ;
14159: LD_VAR 0 1
14163: RET
// export function Mission_Failed ( how ) ; begin
14164: LD_INT 0
14166: PPUSH
// case how of 1 :
14167: LD_VAR 0 1
14171: PUSH
14172: LD_INT 1
14174: DOUBLE
14175: EQUAL
14176: IFTRUE 14180
14178: GO 14190
14180: POP
// YouLost ( JMM ) ; 2 :
14181: LD_STRING JMM
14183: PPUSH
14184: CALL_OW 104
14188: GO 14263
14190: LD_INT 2
14192: DOUBLE
14193: EQUAL
14194: IFTRUE 14198
14196: GO 14208
14198: POP
// YouLost ( Burlak ) ; 3 :
14199: LD_STRING Burlak
14201: PPUSH
14202: CALL_OW 104
14206: GO 14263
14208: LD_INT 3
14210: DOUBLE
14211: EQUAL
14212: IFTRUE 14216
14214: GO 14226
14216: POP
// YouLost ( AmBomb ) ; 4 :
14217: LD_STRING AmBomb
14219: PPUSH
14220: CALL_OW 104
14224: GO 14263
14226: LD_INT 4
14228: DOUBLE
14229: EQUAL
14230: IFTRUE 14234
14232: GO 14244
14234: POP
// YouLost ( RuBomb ) ; 5 :
14235: LD_STRING RuBomb
14237: PPUSH
14238: CALL_OW 104
14242: GO 14263
14244: LD_INT 5
14246: DOUBLE
14247: EQUAL
14248: IFTRUE 14252
14250: GO 14262
14252: POP
// YouLost ( MothContaminate ) ; end ;
14253: LD_STRING MothContaminate
14255: PPUSH
14256: CALL_OW 104
14260: GO 14263
14262: POP
// end ; end_of_file
14263: LD_VAR 0 2
14267: RET
// function Base_Destroyed ( side ) ; var un , list , vysledek ; begin
14268: LD_INT 0
14270: PPUSH
14271: PPUSH
14272: PPUSH
14273: PPUSH
// vysledek := false ;
14274: LD_ADDR_VAR 0 5
14278: PUSH
14279: LD_INT 0
14281: ST_TO_ADDR
// if not ( FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] , [ f_ok ] ] ) or FilterAllUnits ( [ [ f_side , side ] , [ f_class , class_engineer ] , [ f_ok ] ] ) ) then
14282: LD_INT 22
14284: PUSH
14285: LD_VAR 0 1
14289: PUSH
14290: EMPTY
14291: LIST
14292: LIST
14293: PUSH
14294: LD_INT 2
14296: PUSH
14297: LD_INT 30
14299: PUSH
14300: LD_INT 0
14302: PUSH
14303: EMPTY
14304: LIST
14305: LIST
14306: PUSH
14307: LD_INT 30
14309: PUSH
14310: LD_INT 1
14312: PUSH
14313: EMPTY
14314: LIST
14315: LIST
14316: PUSH
14317: EMPTY
14318: LIST
14319: LIST
14320: LIST
14321: PUSH
14322: LD_INT 50
14324: PUSH
14325: EMPTY
14326: LIST
14327: PUSH
14328: EMPTY
14329: LIST
14330: LIST
14331: LIST
14332: PPUSH
14333: CALL_OW 69
14337: PUSH
14338: LD_INT 22
14340: PUSH
14341: LD_VAR 0 1
14345: PUSH
14346: EMPTY
14347: LIST
14348: LIST
14349: PUSH
14350: LD_INT 25
14352: PUSH
14353: LD_INT 2
14355: PUSH
14356: EMPTY
14357: LIST
14358: LIST
14359: PUSH
14360: LD_INT 50
14362: PUSH
14363: EMPTY
14364: LIST
14365: PUSH
14366: EMPTY
14367: LIST
14368: LIST
14369: LIST
14370: PPUSH
14371: CALL_OW 69
14375: OR
14376: NOT
14377: IFFALSE 14387
// vysledek := true ;
14379: LD_ADDR_VAR 0 5
14383: PUSH
14384: LD_INT 1
14386: ST_TO_ADDR
// if not vysledek then
14387: LD_VAR 0 5
14391: NOT
14392: IFFALSE 14455
// begin list := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_ok ] ] ) ;
14394: LD_ADDR_VAR 0 4
14398: PUSH
14399: LD_INT 22
14401: PUSH
14402: LD_VAR 0 1
14406: PUSH
14407: EMPTY
14408: LIST
14409: LIST
14410: PUSH
14411: LD_INT 21
14413: PUSH
14414: LD_INT 1
14416: PUSH
14417: EMPTY
14418: LIST
14419: LIST
14420: PUSH
14421: LD_INT 50
14423: PUSH
14424: EMPTY
14425: LIST
14426: PUSH
14427: EMPTY
14428: LIST
14429: LIST
14430: LIST
14431: PPUSH
14432: CALL_OW 69
14436: ST_TO_ADDR
// if list < 3 then
14437: LD_VAR 0 4
14441: PUSH
14442: LD_INT 3
14444: LESS
14445: IFFALSE 14455
// vysledek := true ;
14447: LD_ADDR_VAR 0 5
14451: PUSH
14452: LD_INT 1
14454: ST_TO_ADDR
// end ; if not vysledek then
14455: LD_VAR 0 5
14459: NOT
14460: IFFALSE 14590
// begin list := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_ok ] ] ) ;
14462: LD_ADDR_VAR 0 4
14466: PUSH
14467: LD_INT 22
14469: PUSH
14470: LD_VAR 0 1
14474: PUSH
14475: EMPTY
14476: LIST
14477: LIST
14478: PUSH
14479: LD_INT 2
14481: PUSH
14482: LD_INT 30
14484: PUSH
14485: LD_INT 32
14487: PUSH
14488: EMPTY
14489: LIST
14490: LIST
14491: PUSH
14492: LD_INT 30
14494: PUSH
14495: LD_INT 33
14497: PUSH
14498: EMPTY
14499: LIST
14500: LIST
14501: PUSH
14502: EMPTY
14503: LIST
14504: LIST
14505: LIST
14506: PUSH
14507: LD_INT 50
14509: PUSH
14510: EMPTY
14511: LIST
14512: PUSH
14513: EMPTY
14514: LIST
14515: LIST
14516: LIST
14517: PPUSH
14518: CALL_OW 69
14522: ST_TO_ADDR
// un := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) ;
14523: LD_ADDR_VAR 0 3
14527: PUSH
14528: LD_INT 22
14530: PUSH
14531: LD_VAR 0 1
14535: PUSH
14536: EMPTY
14537: LIST
14538: LIST
14539: PUSH
14540: LD_INT 21
14542: PUSH
14543: LD_INT 2
14545: PUSH
14546: EMPTY
14547: LIST
14548: LIST
14549: PUSH
14550: LD_INT 50
14552: PUSH
14553: EMPTY
14554: LIST
14555: PUSH
14556: EMPTY
14557: LIST
14558: LIST
14559: LIST
14560: PPUSH
14561: CALL_OW 69
14565: ST_TO_ADDR
// if ( un + list ) < 5 then
14566: LD_VAR 0 3
14570: PUSH
14571: LD_VAR 0 4
14575: PLUS
14576: PUSH
14577: LD_INT 5
14579: LESS
14580: IFFALSE 14590
// vysledek := true ;
14582: LD_ADDR_VAR 0 5
14586: PUSH
14587: LD_INT 1
14589: ST_TO_ADDR
// end ; if not vysledek then
14590: LD_VAR 0 5
14594: NOT
14595: IFFALSE 14684
// begin list := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] , [ f_ok ] ] ) ;
14597: LD_ADDR_VAR 0 4
14601: PUSH
14602: LD_INT 22
14604: PUSH
14605: LD_VAR 0 1
14609: PUSH
14610: EMPTY
14611: LIST
14612: LIST
14613: PUSH
14614: LD_INT 2
14616: PUSH
14617: LD_INT 30
14619: PUSH
14620: LD_INT 27
14622: PUSH
14623: EMPTY
14624: LIST
14625: LIST
14626: PUSH
14627: LD_INT 30
14629: PUSH
14630: LD_INT 26
14632: PUSH
14633: EMPTY
14634: LIST
14635: LIST
14636: PUSH
14637: LD_INT 30
14639: PUSH
14640: LD_INT 28
14642: PUSH
14643: EMPTY
14644: LIST
14645: LIST
14646: PUSH
14647: EMPTY
14648: LIST
14649: LIST
14650: LIST
14651: LIST
14652: PUSH
14653: LD_INT 50
14655: PUSH
14656: EMPTY
14657: LIST
14658: PUSH
14659: EMPTY
14660: LIST
14661: LIST
14662: LIST
14663: PPUSH
14664: CALL_OW 69
14668: ST_TO_ADDR
// if not list then
14669: LD_VAR 0 4
14673: NOT
14674: IFFALSE 14684
// vysledek := 0 ;
14676: LD_ADDR_VAR 0 5
14680: PUSH
14681: LD_INT 0
14683: ST_TO_ADDR
// end ; result := vysledek ;
14684: LD_ADDR_VAR 0 2
14688: PUSH
14689: LD_VAR 0 5
14693: ST_TO_ADDR
// end ;
14694: LD_VAR 0 2
14698: RET
// every 0 0$2.1 trigger Base_Destroyed ( us ) and not siberite_rocket_send do var sol , un , list ;
14699: LD_EXP 3
14703: PPUSH
14704: CALL 14268 0 1
14708: PUSH
14709: LD_EXP 62
14713: NOT
14714: AND
14715: IFFALSE 15282
14717: GO 14719
14719: DISABLE
14720: LD_INT 0
14722: PPUSH
14723: PPUSH
14724: PPUSH
// begin if IsOK ( Powell ) then
14725: LD_EXP 57
14729: PPUSH
14730: CALL_OW 302
14734: IFFALSE 14812
// begin CenterOnUnits ( Powell ) ;
14736: LD_EXP 57
14740: PPUSH
14741: CALL_OW 85
// DialogueOn ;
14745: CALL_OW 6
// interface_hidden := true ;
14749: LD_ADDR_OWVAR 54
14753: PUSH
14754: LD_INT 1
14756: ST_TO_ADDR
// Say ( Powell , DSurrenderAmericans-Pow-1 ) ;
14757: LD_EXP 57
14761: PPUSH
14762: LD_STRING DSurrenderAmericans-Pow-1
14764: PPUSH
14765: CALL_OW 88
// Say ( MacMillan , DSurrenderAmericans-JMM-1 ) ;
14769: LD_EXP 13
14773: PPUSH
14774: LD_STRING DSurrenderAmericans-JMM-1
14776: PPUSH
14777: CALL_OW 88
// interface_hidden := false ;
14781: LD_ADDR_OWVAR 54
14785: PUSH
14786: LD_INT 0
14788: ST_TO_ADDR
// DialogueOff ;
14789: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
14793: LD_INT 35
14795: PPUSH
14796: CALL_OW 67
// until not IsOK ( Powell ) ;
14800: LD_EXP 57
14804: PPUSH
14805: CALL_OW 302
14809: NOT
14810: IFFALSE 14793
// end ; cpu_list := cpu_list diff us ;
14812: LD_ADDR_EXP 8
14816: PUSH
14817: LD_EXP 8
14821: PUSH
14822: LD_EXP 3
14826: DIFF
14827: ST_TO_ADDR
// SetAttitude ( you , us , att_friend , true ) ;
14828: LD_EXP 1
14832: PPUSH
14833: LD_EXP 3
14837: PPUSH
14838: LD_INT 1
14840: PPUSH
14841: LD_INT 1
14843: PPUSH
14844: CALL_OW 80
// sol := FindLastMohycane ( us ) ;
14848: LD_ADDR_VAR 0 1
14852: PUSH
14853: LD_EXP 3
14857: PPUSH
14858: CALL 16158 0 1
14862: ST_TO_ADDR
// if IsOK ( sol ) then
14863: LD_VAR 0 1
14867: PPUSH
14868: CALL_OW 302
14872: IFFALSE 14883
// ComExitBuilding ( sol ) ;
14874: LD_VAR 0 1
14878: PPUSH
14879: CALL_OW 122
// while not See ( you , sol ) do
14883: LD_EXP 1
14887: PPUSH
14888: LD_VAR 0 1
14892: PPUSH
14893: CALL_OW 292
14897: NOT
14898: IFFALSE 14965
// begin un := FilterAllUnits ( [ [ f_side , you ] , [ f_ok ] ] ) ;
14900: LD_ADDR_VAR 0 2
14904: PUSH
14905: LD_INT 22
14907: PUSH
14908: LD_EXP 1
14912: PUSH
14913: EMPTY
14914: LIST
14915: LIST
14916: PUSH
14917: LD_INT 50
14919: PUSH
14920: EMPTY
14921: LIST
14922: PUSH
14923: EMPTY
14924: LIST
14925: LIST
14926: PPUSH
14927: CALL_OW 69
14931: ST_TO_ADDR
// ComMoveUnit ( sol , NearestUnitToUnit ( un , sol ) ) ;
14932: LD_VAR 0 1
14936: PPUSH
14937: LD_VAR 0 2
14941: PPUSH
14942: LD_VAR 0 1
14946: PPUSH
14947: CALL_OW 74
14951: PPUSH
14952: CALL_OW 112
// wait ( 0 0$1 ) ;
14956: LD_INT 35
14958: PPUSH
14959: CALL_OW 67
// end ;
14963: GO 14883
// CenterOnUnits ( sol ) ;
14965: LD_VAR 0 1
14969: PPUSH
14970: CALL_OW 85
// DialogueOn ;
14974: CALL_OW 6
// interface_hidden := true ;
14978: LD_ADDR_OWVAR 54
14982: PUSH
14983: LD_INT 1
14985: ST_TO_ADDR
// case camp of 4 :
14986: LD_EXP 7
14990: PUSH
14991: LD_INT 4
14993: DOUBLE
14994: EQUAL
14995: IFTRUE 14999
14997: GO 15014
14999: POP
// Say ( sol , DSurrenderAmericans-Sol1-1a ) ; 6 :
15000: LD_VAR 0 1
15004: PPUSH
15005: LD_STRING DSurrenderAmericans-Sol1-1a
15007: PPUSH
15008: CALL_OW 88
15012: GO 15038
15014: LD_INT 6
15016: DOUBLE
15017: EQUAL
15018: IFTRUE 15022
15020: GO 15037
15022: POP
// Say ( sol , DSurrenderAmericans-Sol1-1 ) ; end ;
15023: LD_VAR 0 1
15027: PPUSH
15028: LD_STRING DSurrenderAmericans-Sol1-1
15030: PPUSH
15031: CALL_OW 88
15035: GO 15038
15037: POP
// interface_hidden := false ;
15038: LD_ADDR_OWVAR 54
15042: PUSH
15043: LD_INT 0
15045: ST_TO_ADDR
// DialogueOff ;
15046: CALL_OW 7
// finalize := finalize + 1 ;
15050: LD_ADDR_EXP 60
15054: PUSH
15055: LD_EXP 60
15059: PUSH
15060: LD_INT 1
15062: PLUS
15063: ST_TO_ADDR
// list := FilterAllUnits ( [ [ f_side , us ] , f_not , [ f_type , unit_human ] ] ) ;
15064: LD_ADDR_VAR 0 3
15068: PUSH
15069: LD_INT 22
15071: PUSH
15072: LD_EXP 3
15076: PUSH
15077: EMPTY
15078: LIST
15079: LIST
15080: PUSH
15081: LD_INT 3
15083: PUSH
15084: LD_INT 21
15086: PUSH
15087: LD_INT 1
15089: PUSH
15090: EMPTY
15091: LIST
15092: LIST
15093: PUSH
15094: EMPTY
15095: LIST
15096: LIST
15097: LIST
15098: PPUSH
15099: CALL_OW 69
15103: ST_TO_ADDR
// SetSide ( list , you ) ;
15104: LD_VAR 0 3
15108: PPUSH
15109: LD_EXP 1
15113: PPUSH
15114: CALL_OW 235
// DestroyAndReplaceVehicles ( UnitFilter ( list , [ f_type , unit_vehicle ] ) ) ;
15118: LD_VAR 0 3
15122: PPUSH
15123: LD_INT 21
15125: PUSH
15126: LD_INT 2
15128: PUSH
15129: EMPTY
15130: LIST
15131: LIST
15132: PPUSH
15133: CALL_OW 72
15137: PPUSH
15138: CALL 15285 0 1
// repeat list := FilterAllUnits ( [ [ f_side , us ] , [ f_type , unit_human ] , [ f_ok ] ] ) ;
15142: LD_ADDR_VAR 0 3
15146: PUSH
15147: LD_INT 22
15149: PUSH
15150: LD_EXP 3
15154: PUSH
15155: EMPTY
15156: LIST
15157: LIST
15158: PUSH
15159: LD_INT 21
15161: PUSH
15162: LD_INT 1
15164: PUSH
15165: EMPTY
15166: LIST
15167: LIST
15168: PUSH
15169: LD_INT 50
15171: PUSH
15172: EMPTY
15173: LIST
15174: PUSH
15175: EMPTY
15176: LIST
15177: LIST
15178: LIST
15179: PPUSH
15180: CALL_OW 69
15184: ST_TO_ADDR
// ComMoveToArea ( list , am_leaving_area ) ;
15185: LD_VAR 0 3
15189: PPUSH
15190: LD_INT 30
15192: PPUSH
15193: CALL_OW 113
// if list then
15197: LD_VAR 0 3
15201: IFFALSE 15210
// wait ( 0 0$2 ) ;
15203: LD_INT 70
15205: PPUSH
15206: CALL_OW 67
// sol := FilterUnitsInArea ( am_leaving_area , [ [ f_side , us ] , [ f_type , unit_human ] ] ) ;
15210: LD_ADDR_VAR 0 1
15214: PUSH
15215: LD_INT 30
15217: PPUSH
15218: LD_INT 22
15220: PUSH
15221: LD_EXP 3
15225: PUSH
15226: EMPTY
15227: LIST
15228: LIST
15229: PUSH
15230: LD_INT 21
15232: PUSH
15233: LD_INT 1
15235: PUSH
15236: EMPTY
15237: LIST
15238: LIST
15239: PUSH
15240: EMPTY
15241: LIST
15242: LIST
15243: PPUSH
15244: CALL_OW 70
15248: ST_TO_ADDR
// for un in sol do
15249: LD_ADDR_VAR 0 2
15253: PUSH
15254: LD_VAR 0 1
15258: PUSH
15259: FOR_IN
15260: IFFALSE 15273
// RemoveUnit ( un ) ;
15262: LD_VAR 0 2
15266: PPUSH
15267: CALL_OW 64
15271: GO 15259
15273: POP
15274: POP
// until not list ;
15275: LD_VAR 0 3
15279: NOT
15280: IFFALSE 15142
// end ;
15282: PPOPN 3
15284: END
// function DestroyAndReplaceVehicles ( list ) ; var i , x , y , driver , veh ; begin
15285: LD_INT 0
15287: PPUSH
15288: PPUSH
15289: PPUSH
15290: PPUSH
15291: PPUSH
15292: PPUSH
// for i in list do
15293: LD_ADDR_VAR 0 3
15297: PUSH
15298: LD_VAR 0 1
15302: PUSH
15303: FOR_IN
15304: IFFALSE 15565
// begin InitUc ;
15306: CALL_OW 18
// InitVc ;
15310: CALL_OW 20
// uc_nation = GetNation ( i ) ;
15314: LD_ADDR_OWVAR 21
15318: PUSH
15319: LD_VAR 0 3
15323: PPUSH
15324: CALL_OW 248
15328: ST_TO_ADDR
// uc_side = GetSide ( i ) ;
15329: LD_ADDR_OWVAR 20
15333: PUSH
15334: LD_VAR 0 3
15338: PPUSH
15339: CALL_OW 255
15343: ST_TO_ADDR
// uc_direction = GetDir ( i ) ;
15344: LD_ADDR_OWVAR 24
15348: PUSH
15349: LD_VAR 0 3
15353: PPUSH
15354: CALL_OW 254
15358: ST_TO_ADDR
// vc_chassis = GetChassis ( i ) ;
15359: LD_ADDR_OWVAR 37
15363: PUSH
15364: LD_VAR 0 3
15368: PPUSH
15369: CALL_OW 265
15373: ST_TO_ADDR
// vc_engine = GetEngine ( i ) ;
15374: LD_ADDR_OWVAR 39
15378: PUSH
15379: LD_VAR 0 3
15383: PPUSH
15384: CALL_OW 262
15388: ST_TO_ADDR
// vc_weapon = GetWeapon ( i ) ;
15389: LD_ADDR_OWVAR 40
15393: PUSH
15394: LD_VAR 0 3
15398: PPUSH
15399: CALL_OW 264
15403: ST_TO_ADDR
// vc_control = GetControl ( i ) ;
15404: LD_ADDR_OWVAR 38
15408: PUSH
15409: LD_VAR 0 3
15413: PPUSH
15414: CALL_OW 263
15418: ST_TO_ADDR
// vc_fuel_battery = GetFuel ( i ) ;
15419: LD_ADDR_OWVAR 41
15423: PUSH
15424: LD_VAR 0 3
15428: PPUSH
15429: CALL_OW 261
15433: ST_TO_ADDR
// x = GetX ( i ) ;
15434: LD_ADDR_VAR 0 4
15438: PUSH
15439: LD_VAR 0 3
15443: PPUSH
15444: CALL_OW 250
15448: ST_TO_ADDR
// y = GetY ( i ) ;
15449: LD_ADDR_VAR 0 5
15453: PUSH
15454: LD_VAR 0 3
15458: PPUSH
15459: CALL_OW 251
15463: ST_TO_ADDR
// driver = IsDrivenBy ( i ) ;
15464: LD_ADDR_VAR 0 6
15468: PUSH
15469: LD_VAR 0 3
15473: PPUSH
15474: CALL_OW 311
15478: ST_TO_ADDR
// if driver > 0 then
15479: LD_VAR 0 6
15483: PUSH
15484: LD_INT 0
15486: GREATER
15487: IFFALSE 15498
// RemoveUnit ( driver ) ;
15489: LD_VAR 0 6
15493: PPUSH
15494: CALL_OW 64
// DestroyUnit ( i ) ;
15498: LD_VAR 0 3
15502: PPUSH
15503: CALL_OW 65
// veh = CreateVehicle ;
15507: LD_ADDR_VAR 0 7
15511: PUSH
15512: CALL_OW 45
15516: ST_TO_ADDR
// PlaceUnitXY ( veh , x , y , false ) ;
15517: LD_VAR 0 7
15521: PPUSH
15522: LD_VAR 0 4
15526: PPUSH
15527: LD_VAR 0 5
15531: PPUSH
15532: LD_INT 0
15534: PPUSH
15535: CALL_OW 48
// if driver > 0 then
15539: LD_VAR 0 6
15543: PUSH
15544: LD_INT 0
15546: GREATER
15547: IFFALSE 15563
// PlaceHumanInUnit ( driver , veh ) ;
15549: LD_VAR 0 6
15553: PPUSH
15554: LD_VAR 0 7
15558: PPUSH
15559: CALL_OW 52
// end ;
15563: GO 15303
15565: POP
15566: POP
// end ;
15567: LD_VAR 0 2
15571: RET
// every 0 0$2.3 trigger Base_Destroyed ( ru ) and not siberite_rocket_send do var list , sol , un ;
15572: LD_EXP 2
15576: PPUSH
15577: CALL 14268 0 1
15581: PUSH
15582: LD_EXP 62
15586: NOT
15587: AND
15588: IFFALSE 16155
15590: GO 15592
15592: DISABLE
15593: LD_INT 0
15595: PPUSH
15596: PPUSH
15597: PPUSH
// begin if IsOK ( Platonov ) then
15598: LD_EXP 58
15602: PPUSH
15603: CALL_OW 302
15607: IFFALSE 15685
// begin CenterOnUnits ( Platonov ) ;
15609: LD_EXP 58
15613: PPUSH
15614: CALL_OW 85
// DialogueOn ;
15618: CALL_OW 6
// interface_hidden := true ;
15622: LD_ADDR_OWVAR 54
15626: PUSH
15627: LD_INT 1
15629: ST_TO_ADDR
// Say ( Platonov , DSurrenderRussians-Pla-1 ) ;
15630: LD_EXP 58
15634: PPUSH
15635: LD_STRING DSurrenderRussians-Pla-1
15637: PPUSH
15638: CALL_OW 88
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
15642: LD_EXP 12
15646: PPUSH
15647: LD_STRING DSurrenderRussians-Bur-1
15649: PPUSH
15650: CALL_OW 88
// interface_hidden := false ;
15654: LD_ADDR_OWVAR 54
15658: PUSH
15659: LD_INT 0
15661: ST_TO_ADDR
// DialogueOff ;
15662: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
15666: LD_INT 35
15668: PPUSH
15669: CALL_OW 67
// until not IsOK ( Platonov ) ;
15673: LD_EXP 58
15677: PPUSH
15678: CALL_OW 302
15682: NOT
15683: IFFALSE 15666
// end ; cpu_list := cpu_list diff ru ;
15685: LD_ADDR_EXP 8
15689: PUSH
15690: LD_EXP 8
15694: PUSH
15695: LD_EXP 2
15699: DIFF
15700: ST_TO_ADDR
// SetAttitude ( you , ru , att_friend , true ) ;
15701: LD_EXP 1
15705: PPUSH
15706: LD_EXP 2
15710: PPUSH
15711: LD_INT 1
15713: PPUSH
15714: LD_INT 1
15716: PPUSH
15717: CALL_OW 80
// sol := FindLastMohycane ( ru ) ;
15721: LD_ADDR_VAR 0 2
15725: PUSH
15726: LD_EXP 2
15730: PPUSH
15731: CALL 16158 0 1
15735: ST_TO_ADDR
// if IsOK ( sol ) then
15736: LD_VAR 0 2
15740: PPUSH
15741: CALL_OW 302
15745: IFFALSE 15756
// ComExitBuilding ( sol ) ;
15747: LD_VAR 0 2
15751: PPUSH
15752: CALL_OW 122
// while not See ( you , sol ) do
15756: LD_EXP 1
15760: PPUSH
15761: LD_VAR 0 2
15765: PPUSH
15766: CALL_OW 292
15770: NOT
15771: IFFALSE 15838
// begin un := FilterAllUnits ( [ [ f_side , you ] , [ f_ok ] ] ) ;
15773: LD_ADDR_VAR 0 3
15777: PUSH
15778: LD_INT 22
15780: PUSH
15781: LD_EXP 1
15785: PUSH
15786: EMPTY
15787: LIST
15788: LIST
15789: PUSH
15790: LD_INT 50
15792: PUSH
15793: EMPTY
15794: LIST
15795: PUSH
15796: EMPTY
15797: LIST
15798: LIST
15799: PPUSH
15800: CALL_OW 69
15804: ST_TO_ADDR
// ComMoveUnit ( sol , NearestUnitToUnit ( un , sol ) ) ;
15805: LD_VAR 0 2
15809: PPUSH
15810: LD_VAR 0 3
15814: PPUSH
15815: LD_VAR 0 2
15819: PPUSH
15820: CALL_OW 74
15824: PPUSH
15825: CALL_OW 112
// wait ( 0 0$1 ) ;
15829: LD_INT 35
15831: PPUSH
15832: CALL_OW 67
// end ;
15836: GO 15756
// CenterOnUnits ( sol ) ;
15838: LD_VAR 0 2
15842: PPUSH
15843: CALL_OW 85
// DialogueOn ;
15847: CALL_OW 6
// interface_hidden := true ;
15851: LD_ADDR_OWVAR 54
15855: PUSH
15856: LD_INT 1
15858: ST_TO_ADDR
// case camp of 4 :
15859: LD_EXP 7
15863: PUSH
15864: LD_INT 4
15866: DOUBLE
15867: EQUAL
15868: IFTRUE 15872
15870: GO 15887
15872: POP
// Say ( sol , DSurrenderRussians-Rsol1-1a ) ; 6 :
15873: LD_VAR 0 2
15877: PPUSH
15878: LD_STRING DSurrenderRussians-Rsol1-1a
15880: PPUSH
15881: CALL_OW 88
15885: GO 15911
15887: LD_INT 6
15889: DOUBLE
15890: EQUAL
15891: IFTRUE 15895
15893: GO 15910
15895: POP
// Say ( sol , DSurrenderRussians-Rsol1-1 ) ; end ;
15896: LD_VAR 0 2
15900: PPUSH
15901: LD_STRING DSurrenderRussians-Rsol1-1
15903: PPUSH
15904: CALL_OW 88
15908: GO 15911
15910: POP
// interface_hidden := false ;
15911: LD_ADDR_OWVAR 54
15915: PUSH
15916: LD_INT 0
15918: ST_TO_ADDR
// DialogueOff ;
15919: CALL_OW 7
// finalize := finalize + 1 ;
15923: LD_ADDR_EXP 60
15927: PUSH
15928: LD_EXP 60
15932: PUSH
15933: LD_INT 1
15935: PLUS
15936: ST_TO_ADDR
// list := FilterAllUnits ( [ [ f_side , ru ] , f_not , [ f_type , unit_human ] ] ) ;
15937: LD_ADDR_VAR 0 1
15941: PUSH
15942: LD_INT 22
15944: PUSH
15945: LD_EXP 2
15949: PUSH
15950: EMPTY
15951: LIST
15952: LIST
15953: PUSH
15954: LD_INT 3
15956: PUSH
15957: LD_INT 21
15959: PUSH
15960: LD_INT 1
15962: PUSH
15963: EMPTY
15964: LIST
15965: LIST
15966: PUSH
15967: EMPTY
15968: LIST
15969: LIST
15970: LIST
15971: PPUSH
15972: CALL_OW 69
15976: ST_TO_ADDR
// SetSide ( list , you ) ;
15977: LD_VAR 0 1
15981: PPUSH
15982: LD_EXP 1
15986: PPUSH
15987: CALL_OW 235
// DestroyAndReplaceVehicles ( UnitFilter ( list , [ f_type , unit_vehicle ] ) ) ;
15991: LD_VAR 0 1
15995: PPUSH
15996: LD_INT 21
15998: PUSH
15999: LD_INT 2
16001: PUSH
16002: EMPTY
16003: LIST
16004: LIST
16005: PPUSH
16006: CALL_OW 72
16010: PPUSH
16011: CALL 15285 0 1
// repeat list := FilterAllUnits ( [ [ f_side , ru ] , [ f_type , unit_human ] , [ f_ok ] ] ) ;
16015: LD_ADDR_VAR 0 1
16019: PUSH
16020: LD_INT 22
16022: PUSH
16023: LD_EXP 2
16027: PUSH
16028: EMPTY
16029: LIST
16030: LIST
16031: PUSH
16032: LD_INT 21
16034: PUSH
16035: LD_INT 1
16037: PUSH
16038: EMPTY
16039: LIST
16040: LIST
16041: PUSH
16042: LD_INT 50
16044: PUSH
16045: EMPTY
16046: LIST
16047: PUSH
16048: EMPTY
16049: LIST
16050: LIST
16051: LIST
16052: PPUSH
16053: CALL_OW 69
16057: ST_TO_ADDR
// ComMoveToArea ( list , ru_leaving_area ) ;
16058: LD_VAR 0 1
16062: PPUSH
16063: LD_INT 31
16065: PPUSH
16066: CALL_OW 113
// if list then
16070: LD_VAR 0 1
16074: IFFALSE 16083
// wait ( 0 0$2 ) ;
16076: LD_INT 70
16078: PPUSH
16079: CALL_OW 67
// sol := FilterUnitsInArea ( ru_leaving_area , [ [ f_side , ru ] , [ f_type , unit_human ] ] ) ;
16083: LD_ADDR_VAR 0 2
16087: PUSH
16088: LD_INT 31
16090: PPUSH
16091: LD_INT 22
16093: PUSH
16094: LD_EXP 2
16098: PUSH
16099: EMPTY
16100: LIST
16101: LIST
16102: PUSH
16103: LD_INT 21
16105: PUSH
16106: LD_INT 1
16108: PUSH
16109: EMPTY
16110: LIST
16111: LIST
16112: PUSH
16113: EMPTY
16114: LIST
16115: LIST
16116: PPUSH
16117: CALL_OW 70
16121: ST_TO_ADDR
// for un in sol do
16122: LD_ADDR_VAR 0 3
16126: PUSH
16127: LD_VAR 0 2
16131: PUSH
16132: FOR_IN
16133: IFFALSE 16146
// RemoveUnit ( un ) ;
16135: LD_VAR 0 3
16139: PPUSH
16140: CALL_OW 64
16144: GO 16132
16146: POP
16147: POP
// until not list ;
16148: LD_VAR 0 1
16152: NOT
16153: IFFALSE 16015
// end ;
16155: PPOPN 3
16157: END
// function FindLastMohycane ( side ) ; var area , un , list , build , unseen , vysledek ; begin
16158: LD_INT 0
16160: PPUSH
16161: PPUSH
16162: PPUSH
16163: PPUSH
16164: PPUSH
16165: PPUSH
16166: PPUSH
// case side of us :
16167: LD_VAR 0 1
16171: PUSH
16172: LD_EXP 3
16176: DOUBLE
16177: EQUAL
16178: IFTRUE 16182
16180: GO 16193
16182: POP
// area := us_base ; ru :
16183: LD_ADDR_VAR 0 3
16187: PUSH
16188: LD_INT 11
16190: ST_TO_ADDR
16191: GO 16215
16193: LD_EXP 2
16197: DOUBLE
16198: EQUAL
16199: IFTRUE 16203
16201: GO 16214
16203: POP
// area := ru_base ; end ;
16204: LD_ADDR_VAR 0 3
16208: PUSH
16209: LD_INT 12
16211: ST_TO_ADDR
16212: GO 16215
16214: POP
// list := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_sex , sex_male ] , [ f_ok ] ] ) diff FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_kamikaze ] ] ] ) ;
16215: LD_ADDR_VAR 0 5
16219: PUSH
16220: LD_INT 22
16222: PUSH
16223: LD_VAR 0 1
16227: PUSH
16228: EMPTY
16229: LIST
16230: LIST
16231: PUSH
16232: LD_INT 21
16234: PUSH
16235: LD_INT 1
16237: PUSH
16238: EMPTY
16239: LIST
16240: LIST
16241: PUSH
16242: LD_INT 26
16244: PUSH
16245: LD_INT 1
16247: PUSH
16248: EMPTY
16249: LIST
16250: LIST
16251: PUSH
16252: LD_INT 50
16254: PUSH
16255: EMPTY
16256: LIST
16257: PUSH
16258: EMPTY
16259: LIST
16260: LIST
16261: LIST
16262: LIST
16263: PPUSH
16264: CALL_OW 69
16268: PUSH
16269: LD_INT 22
16271: PUSH
16272: LD_VAR 0 1
16276: PUSH
16277: EMPTY
16278: LIST
16279: LIST
16280: PUSH
16281: LD_INT 2
16283: PUSH
16284: LD_INT 25
16286: PUSH
16287: LD_INT 12
16289: PUSH
16290: EMPTY
16291: LIST
16292: LIST
16293: PUSH
16294: LD_INT 25
16296: PUSH
16297: LD_INT 15
16299: PUSH
16300: EMPTY
16301: LIST
16302: LIST
16303: PUSH
16304: LD_INT 25
16306: PUSH
16307: LD_INT 16
16309: PUSH
16310: EMPTY
16311: LIST
16312: LIST
16313: PUSH
16314: LD_INT 25
16316: PUSH
16317: LD_INT 17
16319: PUSH
16320: EMPTY
16321: LIST
16322: LIST
16323: PUSH
16324: EMPTY
16325: LIST
16326: LIST
16327: LIST
16328: LIST
16329: LIST
16330: PUSH
16331: EMPTY
16332: LIST
16333: LIST
16334: PPUSH
16335: CALL_OW 69
16339: DIFF
16340: ST_TO_ADDR
// if list then
16341: LD_VAR 0 5
16345: IFFALSE 16367
// vysledek := FindMaxSkill ( list , skill_combat ) else
16347: LD_ADDR_VAR 0 8
16351: PUSH
16352: LD_VAR 0 5
16356: PPUSH
16357: LD_INT 1
16359: PPUSH
16360: CALL_OW 433
16364: ST_TO_ADDR
16365: GO 16527
// begin unseen := 0 ;
16367: LD_ADDR_VAR 0 7
16371: PUSH
16372: LD_INT 0
16374: ST_TO_ADDR
// build := FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_ok ] ] ) ;
16375: LD_ADDR_VAR 0 6
16379: PUSH
16380: LD_INT 22
16382: PUSH
16383: LD_VAR 0 1
16387: PUSH
16388: EMPTY
16389: LIST
16390: LIST
16391: PUSH
16392: LD_INT 58
16394: PUSH
16395: EMPTY
16396: LIST
16397: PUSH
16398: LD_INT 50
16400: PUSH
16401: EMPTY
16402: LIST
16403: PUSH
16404: EMPTY
16405: LIST
16406: LIST
16407: LIST
16408: PPUSH
16409: CALL_OW 69
16413: ST_TO_ADDR
// for un in build do
16414: LD_ADDR_VAR 0 4
16418: PUSH
16419: LD_VAR 0 6
16423: PUSH
16424: FOR_IN
16425: IFFALSE 16458
// if not See ( you , un ) then
16427: LD_EXP 1
16431: PPUSH
16432: LD_VAR 0 4
16436: PPUSH
16437: CALL_OW 292
16441: NOT
16442: IFFALSE 16456
// begin unseen := un ;
16444: LD_ADDR_VAR 0 7
16448: PUSH
16449: LD_VAR 0 4
16453: ST_TO_ADDR
// break ;
16454: GO 16458
// end ;
16456: GO 16424
16458: POP
16459: POP
// if ( not unseen ) and build then
16460: LD_VAR 0 7
16464: NOT
16465: PUSH
16466: LD_VAR 0 6
16470: AND
16471: IFFALSE 16487
// unseen := build [ 1 ] ;
16473: LD_ADDR_VAR 0 7
16477: PUSH
16478: LD_VAR 0 6
16482: PUSH
16483: LD_INT 1
16485: ARRAY
16486: ST_TO_ADDR
// if unseen then
16487: LD_VAR 0 7
16491: IFFALSE 16527
// begin PrepareSoldier ( sex_male , 5 ) ;
16493: LD_INT 1
16495: PPUSH
16496: LD_INT 5
16498: PPUSH
16499: CALL_OW 381
// vysledek := CreateHuman ;
16503: LD_ADDR_VAR 0 8
16507: PUSH
16508: CALL_OW 44
16512: ST_TO_ADDR
// PlaceHumanInUnit ( vysledek , unseen ) ;
16513: LD_VAR 0 8
16517: PPUSH
16518: LD_VAR 0 7
16522: PPUSH
16523: CALL_OW 52
// end ; end ; result := vysledek ;
16527: LD_ADDR_VAR 0 2
16531: PUSH
16532: LD_VAR 0 8
16536: ST_TO_ADDR
// end ; end_of_file
16537: LD_VAR 0 2
16541: RET
// export function lets_talking ; begin
16542: LD_INT 0
16544: PPUSH
// DialogueOn ;
16545: CALL_OW 6
// interface_hidden := true ;
16549: LD_ADDR_OWVAR 54
16553: PUSH
16554: LD_INT 1
16556: ST_TO_ADDR
// case camp of 4 :
16557: LD_EXP 7
16561: PUSH
16562: LD_INT 4
16564: DOUBLE
16565: EQUAL
16566: IFTRUE 16570
16568: GO 16577
16570: POP
// us_talking ; 6 :
16571: CALL 17642 0 0
16575: GO 16593
16577: LD_INT 6
16579: DOUBLE
16580: EQUAL
16581: IFTRUE 16585
16583: GO 16592
16585: POP
// ru_talking ; end ;
16586: CALL 16610 0 0
16590: GO 16593
16592: POP
// interface_hidden := false ;
16593: LD_ADDR_OWVAR 54
16597: PUSH
16598: LD_INT 0
16600: ST_TO_ADDR
// DialogueOff ;
16601: CALL_OW 7
// end ;
16605: LD_VAR 0 1
16609: RET
// function ru_talking ; begin
16610: LD_INT 0
16612: PPUSH
// if IsOK ( Burlak ) then
16613: LD_EXP 12
16617: PPUSH
16618: CALL_OW 302
16622: IFFALSE 16645
// begin CenterOnUnits ( Burlak ) ;
16624: LD_EXP 12
16628: PPUSH
16629: CALL_OW 85
// Say ( Burlak , DEnd-Burlak-Bur-1 ) ;
16633: LD_EXP 12
16637: PPUSH
16638: LD_STRING DEnd-Burlak-Bur-1
16640: PPUSH
16641: CALL_OW 88
// end ; if IsOK ( Petrosyan ) then
16645: LD_EXP 16
16649: PPUSH
16650: CALL_OW 302
16654: IFFALSE 16677
// begin CenterOnUnits ( Petrosyan ) ;
16656: LD_EXP 16
16660: PPUSH
16661: CALL_OW 85
// Say ( Petrosyan , DEnd-Burlak-Pty-1 ) ;
16665: LD_EXP 16
16669: PPUSH
16670: LD_STRING DEnd-Burlak-Pty-1
16672: PPUSH
16673: CALL_OW 88
// end ; if IsOK ( Belkov ) then
16677: LD_EXP 17
16681: PPUSH
16682: CALL_OW 302
16686: IFFALSE 16709
// begin CenterOnUnits ( Belkov ) ;
16688: LD_EXP 17
16692: PPUSH
16693: CALL_OW 85
// Say ( Belkov , DEnd-Burlak-Bel-1 ) ;
16697: LD_EXP 17
16701: PPUSH
16702: LD_STRING DEnd-Burlak-Bel-1
16704: PPUSH
16705: CALL_OW 88
// end ; if IsOK ( Kirilenkova ) then
16709: LD_EXP 18
16713: PPUSH
16714: CALL_OW 302
16718: IFFALSE 16741
// begin CenterOnUnits ( Kirilenkova ) ;
16720: LD_EXP 18
16724: PPUSH
16725: CALL_OW 85
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
16729: LD_EXP 18
16733: PPUSH
16734: LD_STRING DEnd-Burlak-Kir-1
16736: PPUSH
16737: CALL_OW 88
// end ; if IsOK ( Gnyevko ) then
16741: LD_EXP 19
16745: PPUSH
16746: CALL_OW 302
16750: IFFALSE 16773
// begin CenterOnUnits ( Gnyevko ) ;
16752: LD_EXP 19
16756: PPUSH
16757: CALL_OW 85
// Say ( Gnyevko , DEnd-Burlak-Gny-1 ) ;
16761: LD_EXP 19
16765: PPUSH
16766: LD_STRING DEnd-Burlak-Gny-1
16768: PPUSH
16769: CALL_OW 88
// end ; if IsOK ( Gladkov ) then
16773: LD_EXP 20
16777: PPUSH
16778: CALL_OW 302
16782: IFFALSE 16805
// begin CenterOnUnits ( Gladkov ) ;
16784: LD_EXP 20
16788: PPUSH
16789: CALL_OW 85
// Say ( Gladkov , DEnd-Burlak-Gla-1 ) ;
16793: LD_EXP 20
16797: PPUSH
16798: LD_STRING DEnd-Burlak-Gla-1
16800: PPUSH
16801: CALL_OW 88
// end ; if IsOK ( Dolgov ) then
16805: LD_EXP 21
16809: PPUSH
16810: CALL_OW 302
16814: IFFALSE 16837
// begin CenterOnUnits ( Dolgov ) ;
16816: LD_EXP 21
16820: PPUSH
16821: CALL_OW 85
// Say ( Dolgov , DEnd-Burlak-Dol-1 ) ;
16825: LD_EXP 21
16829: PPUSH
16830: LD_STRING DEnd-Burlak-Dol-1
16832: PPUSH
16833: CALL_OW 88
// end ; if IsOK ( Kapitsova ) then
16837: LD_EXP 23
16841: PPUSH
16842: CALL_OW 302
16846: IFFALSE 16869
// begin CenterOnUnits ( Kapitsova ) ;
16848: LD_EXP 23
16852: PPUSH
16853: CALL_OW 85
// Say ( Kapitsova , DEnd-Burlak-Kap-1 ) ;
16857: LD_EXP 23
16861: PPUSH
16862: LD_STRING DEnd-Burlak-Kap-1
16864: PPUSH
16865: CALL_OW 88
// end ; if IsOK ( Gleb ) then
16869: LD_EXP 22
16873: PPUSH
16874: CALL_OW 302
16878: IFFALSE 16901
// begin CenterOnUnits ( Gleb ) ;
16880: LD_EXP 22
16884: PPUSH
16885: CALL_OW 85
// Say ( Gleb , DEnd-JMM-Glb-1 ) ;
16889: LD_EXP 22
16893: PPUSH
16894: LD_STRING DEnd-JMM-Glb-1
16896: PPUSH
16897: CALL_OW 88
// end ; if IsOK ( Kuzmov ) then
16901: LD_EXP 24
16905: PPUSH
16906: CALL_OW 302
16910: IFFALSE 16933
// begin CenterOnUnits ( Kuzmov ) ;
16912: LD_EXP 24
16916: PPUSH
16917: CALL_OW 85
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
16921: LD_EXP 24
16925: PPUSH
16926: LD_STRING DEnd-Burlak-Kuz-1
16928: PPUSH
16929: CALL_OW 88
// end ; if IsOK ( Kovalyuk ) then
16933: LD_EXP 25
16937: PPUSH
16938: CALL_OW 302
16942: IFFALSE 16965
// begin CenterOnUnits ( Kovalyuk ) ;
16944: LD_EXP 25
16948: PPUSH
16949: CALL_OW 85
// Say ( Kovalyuk , DEnd-Burlak-Kov-1 ) ;
16953: LD_EXP 25
16957: PPUSH
16958: LD_STRING DEnd-Burlak-Kov-1
16960: PPUSH
16961: CALL_OW 88
// end ; if IsOK ( Scholtze ) then
16965: LD_EXP 26
16969: PPUSH
16970: CALL_OW 302
16974: IFFALSE 16997
// begin CenterOnUnits ( Scholtze ) ;
16976: LD_EXP 26
16980: PPUSH
16981: CALL_OW 85
// Say ( Scholtze , DEnd-Burlak-Sch-1 ) ;
16985: LD_EXP 26
16989: PPUSH
16990: LD_STRING DEnd-Burlak-Sch-1
16992: PPUSH
16993: CALL_OW 88
// end ; if IsOK ( Karamazov ) then
16997: LD_EXP 27
17001: PPUSH
17002: CALL_OW 302
17006: IFFALSE 17029
// begin CenterOnUnits ( Karamazov ) ;
17008: LD_EXP 27
17012: PPUSH
17013: CALL_OW 85
// Say ( Karamazov , DEnd-Burlak-Kar-1 ) ;
17017: LD_EXP 27
17021: PPUSH
17022: LD_STRING DEnd-Burlak-Kar-1
17024: PPUSH
17025: CALL_OW 88
// end ; if IsOK ( Titov ) then
17029: LD_EXP 28
17033: PPUSH
17034: CALL_OW 302
17038: IFFALSE 17061
// begin CenterOnUnits ( Titov ) ;
17040: LD_EXP 28
17044: PPUSH
17045: CALL_OW 85
// Say ( Titov , DEnd-Burlak-Tit-1 ) ;
17049: LD_EXP 28
17053: PPUSH
17054: LD_STRING DEnd-Burlak-Tit-1
17056: PPUSH
17057: CALL_OW 88
// end ; if IsOK ( Oblukov ) then
17061: LD_EXP 29
17065: PPUSH
17066: CALL_OW 302
17070: IFFALSE 17093
// begin CenterOnUnits ( Oblukov ) ;
17072: LD_EXP 29
17076: PPUSH
17077: CALL_OW 85
// Say ( Oblukov , DEnd-Burlak-Obl-1 ) ;
17081: LD_EXP 29
17085: PPUSH
17086: LD_STRING DEnd-Burlak-Obl-1
17088: PPUSH
17089: CALL_OW 88
// end ; if IsOK ( Kozlov ) then
17093: LD_EXP 30
17097: PPUSH
17098: CALL_OW 302
17102: IFFALSE 17125
// begin CenterOnUnits ( Kozlov ) ;
17104: LD_EXP 30
17108: PPUSH
17109: CALL_OW 85
// Say ( Kozlov , DEnd-Burlak-Koz-1 ) ;
17113: LD_EXP 30
17117: PPUSH
17118: LD_STRING DEnd-Burlak-Koz-1
17120: PPUSH
17121: CALL_OW 88
// end ; if IsOK ( Petrovova ) then
17125: LD_EXP 31
17129: PPUSH
17130: CALL_OW 302
17134: IFFALSE 17157
// begin CenterOnUnits ( Petrovova ) ;
17136: LD_EXP 31
17140: PPUSH
17141: CALL_OW 85
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
17145: LD_EXP 31
17149: PPUSH
17150: LD_STRING DEnd-Burlak-Ptr-1
17152: PPUSH
17153: CALL_OW 88
// end ; if IsOK ( Bystrov ) then
17157: LD_EXP 32
17161: PPUSH
17162: CALL_OW 302
17166: IFFALSE 17189
// begin CenterOnUnits ( Bystrov ) ;
17168: LD_EXP 32
17172: PPUSH
17173: CALL_OW 85
// Say ( Bystrov , DEnd-Burlak-Bys-1 ) ;
17177: LD_EXP 32
17181: PPUSH
17182: LD_STRING DEnd-Burlak-Bys-1
17184: PPUSH
17185: CALL_OW 88
// end ; if IsOK ( Lipshchin ) then
17189: LD_EXP 33
17193: PPUSH
17194: CALL_OW 302
17198: IFFALSE 17221
// begin CenterOnUnits ( Lipshchin ) ;
17200: LD_EXP 33
17204: PPUSH
17205: CALL_OW 85
// Say ( Lipshchin , DEnd-Burlak-Lip-1 ) ;
17209: LD_EXP 33
17213: PPUSH
17214: LD_STRING DEnd-Burlak-Lip-1
17216: PPUSH
17217: CALL_OW 88
// end ; if IsOK ( Fadeev ) then
17221: LD_EXP 34
17225: PPUSH
17226: CALL_OW 302
17230: IFFALSE 17253
// begin CenterOnUnits ( Fadeev ) ;
17232: LD_EXP 34
17236: PPUSH
17237: CALL_OW 85
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
17241: LD_EXP 34
17245: PPUSH
17246: LD_STRING DEnd-Burlak-Fad-1
17248: PPUSH
17249: CALL_OW 88
// end ; if IsOK ( MacMillan ) then
17253: LD_EXP 13
17257: PPUSH
17258: CALL_OW 302
17262: IFFALSE 17285
// begin CenterOnUnits ( MacMillan ) ;
17264: LD_EXP 13
17268: PPUSH
17269: CALL_OW 85
// Say ( MacMillan , DEnd-Burlak-JMM-1 ) ;
17273: LD_EXP 13
17277: PPUSH
17278: LD_STRING DEnd-Burlak-JMM-1
17280: PPUSH
17281: CALL_OW 88
// end ; if IsOK ( Lisa ) then
17285: LD_EXP 48
17289: PPUSH
17290: CALL_OW 302
17294: IFFALSE 17317
// begin CenterOnUnits ( Lisa ) ;
17296: LD_EXP 48
17300: PPUSH
17301: CALL_OW 85
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
17305: LD_EXP 48
17309: PPUSH
17310: LD_STRING DEnd-Burlak-Lisa-1
17312: PPUSH
17313: CALL_OW 88
// end ; if IsOK ( Joan ) then
17317: LD_EXP 47
17321: PPUSH
17322: CALL_OW 302
17326: IFFALSE 17349
// begin CenterOnUnits ( Joan ) ;
17328: LD_EXP 47
17332: PPUSH
17333: CALL_OW 85
// Say ( Joan , DEnd-Burlak-Joan-1 ) ;
17337: LD_EXP 47
17341: PPUSH
17342: LD_STRING DEnd-Burlak-Joan-1
17344: PPUSH
17345: CALL_OW 88
// end ; if IsOK ( Frank ) then
17349: LD_EXP 44
17353: PPUSH
17354: CALL_OW 302
17358: IFFALSE 17381
// begin CenterOnUnits ( Frank ) ;
17360: LD_EXP 44
17364: PPUSH
17365: CALL_OW 85
// Say ( Frank , DEnd-Burlak-Frank-1 ) ;
17369: LD_EXP 44
17373: PPUSH
17374: LD_STRING DEnd-Burlak-Frank-1
17376: PPUSH
17377: CALL_OW 88
// end ; if IsOK ( Cyrus ) then
17381: LD_EXP 41
17385: PPUSH
17386: CALL_OW 302
17390: IFFALSE 17413
// begin CenterOnUnits ( Cyrus ) ;
17392: LD_EXP 41
17396: PPUSH
17397: CALL_OW 85
// Say ( Cyrus , DEnd-Burlak-Cyrus-1 ) ;
17401: LD_EXP 41
17405: PPUSH
17406: LD_STRING DEnd-Burlak-Cyrus-1
17408: PPUSH
17409: CALL_OW 88
// end ; if IsOK ( Donaldson ) then
17413: LD_EXP 43
17417: PPUSH
17418: CALL_OW 302
17422: IFFALSE 17445
// begin CenterOnUnits ( Donaldson ) ;
17424: LD_EXP 43
17428: PPUSH
17429: CALL_OW 85
// Say ( Donaldson , DEnd-Burlak-Don-1 ) ;
17433: LD_EXP 43
17437: PPUSH
17438: LD_STRING DEnd-Burlak-Don-1
17440: PPUSH
17441: CALL_OW 88
// end ; if IsOK ( Bobby ) then
17445: LD_EXP 37
17449: PPUSH
17450: CALL_OW 302
17454: IFFALSE 17477
// begin CenterOnUnits ( Bobby ) ;
17456: LD_EXP 37
17460: PPUSH
17461: CALL_OW 85
// Say ( Bobby , DEnd-Burlak-Bobby-1 ) ;
17465: LD_EXP 37
17469: PPUSH
17470: LD_STRING DEnd-Burlak-Bobby-1
17472: PPUSH
17473: CALL_OW 88
// end ; if IsOK ( Denis ) then
17477: LD_EXP 42
17481: PPUSH
17482: CALL_OW 302
17486: IFFALSE 17509
// begin CenterOnUnits ( Denis ) ;
17488: LD_EXP 42
17492: PPUSH
17493: CALL_OW 85
// Say ( Denis , DEnd-Burlak-Den-1 ) ;
17497: LD_EXP 42
17501: PPUSH
17502: LD_STRING DEnd-Burlak-Den-1
17504: PPUSH
17505: CALL_OW 88
// end ; if IsOK ( Gladstone ) then
17509: LD_EXP 46
17513: PPUSH
17514: CALL_OW 302
17518: IFFALSE 17541
// begin CenterOnUnits ( Gladstone ) ;
17520: LD_EXP 46
17524: PPUSH
17525: CALL_OW 85
// Say ( Gladstone , DEnd-Burlak-Glad-1 ) ;
17529: LD_EXP 46
17533: PPUSH
17534: LD_STRING DEnd-Burlak-Glad-1
17536: PPUSH
17537: CALL_OW 88
// end ; if IsOK ( Yamoko ) then
17541: LD_EXP 52
17545: PPUSH
17546: CALL_OW 302
17550: IFFALSE 17573
// begin CenterOnUnits ( Yamoko ) ;
17552: LD_EXP 52
17556: PPUSH
17557: CALL_OW 85
// Say ( Yamoko , DEnd-Burlak-Yam-1 ) ;
17561: LD_EXP 52
17565: PPUSH
17566: LD_STRING DEnd-Burlak-Yam-1
17568: PPUSH
17569: CALL_OW 88
// end ; if IsOK ( Brown ) then
17573: LD_EXP 38
17577: PPUSH
17578: CALL_OW 302
17582: IFFALSE 17605
// begin CenterOnUnits ( Brown ) ;
17584: LD_EXP 38
17588: PPUSH
17589: CALL_OW 85
// Say ( Brown , DEnd-Burlak-Brown-1 ) ;
17593: LD_EXP 38
17597: PPUSH
17598: LD_STRING DEnd-Burlak-Brown-1
17600: PPUSH
17601: CALL_OW 88
// end ; if IsOK ( Roth ) then
17605: LD_EXP 14
17609: PPUSH
17610: CALL_OW 302
17614: IFFALSE 17637
// begin CenterOnUnits ( Roth ) ;
17616: LD_EXP 14
17620: PPUSH
17621: CALL_OW 85
// Say ( Roth , DEnd-Burlak-Roth-1 ) ;
17625: LD_EXP 14
17629: PPUSH
17630: LD_STRING DEnd-Burlak-Roth-1
17632: PPUSH
17633: CALL_OW 88
// end ; end ;
17637: LD_VAR 0 1
17641: RET
// function us_talking ; begin
17642: LD_INT 0
17644: PPUSH
// if IsOK ( MacMillan ) then
17645: LD_EXP 13
17649: PPUSH
17650: CALL_OW 302
17654: IFFALSE 17677
// begin CenterOnUnits ( MacMillan ) ;
17656: LD_EXP 13
17660: PPUSH
17661: CALL_OW 85
// Say ( MacMillan , DEnd-JMM-JMM-1 ) ;
17665: LD_EXP 13
17669: PPUSH
17670: LD_STRING DEnd-JMM-JMM-1
17672: PPUSH
17673: CALL_OW 88
// end ; if IsOK ( Lisa ) then
17677: LD_EXP 48
17681: PPUSH
17682: CALL_OW 302
17686: IFFALSE 17709
// begin CenterOnUnits ( Lisa ) ;
17688: LD_EXP 48
17692: PPUSH
17693: CALL_OW 85
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
17697: LD_EXP 48
17701: PPUSH
17702: LD_STRING DEnd-JMM-Lisa-1
17704: PPUSH
17705: CALL_OW 88
// end ; if IsOK ( Joan ) then
17709: LD_EXP 47
17713: PPUSH
17714: CALL_OW 302
17718: IFFALSE 17741
// begin CenterOnUnits ( Joan ) ;
17720: LD_EXP 47
17724: PPUSH
17725: CALL_OW 85
// Say ( Joan , DEnd-JMM-Joan-1 ) ;
17729: LD_EXP 47
17733: PPUSH
17734: LD_STRING DEnd-JMM-Joan-1
17736: PPUSH
17737: CALL_OW 88
// end ; if IsOK ( Frank ) then
17741: LD_EXP 44
17745: PPUSH
17746: CALL_OW 302
17750: IFFALSE 17773
// begin CenterOnUnits ( Frank ) ;
17752: LD_EXP 44
17756: PPUSH
17757: CALL_OW 85
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
17761: LD_EXP 44
17765: PPUSH
17766: LD_STRING DEnd-JMM-Frank-1
17768: PPUSH
17769: CALL_OW 88
// end ; if IsOK ( Cyrus ) then
17773: LD_EXP 41
17777: PPUSH
17778: CALL_OW 302
17782: IFFALSE 17805
// begin CenterOnUnits ( Cyrus ) ;
17784: LD_EXP 41
17788: PPUSH
17789: CALL_OW 85
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
17793: LD_EXP 41
17797: PPUSH
17798: LD_STRING DEnd-JMM-Cyrus-1
17800: PPUSH
17801: CALL_OW 88
// end ; if IsOK ( Cornell ) then
17805: LD_EXP 39
17809: PPUSH
17810: CALL_OW 302
17814: IFFALSE 17837
// begin CenterOnUnits ( Cornell ) ;
17816: LD_EXP 39
17820: PPUSH
17821: CALL_OW 85
// Say ( Cornell , DEnd-JMM-Corn-1 ) ;
17825: LD_EXP 39
17829: PPUSH
17830: LD_STRING DEnd-JMM-Corn-1
17832: PPUSH
17833: CALL_OW 88
// end ; if IsOK ( Donaldson ) then
17837: LD_EXP 43
17841: PPUSH
17842: CALL_OW 302
17846: IFFALSE 17869
// begin CenterOnUnits ( Donaldson ) ;
17848: LD_EXP 43
17852: PPUSH
17853: CALL_OW 85
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
17857: LD_EXP 43
17861: PPUSH
17862: LD_STRING DEnd-JMM-Don-1
17864: PPUSH
17865: CALL_OW 88
// end ; if IsOK ( Bobby ) then
17869: LD_EXP 37
17873: PPUSH
17874: CALL_OW 302
17878: IFFALSE 17901
// begin CenterOnUnits ( Bobby ) ;
17880: LD_EXP 37
17884: PPUSH
17885: CALL_OW 85
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
17889: LD_EXP 37
17893: PPUSH
17894: LD_STRING DEnd-JMM-Bobby-1
17896: PPUSH
17897: CALL_OW 88
// end ; if IsOK ( Denis ) then
17901: LD_EXP 42
17905: PPUSH
17906: CALL_OW 302
17910: IFFALSE 17933
// begin CenterOnUnits ( Denis ) ;
17912: LD_EXP 42
17916: PPUSH
17917: CALL_OW 85
// Say ( Denis , DEnd-JMM-Den-1 ) ;
17921: LD_EXP 42
17925: PPUSH
17926: LD_STRING DEnd-JMM-Den-1
17928: PPUSH
17929: CALL_OW 88
// end ; if IsOK ( Gladstone ) then
17933: LD_EXP 46
17937: PPUSH
17938: CALL_OW 302
17942: IFFALSE 17965
// begin CenterOnUnits ( Gladstone ) ;
17944: LD_EXP 46
17948: PPUSH
17949: CALL_OW 85
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
17953: LD_EXP 46
17957: PPUSH
17958: LD_STRING DEnd-JMM-Glad-1
17960: PPUSH
17961: CALL_OW 88
// end ; if IsOK ( Yamoko ) then
17965: LD_EXP 52
17969: PPUSH
17970: CALL_OW 302
17974: IFFALSE 17997
// begin CenterOnUnits ( Yamoko ) ;
17976: LD_EXP 52
17980: PPUSH
17981: CALL_OW 85
// Say ( Yamoko , DEnd-JMM-Yam-1 ) ;
17985: LD_EXP 52
17989: PPUSH
17990: LD_STRING DEnd-JMM-Yam-1
17992: PPUSH
17993: CALL_OW 88
// end ; if IsOK ( Brown ) then
17997: LD_EXP 38
18001: PPUSH
18002: CALL_OW 302
18006: IFFALSE 18029
// begin CenterOnUnits ( Brown ) ;
18008: LD_EXP 38
18012: PPUSH
18013: CALL_OW 85
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
18017: LD_EXP 38
18021: PPUSH
18022: LD_STRING DEnd-JMM-Brown-1
18024: PPUSH
18025: CALL_OW 88
// end ; if IsOK ( Roth ) then
18029: LD_EXP 14
18033: PPUSH
18034: CALL_OW 302
18038: IFFALSE 18061
// begin CenterOnUnits ( Roth ) ;
18040: LD_EXP 14
18044: PPUSH
18045: CALL_OW 85
// Say ( Roth , DEnd-JMM-Roth-1 ) ;
18049: LD_EXP 14
18053: PPUSH
18054: LD_STRING DEnd-JMM-Roth-1
18056: PPUSH
18057: CALL_OW 88
// end ; if IsOK ( Connie ) then
18061: LD_EXP 40
18065: PPUSH
18066: CALL_OW 302
18070: IFFALSE 18093
// begin CenterOnUnits ( Connie ) ;
18072: LD_EXP 40
18076: PPUSH
18077: CALL_OW 85
// Say ( Connie , DEnd-JMM-Con-1 ) ;
18081: LD_EXP 40
18085: PPUSH
18086: LD_STRING DEnd-JMM-Con-1
18088: PPUSH
18089: CALL_OW 88
// end ; if IsOK ( Gary ) then
18093: LD_EXP 45
18097: PPUSH
18098: CALL_OW 302
18102: IFFALSE 18125
// begin CenterOnUnits ( Gary ) ;
18104: LD_EXP 45
18108: PPUSH
18109: CALL_OW 85
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
18113: LD_EXP 45
18117: PPUSH
18118: LD_STRING DEnd-JMM-Gary-1
18120: PPUSH
18121: CALL_OW 88
// end ; if IsOK ( Simms ) then
18125: LD_EXP 50
18129: PPUSH
18130: CALL_OW 302
18134: IFFALSE 18157
// begin CenterOnUnits ( Simms ) ;
18136: LD_EXP 50
18140: PPUSH
18141: CALL_OW 85
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
18145: LD_EXP 50
18149: PPUSH
18150: LD_STRING DEnd-JMM-Sim-1
18152: PPUSH
18153: CALL_OW 88
// end ; if IsOK ( VanHouten ) then
18157: LD_EXP 51
18161: PPUSH
18162: CALL_OW 302
18166: IFFALSE 18189
// begin CenterOnUnits ( VanHouten ) ;
18168: LD_EXP 51
18172: PPUSH
18173: CALL_OW 85
// Say ( VanHouten , DEnd-JMM-VanH-1 ) ;
18177: LD_EXP 51
18181: PPUSH
18182: LD_STRING DEnd-JMM-VanH-1
18184: PPUSH
18185: CALL_OW 88
// end ; if IsOK ( Burlak ) then
18189: LD_EXP 12
18193: PPUSH
18194: CALL_OW 302
18198: IFFALSE 18221
// begin CenterOnUnits ( Burlak ) ;
18200: LD_EXP 12
18204: PPUSH
18205: CALL_OW 85
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
18209: LD_EXP 12
18213: PPUSH
18214: LD_STRING DEnd-JMM-Bur-1
18216: PPUSH
18217: CALL_OW 88
// end ; if IsOK ( Belkov ) then
18221: LD_EXP 17
18225: PPUSH
18226: CALL_OW 302
18230: IFFALSE 18253
// begin CenterOnUnits ( Belkov ) ;
18232: LD_EXP 17
18236: PPUSH
18237: CALL_OW 85
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
18241: LD_EXP 17
18245: PPUSH
18246: LD_STRING DEnd-JMM-Bel-1
18248: PPUSH
18249: CALL_OW 88
// end ; if IsOK ( Gnyevko ) then
18253: LD_EXP 19
18257: PPUSH
18258: CALL_OW 302
18262: IFFALSE 18285
// begin CenterOnUnits ( Gnyevko ) ;
18264: LD_EXP 19
18268: PPUSH
18269: CALL_OW 85
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
18273: LD_EXP 19
18277: PPUSH
18278: LD_STRING DEnd-JMM-Gny-1
18280: PPUSH
18281: CALL_OW 88
// end ; if IsOK ( Dolgov ) then
18285: LD_EXP 21
18289: PPUSH
18290: CALL_OW 302
18294: IFFALSE 18317
// begin CenterOnUnits ( Dolgov ) ;
18296: LD_EXP 21
18300: PPUSH
18301: CALL_OW 85
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
18305: LD_EXP 21
18309: PPUSH
18310: LD_STRING DEnd-JMM-Dol-1
18312: PPUSH
18313: CALL_OW 88
// end ; if IsOK ( Kapitsova ) then
18317: LD_EXP 23
18321: PPUSH
18322: CALL_OW 302
18326: IFFALSE 18349
// begin CenterOnUnits ( Kapitsova ) ;
18328: LD_EXP 23
18332: PPUSH
18333: CALL_OW 85
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
18337: LD_EXP 23
18341: PPUSH
18342: LD_STRING DEnd-JMM-Kap-1
18344: PPUSH
18345: CALL_OW 88
// end ; if IsOK ( Gleb ) then
18349: LD_EXP 22
18353: PPUSH
18354: CALL_OW 302
18358: IFFALSE 18381
// begin CenterOnUnits ( Gleb ) ;
18360: LD_EXP 22
18364: PPUSH
18365: CALL_OW 85
// Say ( Gleb , DEnd-JMM-Glb-1 ) ;
18369: LD_EXP 22
18373: PPUSH
18374: LD_STRING DEnd-JMM-Glb-1
18376: PPUSH
18377: CALL_OW 88
// end ; if IsOK ( Kovalyuk ) then
18381: LD_EXP 25
18385: PPUSH
18386: CALL_OW 302
18390: IFFALSE 18413
// begin CenterOnUnits ( Kovalyuk ) ;
18392: LD_EXP 25
18396: PPUSH
18397: CALL_OW 85
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
18401: LD_EXP 25
18405: PPUSH
18406: LD_STRING DEnd-JMM-Kov-1
18408: PPUSH
18409: CALL_OW 88
// end ; if IsOK ( Scholtze ) then
18413: LD_EXP 26
18417: PPUSH
18418: CALL_OW 302
18422: IFFALSE 18445
// begin CenterOnUnits ( Scholtze ) ;
18424: LD_EXP 26
18428: PPUSH
18429: CALL_OW 85
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
18433: LD_EXP 26
18437: PPUSH
18438: LD_STRING DEnd-JMM-Sch-1
18440: PPUSH
18441: CALL_OW 88
// end ; if IsOK ( Titov ) then
18445: LD_EXP 28
18449: PPUSH
18450: CALL_OW 302
18454: IFFALSE 18477
// begin CenterOnUnits ( Titov ) ;
18456: LD_EXP 28
18460: PPUSH
18461: CALL_OW 85
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
18465: LD_EXP 28
18469: PPUSH
18470: LD_STRING DEnd-JMM-Tit-1
18472: PPUSH
18473: CALL_OW 88
// end ; if IsOK ( Oblukov ) then
18477: LD_EXP 29
18481: PPUSH
18482: CALL_OW 302
18486: IFFALSE 18509
// begin CenterOnUnits ( Oblukov ) ;
18488: LD_EXP 29
18492: PPUSH
18493: CALL_OW 85
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
18497: LD_EXP 29
18501: PPUSH
18502: LD_STRING DEnd-JMM-Obl-1
18504: PPUSH
18505: CALL_OW 88
// end ; if IsOK ( Bystrov ) then
18509: LD_EXP 32
18513: PPUSH
18514: CALL_OW 302
18518: IFFALSE 18541
// begin CenterOnUnits ( Bystrov ) ;
18520: LD_EXP 32
18524: PPUSH
18525: CALL_OW 85
// Say ( Bystrov , DEnd-JMM-Bys-1 ) ;
18529: LD_EXP 32
18533: PPUSH
18534: LD_STRING DEnd-JMM-Bys-1
18536: PPUSH
18537: CALL_OW 88
// end ; if IsOK ( Lipshchin ) then
18541: LD_EXP 33
18545: PPUSH
18546: CALL_OW 302
18550: IFFALSE 18573
// begin CenterOnUnits ( Lipshchin ) ;
18552: LD_EXP 33
18556: PPUSH
18557: CALL_OW 85
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
18561: LD_EXP 33
18565: PPUSH
18566: LD_STRING DEnd-JMM-Lip-1
18568: PPUSH
18569: CALL_OW 88
// end ; end ; end_of_file
18573: LD_VAR 0 1
18577: RET
// var id_reg , id_def ; var BaseArea , DefendArea , Heal ; var docs ; var healing_un , wounded_un ; var central_base , mc_id_defend ; export function init_defend ; var side ; begin
18578: LD_INT 0
18580: PPUSH
18581: PPUSH
// BaseArea := [ us_base , ar_base , ru_base ] ;
18582: LD_ADDR_LOC 14
18586: PUSH
18587: LD_INT 11
18589: PUSH
18590: LD_INT 13
18592: PUSH
18593: LD_INT 12
18595: PUSH
18596: EMPTY
18597: LIST
18598: LIST
18599: LIST
18600: ST_TO_ADDR
// DefendArea := [ us_defend_base , ar_defend_base , ru_base ] ;
18601: LD_ADDR_LOC 15
18605: PUSH
18606: LD_INT 36
18608: PUSH
18609: LD_INT 37
18611: PUSH
18612: LD_INT 12
18614: PUSH
18615: EMPTY
18616: LIST
18617: LIST
18618: LIST
18619: ST_TO_ADDR
// Heal := [ us_heal , ar_heal , ru_heal ] ;
18620: LD_ADDR_LOC 16
18624: PUSH
18625: LD_INT 16
18627: PUSH
18628: LD_INT 14
18630: PUSH
18631: LD_INT 15
18633: PUSH
18634: EMPTY
18635: LIST
18636: LIST
18637: LIST
18638: ST_TO_ADDR
// docs := [ [ ] , [ ] , [ ] , [ ] , [ ] , [ ] , [ ] , [ ] ] ;
18639: LD_ADDR_LOC 17
18643: PUSH
18644: EMPTY
18645: PUSH
18646: EMPTY
18647: PUSH
18648: EMPTY
18649: PUSH
18650: EMPTY
18651: PUSH
18652: EMPTY
18653: PUSH
18654: EMPTY
18655: PUSH
18656: EMPTY
18657: PUSH
18658: EMPTY
18659: PUSH
18660: EMPTY
18661: LIST
18662: LIST
18663: LIST
18664: LIST
18665: LIST
18666: LIST
18667: LIST
18668: LIST
18669: ST_TO_ADDR
// central_base := [ [ 44 , 62 ] , [ 251 , 193 ] , [ 177 , 72 ] ] ;
18670: LD_ADDR_LOC 20
18674: PUSH
18675: LD_INT 44
18677: PUSH
18678: LD_INT 62
18680: PUSH
18681: EMPTY
18682: LIST
18683: LIST
18684: PUSH
18685: LD_INT 251
18687: PUSH
18688: LD_INT 193
18690: PUSH
18691: EMPTY
18692: LIST
18693: LIST
18694: PUSH
18695: LD_INT 177
18697: PUSH
18698: LD_INT 72
18700: PUSH
18701: EMPTY
18702: LIST
18703: LIST
18704: PUSH
18705: EMPTY
18706: LIST
18707: LIST
18708: LIST
18709: ST_TO_ADDR
// healing_un := [ ] ;
18710: LD_ADDR_LOC 18
18714: PUSH
18715: EMPTY
18716: ST_TO_ADDR
// wounded_un := [ ] ;
18717: LD_ADDR_LOC 19
18721: PUSH
18722: EMPTY
18723: ST_TO_ADDR
// mc_id_defend := false ;
18724: LD_ADDR_LOC 21
18728: PUSH
18729: LD_INT 0
18731: ST_TO_ADDR
// start_defend ;
18732: CALL 18992 0 0
// end ;
18736: LD_VAR 0 1
18740: RET
// function prepare_defend ( side ) ; var seznam , def_buildings , def_vehicles , def_peoples ; begin
18741: LD_INT 0
18743: PPUSH
18744: PPUSH
18745: PPUSH
18746: PPUSH
18747: PPUSH
// def_buildings := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ] ) ;
18748: LD_ADDR_VAR 0 4
18752: PUSH
18753: LD_INT 22
18755: PUSH
18756: LD_VAR 0 1
18760: PUSH
18761: EMPTY
18762: LIST
18763: LIST
18764: PUSH
18765: LD_INT 2
18767: PUSH
18768: LD_INT 30
18770: PUSH
18771: LD_INT 32
18773: PUSH
18774: EMPTY
18775: LIST
18776: LIST
18777: PUSH
18778: LD_INT 30
18780: PUSH
18781: LD_INT 31
18783: PUSH
18784: EMPTY
18785: LIST
18786: LIST
18787: PUSH
18788: EMPTY
18789: LIST
18790: LIST
18791: LIST
18792: PUSH
18793: EMPTY
18794: LIST
18795: LIST
18796: PPUSH
18797: CALL_OW 69
18801: ST_TO_ADDR
// def_peoples := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , f_not , [ f_class , class_scientistic ] ] ) ;
18802: LD_ADDR_VAR 0 6
18806: PUSH
18807: LD_INT 22
18809: PUSH
18810: LD_VAR 0 1
18814: PUSH
18815: EMPTY
18816: LIST
18817: LIST
18818: PUSH
18819: LD_INT 21
18821: PUSH
18822: LD_INT 1
18824: PUSH
18825: EMPTY
18826: LIST
18827: LIST
18828: PUSH
18829: LD_INT 3
18831: PUSH
18832: LD_INT 25
18834: PUSH
18835: LD_INT 4
18837: PUSH
18838: EMPTY
18839: LIST
18840: LIST
18841: PUSH
18842: EMPTY
18843: LIST
18844: LIST
18845: LIST
18846: LIST
18847: PPUSH
18848: CALL_OW 69
18852: ST_TO_ADDR
// def_vehicles := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , f_not , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ] ) ;
18853: LD_ADDR_VAR 0 5
18857: PUSH
18858: LD_INT 22
18860: PUSH
18861: LD_VAR 0 1
18865: PUSH
18866: EMPTY
18867: LIST
18868: LIST
18869: PUSH
18870: LD_INT 21
18872: PUSH
18873: LD_INT 2
18875: PUSH
18876: EMPTY
18877: LIST
18878: LIST
18879: PUSH
18880: LD_INT 3
18882: PUSH
18883: LD_INT 2
18885: PUSH
18886: LD_INT 34
18888: PUSH
18889: LD_INT 12
18891: PUSH
18892: EMPTY
18893: LIST
18894: LIST
18895: PUSH
18896: LD_INT 34
18898: PUSH
18899: LD_INT 13
18901: PUSH
18902: EMPTY
18903: LIST
18904: LIST
18905: PUSH
18906: LD_INT 34
18908: PUSH
18909: LD_INT 32
18911: PUSH
18912: EMPTY
18913: LIST
18914: LIST
18915: PUSH
18916: LD_INT 34
18918: PUSH
18919: LD_INT 51
18921: PUSH
18922: EMPTY
18923: LIST
18924: LIST
18925: PUSH
18926: LD_INT 34
18928: PUSH
18929: LD_INT 52
18931: PUSH
18932: EMPTY
18933: LIST
18934: LIST
18935: PUSH
18936: EMPTY
18937: LIST
18938: LIST
18939: LIST
18940: LIST
18941: LIST
18942: LIST
18943: PUSH
18944: EMPTY
18945: LIST
18946: LIST
18947: LIST
18948: LIST
18949: PPUSH
18950: CALL_OW 69
18954: ST_TO_ADDR
// seznam := def_buildings ^ def_peoples ^ def_vehicles ;
18955: LD_ADDR_VAR 0 3
18959: PUSH
18960: LD_VAR 0 4
18964: PUSH
18965: LD_VAR 0 6
18969: ADD
18970: PUSH
18971: LD_VAR 0 5
18975: ADD
18976: ST_TO_ADDR
// result := seznam ;
18977: LD_ADDR_VAR 0 2
18981: PUSH
18982: LD_VAR 0 3
18986: ST_TO_ADDR
// end ;
18987: LD_VAR 0 2
18991: RET
// function start_defend ; var side ; begin
18992: LD_INT 0
18994: PPUSH
18995: PPUSH
// id_reg := [ ] ;
18996: LD_ADDR_LOC 12
19000: PUSH
19001: EMPTY
19002: ST_TO_ADDR
// id_def := [ ] ;
19003: LD_ADDR_LOC 13
19007: PUSH
19008: EMPTY
19009: ST_TO_ADDR
// for side = 1 to 8 do
19010: LD_ADDR_VAR 0 2
19014: PUSH
19015: DOUBLE
19016: LD_INT 1
19018: DEC
19019: ST_TO_ADDR
19020: LD_INT 8
19022: PUSH
19023: FOR_TO
19024: IFFALSE 19280
// if side in cpu_list then
19026: LD_VAR 0 2
19030: PUSH
19031: LD_EXP 8
19035: IN
19036: IFFALSE 19244
// begin id_reg := id_reg ^ McRegistry ( 1 , [ [ mc_reg_refresh_time , 0 0$1 ] , [ mc_reg_expire_stops_to_attack , 0 0$4 ] , [ mc_reg_area_to_guard , BaseArea [ side ] ] , [ mc_reg_area_to_protect , BaseArea [ side ] ] , [ mc_reg_units_to_protect , prepare_defend ( side ) ] , mc_reg_only_important , - mc_reg_ignore_fog ] ) ;
19038: LD_ADDR_LOC 12
19042: PUSH
19043: LD_LOC 12
19047: PUSH
19048: LD_INT 1
19050: PPUSH
19051: LD_INT 1
19053: PUSH
19054: LD_INT 35
19056: PUSH
19057: EMPTY
19058: LIST
19059: LIST
19060: PUSH
19061: LD_INT 5
19063: PUSH
19064: LD_INT 140
19066: PUSH
19067: EMPTY
19068: LIST
19069: LIST
19070: PUSH
19071: LD_INT 2
19073: PUSH
19074: LD_LOC 14
19078: PUSH
19079: LD_VAR 0 2
19083: ARRAY
19084: PUSH
19085: EMPTY
19086: LIST
19087: LIST
19088: PUSH
19089: LD_INT 3
19091: PUSH
19092: LD_LOC 14
19096: PUSH
19097: LD_VAR 0 2
19101: ARRAY
19102: PUSH
19103: EMPTY
19104: LIST
19105: LIST
19106: PUSH
19107: LD_INT 4
19109: PUSH
19110: LD_VAR 0 2
19114: PPUSH
19115: CALL 18741 0 1
19119: PUSH
19120: EMPTY
19121: LIST
19122: LIST
19123: PUSH
19124: LD_INT 8
19126: PUSH
19127: LD_INT 7
19129: NEG
19130: PUSH
19131: EMPTY
19132: LIST
19133: LIST
19134: LIST
19135: LIST
19136: LIST
19137: LIST
19138: LIST
19139: PPUSH
19140: CALL_OW 399
19144: ADD
19145: ST_TO_ADDR
// id_def := id_def ^ McDefend ( 200 , id_reg , prepare_defend ( side ) , [ [ mc_def_advantage , 5000 ] , [ mc_area_dont_leave , BaseArea [ side ] ] , [ mc_retreat_area_people , Heal [ side ] ] , [ mc_retreat_lives_people , 600 ] , ] ) ;
19146: LD_ADDR_LOC 13
19150: PUSH
19151: LD_LOC 13
19155: PUSH
19156: LD_INT 200
19158: PPUSH
19159: LD_LOC 12
19163: PPUSH
19164: LD_VAR 0 2
19168: PPUSH
19169: CALL 18741 0 1
19173: PPUSH
19174: LD_INT 1
19176: PUSH
19177: LD_INT 5000
19179: PUSH
19180: EMPTY
19181: LIST
19182: LIST
19183: PUSH
19184: LD_INT 2
19186: PUSH
19187: LD_LOC 14
19191: PUSH
19192: LD_VAR 0 2
19196: ARRAY
19197: PUSH
19198: EMPTY
19199: LIST
19200: LIST
19201: PUSH
19202: LD_INT 7
19204: PUSH
19205: LD_LOC 16
19209: PUSH
19210: LD_VAR 0 2
19214: ARRAY
19215: PUSH
19216: EMPTY
19217: LIST
19218: LIST
19219: PUSH
19220: LD_INT 5
19222: PUSH
19223: LD_INT 600
19225: PUSH
19226: EMPTY
19227: LIST
19228: LIST
19229: PUSH
19230: EMPTY
19231: LIST
19232: LIST
19233: LIST
19234: LIST
19235: PPUSH
19236: CALL_OW 401
19240: ADD
19241: ST_TO_ADDR
// end else
19242: GO 19278
// begin id_reg := id_reg ^ [ 0 ] ;
19244: LD_ADDR_LOC 12
19248: PUSH
19249: LD_LOC 12
19253: PUSH
19254: LD_INT 0
19256: PUSH
19257: EMPTY
19258: LIST
19259: ADD
19260: ST_TO_ADDR
// id_def := id_reg ^ [ 0 ] ;
19261: LD_ADDR_LOC 13
19265: PUSH
19266: LD_LOC 12
19270: PUSH
19271: LD_INT 0
19273: PUSH
19274: EMPTY
19275: LIST
19276: ADD
19277: ST_TO_ADDR
// end ;
19278: GO 19023
19280: POP
19281: POP
// end ;
19282: LD_VAR 0 1
19286: RET
// on McRegistryResultChanges ( mcid , n , s ) do var side ;
19287: LD_INT 0
19289: PPUSH
// begin for side = 1 to id_reg do
19290: LD_ADDR_VAR 0 4
19294: PUSH
19295: DOUBLE
19296: LD_INT 1
19298: DEC
19299: ST_TO_ADDR
19300: LD_LOC 12
19304: PUSH
19305: FOR_TO
19306: IFFALSE 19358
// if id_reg [ side ] = mcid then
19308: LD_LOC 12
19312: PUSH
19313: LD_VAR 0 4
19317: ARRAY
19318: PUSH
19319: LD_VAR 0 1
19323: EQUAL
19324: IFFALSE 19356
// begin AddMcUnits ( mcid , prepare_defend ( side ) ) ;
19326: LD_VAR 0 1
19330: PPUSH
19331: LD_VAR 0 4
19335: PPUSH
19336: CALL 18741 0 1
19340: PPUSH
19341: CALL_OW 390
// SendForces ( side ) ;
19345: LD_VAR 0 4
19349: PPUSH
19350: CALL 20503 0 1
// break ;
19354: GO 19358
// end ;
19356: GO 19305
19358: POP
19359: POP
// end ;
19360: PPOPN 4
19362: END
// every 0 0$7.7 do var side , list ;
19363: GO 19365
19365: DISABLE
19366: LD_INT 0
19368: PPUSH
19369: PPUSH
// begin list := [ ] ;
19370: LD_ADDR_VAR 0 2
19374: PUSH
19375: EMPTY
19376: ST_TO_ADDR
// for side = 1 to 8 do
19377: LD_ADDR_VAR 0 1
19381: PUSH
19382: DOUBLE
19383: LD_INT 1
19385: DEC
19386: ST_TO_ADDR
19387: LD_INT 8
19389: PUSH
19390: FOR_TO
19391: IFFALSE 19536
// if ( not side in cpu_list ) and id_reg [ side ] then
19393: LD_VAR 0 1
19397: PUSH
19398: LD_EXP 8
19402: IN
19403: NOT
19404: PUSH
19405: LD_LOC 12
19409: PUSH
19410: LD_VAR 0 1
19414: ARRAY
19415: AND
19416: IFFALSE 19534
// begin KillMc ( id_reg [ side ] ) ;
19418: LD_LOC 12
19422: PUSH
19423: LD_VAR 0 1
19427: ARRAY
19428: PPUSH
19429: CALL_OW 387
// id_reg := Delete ( id_reg , side ) ;
19433: LD_ADDR_LOC 12
19437: PUSH
19438: LD_LOC 12
19442: PPUSH
19443: LD_VAR 0 1
19447: PPUSH
19448: CALL_OW 3
19452: ST_TO_ADDR
// id_reg := Insert ( id_reg , side , 0 ) ;
19453: LD_ADDR_LOC 12
19457: PUSH
19458: LD_LOC 12
19462: PPUSH
19463: LD_VAR 0 1
19467: PPUSH
19468: LD_INT 0
19470: PPUSH
19471: CALL_OW 2
19475: ST_TO_ADDR
// KillMc ( id_def [ side ] ) ;
19476: LD_LOC 13
19480: PUSH
19481: LD_VAR 0 1
19485: ARRAY
19486: PPUSH
19487: CALL_OW 387
// id_def := Delete ( id_def , side ) ;
19491: LD_ADDR_LOC 13
19495: PUSH
19496: LD_LOC 13
19500: PPUSH
19501: LD_VAR 0 1
19505: PPUSH
19506: CALL_OW 3
19510: ST_TO_ADDR
// id_def := Insert ( id_def , side , 0 ) ;
19511: LD_ADDR_LOC 13
19515: PUSH
19516: LD_LOC 13
19520: PPUSH
19521: LD_VAR 0 1
19525: PPUSH
19526: LD_INT 0
19528: PPUSH
19529: CALL_OW 2
19533: ST_TO_ADDR
// end ;
19534: GO 19390
19536: POP
19537: POP
// enable ;
19538: ENABLE
// end ;
19539: PPOPN 2
19541: END
// every 0 0$5.3 do var side , sci , list , wounded , un ;
19542: GO 19544
19544: DISABLE
19545: LD_INT 0
19547: PPUSH
19548: PPUSH
19549: PPUSH
19550: PPUSH
19551: PPUSH
// begin for side = 1 to 8 do
19552: LD_ADDR_VAR 0 1
19556: PUSH
19557: DOUBLE
19558: LD_INT 1
19560: DEC
19561: ST_TO_ADDR
19562: LD_INT 8
19564: PUSH
19565: FOR_TO
19566: IFFALSE 20000
// if side in cpu_list then
19568: LD_VAR 0 1
19572: PUSH
19573: LD_EXP 8
19577: IN
19578: IFFALSE 19998
// begin wounded := FilterUnitsInArea ( Heal [ side ] , [ [ f_side , side ] , [ f_type , unit_human ] , f_not , [ f_lives , 1000 ] ] ) ;
19580: LD_ADDR_VAR 0 4
19584: PUSH
19585: LD_LOC 16
19589: PUSH
19590: LD_VAR 0 1
19594: ARRAY
19595: PPUSH
19596: LD_INT 22
19598: PUSH
19599: LD_VAR 0 1
19603: PUSH
19604: EMPTY
19605: LIST
19606: LIST
19607: PUSH
19608: LD_INT 21
19610: PUSH
19611: LD_INT 1
19613: PUSH
19614: EMPTY
19615: LIST
19616: LIST
19617: PUSH
19618: LD_INT 3
19620: PUSH
19621: LD_INT 24
19623: PUSH
19624: LD_INT 1000
19626: PUSH
19627: EMPTY
19628: LIST
19629: LIST
19630: PUSH
19631: EMPTY
19632: LIST
19633: LIST
19634: LIST
19635: LIST
19636: PPUSH
19637: CALL_OW 70
19641: ST_TO_ADDR
// if wounded then
19642: LD_VAR 0 4
19646: IFFALSE 19856
// begin if not docs [ side ] then
19648: LD_LOC 17
19652: PUSH
19653: LD_VAR 0 1
19657: ARRAY
19658: NOT
19659: IFFALSE 19823
// begin sci := request_people ( side , class_scientistic , 5 ) ;
19661: LD_ADDR_VAR 0 2
19665: PUSH
19666: LD_VAR 0 1
19670: PPUSH
19671: LD_INT 4
19673: PPUSH
19674: LD_INT 5
19676: PPUSH
19677: CALL 26825 0 3
19681: ST_TO_ADDR
// docs := Delete ( docs , side ) ;
19682: LD_ADDR_LOC 17
19686: PUSH
19687: LD_LOC 17
19691: PPUSH
19692: LD_VAR 0 1
19696: PPUSH
19697: CALL_OW 3
19701: ST_TO_ADDR
// docs := Insert ( docs , side , sci ) ;
19702: LD_ADDR_LOC 17
19706: PUSH
19707: LD_LOC 17
19711: PPUSH
19712: LD_VAR 0 1
19716: PPUSH
19717: LD_VAR 0 2
19721: PPUSH
19722: CALL_OW 2
19726: ST_TO_ADDR
// list := reserved_people [ side ] ^ sci ;
19727: LD_ADDR_VAR 0 3
19731: PUSH
19732: LD_EXP 73
19736: PUSH
19737: LD_VAR 0 1
19741: ARRAY
19742: PUSH
19743: LD_VAR 0 2
19747: ADD
19748: ST_TO_ADDR
// reserved_people := Delete ( reserved_people , side ) ;
19749: LD_ADDR_EXP 73
19753: PUSH
19754: LD_EXP 73
19758: PPUSH
19759: LD_VAR 0 1
19763: PPUSH
19764: CALL_OW 3
19768: ST_TO_ADDR
// reserved_people := Insert ( reserved_people , side , list ) ;
19769: LD_ADDR_EXP 73
19773: PUSH
19774: LD_EXP 73
19778: PPUSH
19779: LD_VAR 0 1
19783: PPUSH
19784: LD_VAR 0 3
19788: PPUSH
19789: CALL_OW 2
19793: ST_TO_ADDR
// ComRemember ( sci ) ;
19794: LD_VAR 0 2
19798: PPUSH
19799: CALL_OW 143
// ComMoveToArea ( sci , Heal [ side ] ) ;
19803: LD_VAR 0 2
19807: PPUSH
19808: LD_LOC 16
19812: PUSH
19813: LD_VAR 0 1
19817: ARRAY
19818: PPUSH
19819: CALL_OW 113
// end ; for un in wounded do
19823: LD_ADDR_VAR 0 5
19827: PUSH
19828: LD_VAR 0 4
19832: PUSH
19833: FOR_IN
19834: IFFALSE 19852
// AddComHeal ( sci , un ) ;
19836: LD_VAR 0 2
19840: PPUSH
19841: LD_VAR 0 5
19845: PPUSH
19846: CALL_OW 188
19850: GO 19833
19852: POP
19853: POP
// end else
19854: GO 19998
// if docs [ side ] then
19856: LD_LOC 17
19860: PUSH
19861: LD_VAR 0 1
19865: ARRAY
19866: IFFALSE 19998
// begin list := reserved_people [ side ] diff docs [ side ] ;
19868: LD_ADDR_VAR 0 3
19872: PUSH
19873: LD_EXP 73
19877: PUSH
19878: LD_VAR 0 1
19882: ARRAY
19883: PUSH
19884: LD_LOC 17
19888: PUSH
19889: LD_VAR 0 1
19893: ARRAY
19894: DIFF
19895: ST_TO_ADDR
// reserved_people := Delete ( reserved_people , side ) ;
19896: LD_ADDR_EXP 73
19900: PUSH
19901: LD_EXP 73
19905: PPUSH
19906: LD_VAR 0 1
19910: PPUSH
19911: CALL_OW 3
19915: ST_TO_ADDR
// reserved_people := Insert ( reserved_people , side , list ) ;
19916: LD_ADDR_EXP 73
19920: PUSH
19921: LD_EXP 73
19925: PPUSH
19926: LD_VAR 0 1
19930: PPUSH
19931: LD_VAR 0 3
19935: PPUSH
19936: CALL_OW 2
19940: ST_TO_ADDR
// ComReturn ( docs [ side ] ) ;
19941: LD_LOC 17
19945: PUSH
19946: LD_VAR 0 1
19950: ARRAY
19951: PPUSH
19952: CALL_OW 144
// docs := Delete ( docs , side ) ;
19956: LD_ADDR_LOC 17
19960: PUSH
19961: LD_LOC 17
19965: PPUSH
19966: LD_VAR 0 1
19970: PPUSH
19971: CALL_OW 3
19975: ST_TO_ADDR
// docs := Insert ( docs , side , [ ] ) ;
19976: LD_ADDR_LOC 17
19980: PUSH
19981: LD_LOC 17
19985: PPUSH
19986: LD_VAR 0 1
19990: PPUSH
19991: EMPTY
19992: PPUSH
19993: CALL_OW 2
19997: ST_TO_ADDR
// end ; end ;
19998: GO 19565
20000: POP
20001: POP
// enable ;
20002: ENABLE
// end ;
20003: PPOPN 5
20005: END
// every 0 0$3.1 do var list , self ;
20006: GO 20008
20008: DISABLE
20009: LD_INT 0
20011: PPUSH
20012: PPUSH
// begin list := FilterUnitsInArea ( ar_base , [ [ f_side , you ] , [ f_ok ] ] ) ;
20013: LD_ADDR_VAR 0 1
20017: PUSH
20018: LD_INT 13
20020: PPUSH
20021: LD_INT 22
20023: PUSH
20024: LD_EXP 1
20028: PUSH
20029: EMPTY
20030: LIST
20031: LIST
20032: PUSH
20033: LD_INT 50
20035: PUSH
20036: EMPTY
20037: LIST
20038: PUSH
20039: EMPTY
20040: LIST
20041: LIST
20042: PPUSH
20043: CALL_OW 70
20047: ST_TO_ADDR
// if list then
20048: LD_VAR 0 1
20052: IFFALSE 20149
// begin self := FilterAllUnits ( [ [ f_side , ar ] , [ f_type , unit_vehicle ] , [ f_weapon , ar_selfpropelled_bomb ] ] ) ;
20054: LD_ADDR_VAR 0 2
20058: PUSH
20059: LD_INT 22
20061: PUSH
20062: LD_EXP 4
20066: PUSH
20067: EMPTY
20068: LIST
20069: LIST
20070: PUSH
20071: LD_INT 21
20073: PUSH
20074: LD_INT 2
20076: PUSH
20077: EMPTY
20078: LIST
20079: LIST
20080: PUSH
20081: LD_INT 34
20083: PUSH
20084: LD_INT 29
20086: PUSH
20087: EMPTY
20088: LIST
20089: LIST
20090: PUSH
20091: EMPTY
20092: LIST
20093: LIST
20094: LIST
20095: PPUSH
20096: CALL_OW 69
20100: ST_TO_ADDR
// if self then
20101: LD_VAR 0 2
20105: IFFALSE 20123
// self := self [ 1 ] else
20107: LD_ADDR_VAR 0 2
20111: PUSH
20112: LD_VAR 0 2
20116: PUSH
20117: LD_INT 1
20119: ARRAY
20120: ST_TO_ADDR
20121: GO 20125
// exit ;
20123: GO 20150
// ComAttackUnit ( self , NearestUnitToUnit ( list , self ) ) ;
20125: LD_VAR 0 2
20129: PPUSH
20130: LD_VAR 0 1
20134: PPUSH
20135: LD_VAR 0 2
20139: PPUSH
20140: CALL_OW 74
20144: PPUSH
20145: CALL_OW 115
// ; end ; enable ;
20149: ENABLE
// end ;
20150: PPOPN 2
20152: END
// every 0 0$3 do var side , list ;
20153: GO 20155
20155: DISABLE
20156: LD_INT 0
20158: PPUSH
20159: PPUSH
// begin for side in cpu_list do
20160: LD_ADDR_VAR 0 1
20164: PUSH
20165: LD_EXP 8
20169: PUSH
20170: FOR_IN
20171: IFFALSE 20260
// if side then
20173: LD_VAR 0 1
20177: IFFALSE 20258
// begin list := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , f_not , [ f_lives , 800 ] ] ) diff healing_un ;
20179: LD_ADDR_VAR 0 2
20183: PUSH
20184: LD_INT 22
20186: PUSH
20187: LD_VAR 0 1
20191: PUSH
20192: EMPTY
20193: LIST
20194: LIST
20195: PUSH
20196: LD_INT 21
20198: PUSH
20199: LD_INT 1
20201: PUSH
20202: EMPTY
20203: LIST
20204: LIST
20205: PUSH
20206: LD_INT 3
20208: PUSH
20209: LD_INT 24
20211: PUSH
20212: LD_INT 800
20214: PUSH
20215: EMPTY
20216: LIST
20217: LIST
20218: PUSH
20219: EMPTY
20220: LIST
20221: LIST
20222: LIST
20223: LIST
20224: PPUSH
20225: CALL_OW 69
20229: PUSH
20230: LD_LOC 18
20234: DIFF
20235: ST_TO_ADDR
// if list then
20236: LD_VAR 0 2
20240: IFFALSE 20258
// wounded_un := wounded_un ^ list ;
20242: LD_ADDR_LOC 19
20246: PUSH
20247: LD_LOC 19
20251: PUSH
20252: LD_VAR 0 2
20256: ADD
20257: ST_TO_ADDR
// end ;
20258: GO 20170
20260: POP
20261: POP
// enable ;
20262: ENABLE
// end ;
20263: PPOPN 2
20265: END
// every 0 0$2 do var list , un ;
20266: GO 20268
20268: DISABLE
20269: LD_INT 0
20271: PPUSH
20272: PPUSH
// begin for un in wounded_un do
20273: LD_ADDR_VAR 0 2
20277: PUSH
20278: LD_LOC 19
20282: PUSH
20283: FOR_IN
20284: IFFALSE 20370
// if not ( un in healing_un ) then
20286: LD_VAR 0 2
20290: PUSH
20291: LD_LOC 18
20295: IN
20296: NOT
20297: IFFALSE 20368
// begin healing_un := healing_un ^ un ;
20299: LD_ADDR_LOC 18
20303: PUSH
20304: LD_LOC 18
20308: PUSH
20309: LD_VAR 0 2
20313: ADD
20314: ST_TO_ADDR
// McCustom ( 100 , un ) ;
20315: LD_INT 100
20317: PPUSH
20318: LD_VAR 0 2
20322: PPUSH
20323: CALL_OW 416
// ComMoveToArea ( un , Heal [ GetSide ( un ) ] ) ;
20327: LD_VAR 0 2
20331: PPUSH
20332: LD_LOC 16
20336: PUSH
20337: LD_VAR 0 2
20341: PPUSH
20342: CALL_OW 255
20346: ARRAY
20347: PPUSH
20348: CALL_OW 113
// wounded_un := wounded_un diff un ;
20352: LD_ADDR_LOC 19
20356: PUSH
20357: LD_LOC 19
20361: PUSH
20362: LD_VAR 0 2
20366: DIFF
20367: ST_TO_ADDR
// end ;
20368: GO 20283
20370: POP
20371: POP
// enable ;
20372: ENABLE
// end ;
20373: PPOPN 2
20375: END
// every 0 0$2 + 0 0$1 do var un ;
20376: GO 20378
20378: DISABLE
20379: LD_INT 0
20381: PPUSH
// begin for un in healing_un do
20382: LD_ADDR_VAR 0 1
20386: PUSH
20387: LD_LOC 18
20391: PUSH
20392: FOR_IN
20393: IFFALSE 20497
// if GetLives ( un ) = 1000 then
20395: LD_VAR 0 1
20399: PPUSH
20400: CALL_OW 256
20404: PUSH
20405: LD_INT 1000
20407: EQUAL
20408: IFFALSE 20442
// begin KillMc ( GetUnitMc ( un ) ) ;
20410: LD_VAR 0 1
20414: PPUSH
20415: CALL_OW 388
20419: PPUSH
20420: CALL_OW 387
// healing_un := healing_un diff un ;
20424: LD_ADDR_LOC 18
20428: PUSH
20429: LD_LOC 18
20433: PUSH
20434: LD_VAR 0 1
20438: DIFF
20439: ST_TO_ADDR
// end else
20440: GO 20495
// if not IsInArea ( un , Heal [ GetSide ( un ) ] ) then
20442: LD_VAR 0 1
20446: PPUSH
20447: LD_LOC 16
20451: PUSH
20452: LD_VAR 0 1
20456: PPUSH
20457: CALL_OW 255
20461: ARRAY
20462: PPUSH
20463: CALL_OW 308
20467: NOT
20468: IFFALSE 20495
// ComMoveToArea ( un , Heal [ GetSide ( un ) ] ) ;
20470: LD_VAR 0 1
20474: PPUSH
20475: LD_LOC 16
20479: PUSH
20480: LD_VAR 0 1
20484: PPUSH
20485: CALL_OW 255
20489: ARRAY
20490: PPUSH
20491: CALL_OW 113
20495: GO 20392
20497: POP
20498: POP
// enable ;
20499: ENABLE
// end ;
20500: PPOPN 1
20502: END
// function SendForces ( side ) ; var un , list , target , defenders ; begin
20503: LD_INT 0
20505: PPUSH
20506: PPUSH
20507: PPUSH
20508: PPUSH
20509: PPUSH
// ComRemember ( defend_forces [ side ] ) ;
20510: LD_EXP 70
20514: PUSH
20515: LD_VAR 0 1
20519: ARRAY
20520: PPUSH
20521: CALL_OW 143
// if ExistMc ( mc_id_defend ) then
20525: LD_LOC 21
20529: PPUSH
20530: CALL_OW 386
20534: IFFALSE 20545
// KillMc ( mc_id_defend ) ;
20536: LD_LOC 21
20540: PPUSH
20541: CALL_OW 387
// mc_id_defend := McCustom ( 500 , defend_forces [ side ] ) ;
20545: LD_ADDR_LOC 21
20549: PUSH
20550: LD_INT 500
20552: PPUSH
20553: LD_EXP 70
20557: PUSH
20558: LD_VAR 0 1
20562: ARRAY
20563: PPUSH
20564: CALL_OW 416
20568: ST_TO_ADDR
// wait ( 1 ) ;
20569: LD_INT 1
20571: PPUSH
20572: CALL_OW 67
// repeat list := FilterUnitsInArea ( DefendArea [ side ] , [ [ f_side , you ] , [ f_ok ] ] ) ;
20576: LD_ADDR_VAR 0 4
20580: PUSH
20581: LD_LOC 15
20585: PUSH
20586: LD_VAR 0 1
20590: ARRAY
20591: PPUSH
20592: LD_INT 22
20594: PUSH
20595: LD_EXP 1
20599: PUSH
20600: EMPTY
20601: LIST
20602: LIST
20603: PUSH
20604: LD_INT 50
20606: PUSH
20607: EMPTY
20608: LIST
20609: PUSH
20610: EMPTY
20611: LIST
20612: LIST
20613: PPUSH
20614: CALL_OW 70
20618: ST_TO_ADDR
// target := NearestUnitToXY ( list , central_base [ side ] [ 1 ] , central_base [ side ] [ 2 ] ) ;
20619: LD_ADDR_VAR 0 5
20623: PUSH
20624: LD_VAR 0 4
20628: PPUSH
20629: LD_LOC 20
20633: PUSH
20634: LD_VAR 0 1
20638: ARRAY
20639: PUSH
20640: LD_INT 1
20642: ARRAY
20643: PPUSH
20644: LD_LOC 20
20648: PUSH
20649: LD_VAR 0 1
20653: ARRAY
20654: PUSH
20655: LD_INT 2
20657: ARRAY
20658: PPUSH
20659: CALL_OW 73
20663: ST_TO_ADDR
// defenders := prepare_defend ( side ) ;
20664: LD_ADDR_VAR 0 6
20668: PUSH
20669: LD_VAR 0 1
20673: PPUSH
20674: CALL 18741 0 1
20678: ST_TO_ADDR
// if list = 0 or defenders = 0 then
20679: LD_VAR 0 4
20683: PUSH
20684: LD_INT 0
20686: EQUAL
20687: PUSH
20688: LD_VAR 0 6
20692: PUSH
20693: LD_INT 0
20695: EQUAL
20696: OR
20697: IFFALSE 20701
// break ;
20699: GO 20816
// for un in defenders do
20701: LD_ADDR_VAR 0 3
20705: PUSH
20706: LD_VAR 0 6
20710: PUSH
20711: FOR_IN
20712: IFFALSE 20803
// if GetWeapon ( un ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ru_rocket ] then
20714: LD_VAR 0 3
20718: PPUSH
20719: CALL_OW 264
20723: PUSH
20724: LD_INT 7
20726: PUSH
20727: LD_INT 28
20729: PUSH
20730: LD_INT 45
20732: PUSH
20733: LD_INT 47
20735: PUSH
20736: EMPTY
20737: LIST
20738: LIST
20739: LIST
20740: LIST
20741: IN
20742: IFFALSE 20781
// ComAttackPlace ( defend_forces [ side ] , GetX ( target ) , GetY ( target ) ) else
20744: LD_EXP 70
20748: PUSH
20749: LD_VAR 0 1
20753: ARRAY
20754: PPUSH
20755: LD_VAR 0 5
20759: PPUSH
20760: CALL_OW 250
20764: PPUSH
20765: LD_VAR 0 5
20769: PPUSH
20770: CALL_OW 251
20774: PPUSH
20775: CALL_OW 116
20779: GO 20801
// ComAttackUnit ( defend_forces [ side ] , target ) ;
20781: LD_EXP 70
20785: PUSH
20786: LD_VAR 0 1
20790: ARRAY
20791: PPUSH
20792: LD_VAR 0 5
20796: PPUSH
20797: CALL_OW 115
20801: GO 20711
20803: POP
20804: POP
// wait ( 50 ) ;
20805: LD_INT 50
20807: PPUSH
20808: CALL_OW 67
// until false ;
20812: LD_INT 0
20814: IFFALSE 20576
// KillMc ( mc_id_defend ) ;
20816: LD_LOC 21
20820: PPUSH
20821: CALL_OW 387
// mc_id_defend := false ;
20825: LD_ADDR_LOC 21
20829: PUSH
20830: LD_INT 0
20832: ST_TO_ADDR
// wait ( 2 ) ;
20833: LD_INT 2
20835: PPUSH
20836: CALL_OW 67
// ComReturn ( defend_forces [ side ] ) ;
20840: LD_EXP 70
20844: PUSH
20845: LD_VAR 0 1
20849: ARRAY
20850: PPUSH
20851: CALL_OW 144
// end ;
20855: LD_VAR 0 2
20859: RET
// every 0 0$5.1 do var side ;
20860: GO 20862
20862: DISABLE
20863: LD_INT 0
20865: PPUSH
// begin for side = 1 to 3 do
20866: LD_ADDR_VAR 0 1
20870: PUSH
20871: DOUBLE
20872: LD_INT 1
20874: DEC
20875: ST_TO_ADDR
20876: LD_INT 3
20878: PUSH
20879: FOR_TO
20880: IFFALSE 21082
// if ( not defend_forces [ side ] ) and ready_forces [ side ] then
20882: LD_EXP 70
20886: PUSH
20887: LD_VAR 0 1
20891: ARRAY
20892: NOT
20893: PUSH
20894: LD_EXP 67
20898: PUSH
20899: LD_VAR 0 1
20903: ARRAY
20904: AND
20905: IFFALSE 21080
// begin defend_forces := Replace ( defend_forces , side , ready_forces [ side ] ) ;
20907: LD_ADDR_EXP 70
20911: PUSH
20912: LD_EXP 70
20916: PPUSH
20917: LD_VAR 0 1
20921: PPUSH
20922: LD_EXP 67
20926: PUSH
20927: LD_VAR 0 1
20931: ARRAY
20932: PPUSH
20933: CALL_OW 1
20937: ST_TO_ADDR
// ready_forces := Replace ( ready_forces , side , [ ] ) ;
20938: LD_ADDR_EXP 67
20942: PUSH
20943: LD_EXP 67
20947: PPUSH
20948: LD_VAR 0 1
20952: PPUSH
20953: EMPTY
20954: PPUSH
20955: CALL_OW 1
20959: ST_TO_ADDR
// jammed_forces := Replace ( jammed_forces , side , jammed_forces [ side ] diff defend_forces [ side ] ) ;
20960: LD_ADDR_EXP 71
20964: PUSH
20965: LD_EXP 71
20969: PPUSH
20970: LD_VAR 0 1
20974: PPUSH
20975: LD_EXP 71
20979: PUSH
20980: LD_VAR 0 1
20984: ARRAY
20985: PUSH
20986: LD_EXP 70
20990: PUSH
20991: LD_VAR 0 1
20995: ARRAY
20996: DIFF
20997: PPUSH
20998: CALL_OW 1
21002: ST_TO_ADDR
// case side of 1 :
21003: LD_VAR 0 1
21007: PUSH
21008: LD_INT 1
21010: DOUBLE
21011: EQUAL
21012: IFTRUE 21016
21014: GO 21040
21016: POP
// ComMoveXY ( defend_forces [ side ] , 40 , 46 ) ; 3 :
21017: LD_EXP 70
21021: PUSH
21022: LD_VAR 0 1
21026: ARRAY
21027: PPUSH
21028: LD_INT 40
21030: PPUSH
21031: LD_INT 46
21033: PPUSH
21034: CALL_OW 111
21038: GO 21073
21040: LD_INT 3
21042: DOUBLE
21043: EQUAL
21044: IFTRUE 21048
21046: GO 21072
21048: POP
// ComMoveXY ( defend_forces [ side ] , 175 , 50 ) ; end ;
21049: LD_EXP 70
21053: PUSH
21054: LD_VAR 0 1
21058: ARRAY
21059: PPUSH
21060: LD_INT 175
21062: PPUSH
21063: LD_INT 50
21065: PPUSH
21066: CALL_OW 111
21070: GO 21073
21072: POP
// wait ( 2 ) ;
21073: LD_INT 2
21075: PPUSH
21076: CALL_OW 67
// end ;
21080: GO 20879
21082: POP
21083: POP
// enable ;
21084: ENABLE
// end ;
21085: PPOPN 1
21087: END
// export function Update_defend ( un ) ; var side ; begin
21088: LD_INT 0
21090: PPUSH
21091: PPUSH
// if GetSide ( un ) = you then
21092: LD_VAR 0 1
21096: PPUSH
21097: CALL_OW 255
21101: PUSH
21102: LD_EXP 1
21106: EQUAL
21107: IFFALSE 21111
// exit ;
21109: GO 21186
// for side = 1 to 3 do
21111: LD_ADDR_VAR 0 3
21115: PUSH
21116: DOUBLE
21117: LD_INT 1
21119: DEC
21120: ST_TO_ADDR
21121: LD_INT 3
21123: PUSH
21124: FOR_TO
21125: IFFALSE 21184
// if un in defend_forces [ side ] then
21127: LD_VAR 0 1
21131: PUSH
21132: LD_EXP 70
21136: PUSH
21137: LD_VAR 0 3
21141: ARRAY
21142: IN
21143: IFFALSE 21182
// defend_forces := Replace ( defend_forces , side , defend_forces [ side ] diff un ) ;
21145: LD_ADDR_EXP 70
21149: PUSH
21150: LD_EXP 70
21154: PPUSH
21155: LD_VAR 0 3
21159: PPUSH
21160: LD_EXP 70
21164: PUSH
21165: LD_VAR 0 3
21169: ARRAY
21170: PUSH
21171: LD_VAR 0 1
21175: DIFF
21176: PPUSH
21177: CALL_OW 1
21181: ST_TO_ADDR
21182: GO 21124
21184: POP
21185: POP
// end ; end_of_file
21186: LD_VAR 0 2
21190: RET
// export ready_forces , attack_forces , retreat_forces , defend_forces , jammed_forces ; var us_ru , us_ar , ru_us , ru_ar ; var last_ar_attack , attack_timing , attack_limit ; var al_eliminate ; var pocet_odebrani ; export function init_attack ; var side ; begin
21191: LD_INT 0
21193: PPUSH
21194: PPUSH
// ready_forces = [ ] ;
21195: LD_ADDR_EXP 67
21199: PUSH
21200: EMPTY
21201: ST_TO_ADDR
// attack_forces = [ ] ;
21202: LD_ADDR_EXP 68
21206: PUSH
21207: EMPTY
21208: ST_TO_ADDR
// retreat_forces = [ ] ;
21209: LD_ADDR_EXP 69
21213: PUSH
21214: EMPTY
21215: ST_TO_ADDR
// defend_forces = [ ] ;
21216: LD_ADDR_EXP 70
21220: PUSH
21221: EMPTY
21222: ST_TO_ADDR
// for side = 1 to 8 do
21223: LD_ADDR_VAR 0 2
21227: PUSH
21228: DOUBLE
21229: LD_INT 1
21231: DEC
21232: ST_TO_ADDR
21233: LD_INT 8
21235: PUSH
21236: FOR_TO
21237: IFFALSE 21321
// begin ready_forces = ready_forces ^ [ [ ] ] ;
21239: LD_ADDR_EXP 67
21243: PUSH
21244: LD_EXP 67
21248: PUSH
21249: EMPTY
21250: PUSH
21251: EMPTY
21252: LIST
21253: ADD
21254: ST_TO_ADDR
// attack_forces = attack_forces ^ [ [ ] ] ;
21255: LD_ADDR_EXP 68
21259: PUSH
21260: LD_EXP 68
21264: PUSH
21265: EMPTY
21266: PUSH
21267: EMPTY
21268: LIST
21269: ADD
21270: ST_TO_ADDR
// retreat_forces = retreat_forces ^ [ [ ] ] ;
21271: LD_ADDR_EXP 69
21275: PUSH
21276: LD_EXP 69
21280: PUSH
21281: EMPTY
21282: PUSH
21283: EMPTY
21284: LIST
21285: ADD
21286: ST_TO_ADDR
// defend_forces = defend_forces ^ [ [ ] ] ;
21287: LD_ADDR_EXP 70
21291: PUSH
21292: LD_EXP 70
21296: PUSH
21297: EMPTY
21298: PUSH
21299: EMPTY
21300: LIST
21301: ADD
21302: ST_TO_ADDR
// jammed_forces = jammed_forces ^ [ [ ] ] ;
21303: LD_ADDR_EXP 71
21307: PUSH
21308: LD_EXP 71
21312: PUSH
21313: EMPTY
21314: PUSH
21315: EMPTY
21316: LIST
21317: ADD
21318: ST_TO_ADDR
// end ;
21319: GO 21236
21321: POP
21322: POP
// us_ru := [ [ 76 , 61 ] , [ 121 , 55 ] , [ 171 , 59 ] , [ 190 , 90 ] ] ;
21323: LD_ADDR_LOC 22
21327: PUSH
21328: LD_INT 76
21330: PUSH
21331: LD_INT 61
21333: PUSH
21334: EMPTY
21335: LIST
21336: LIST
21337: PUSH
21338: LD_INT 121
21340: PUSH
21341: LD_INT 55
21343: PUSH
21344: EMPTY
21345: LIST
21346: LIST
21347: PUSH
21348: LD_INT 171
21350: PUSH
21351: LD_INT 59
21353: PUSH
21354: EMPTY
21355: LIST
21356: LIST
21357: PUSH
21358: LD_INT 190
21360: PUSH
21361: LD_INT 90
21363: PUSH
21364: EMPTY
21365: LIST
21366: LIST
21367: PUSH
21368: EMPTY
21369: LIST
21370: LIST
21371: LIST
21372: LIST
21373: ST_TO_ADDR
// us_ar := [ [ [ 78 , 69 ] , [ 121 , 116 ] , [ 155 , 137 ] , [ 190 , 170 ] , [ 242 , 187 ] ] , [ [ 72 , 106 ] , [ 111 , 176 ] , [ 163 , 184 ] , [ 215 , 191 ] , [ 242 , 187 ] ] ] ;
21374: LD_ADDR_LOC 23
21378: PUSH
21379: LD_INT 78
21381: PUSH
21382: LD_INT 69
21384: PUSH
21385: EMPTY
21386: LIST
21387: LIST
21388: PUSH
21389: LD_INT 121
21391: PUSH
21392: LD_INT 116
21394: PUSH
21395: EMPTY
21396: LIST
21397: LIST
21398: PUSH
21399: LD_INT 155
21401: PUSH
21402: LD_INT 137
21404: PUSH
21405: EMPTY
21406: LIST
21407: LIST
21408: PUSH
21409: LD_INT 190
21411: PUSH
21412: LD_INT 170
21414: PUSH
21415: EMPTY
21416: LIST
21417: LIST
21418: PUSH
21419: LD_INT 242
21421: PUSH
21422: LD_INT 187
21424: PUSH
21425: EMPTY
21426: LIST
21427: LIST
21428: PUSH
21429: EMPTY
21430: LIST
21431: LIST
21432: LIST
21433: LIST
21434: LIST
21435: PUSH
21436: LD_INT 72
21438: PUSH
21439: LD_INT 106
21441: PUSH
21442: EMPTY
21443: LIST
21444: LIST
21445: PUSH
21446: LD_INT 111
21448: PUSH
21449: LD_INT 176
21451: PUSH
21452: EMPTY
21453: LIST
21454: LIST
21455: PUSH
21456: LD_INT 163
21458: PUSH
21459: LD_INT 184
21461: PUSH
21462: EMPTY
21463: LIST
21464: LIST
21465: PUSH
21466: LD_INT 215
21468: PUSH
21469: LD_INT 191
21471: PUSH
21472: EMPTY
21473: LIST
21474: LIST
21475: PUSH
21476: LD_INT 242
21478: PUSH
21479: LD_INT 187
21481: PUSH
21482: EMPTY
21483: LIST
21484: LIST
21485: PUSH
21486: EMPTY
21487: LIST
21488: LIST
21489: LIST
21490: LIST
21491: LIST
21492: PUSH
21493: EMPTY
21494: LIST
21495: LIST
21496: ST_TO_ADDR
// ru_us := [ [ 118 , 63 ] , [ 78 , 57 ] , [ 30 , 44 ] , [ 56 , 83 ] ] ;
21497: LD_ADDR_LOC 24
21501: PUSH
21502: LD_INT 118
21504: PUSH
21505: LD_INT 63
21507: PUSH
21508: EMPTY
21509: LIST
21510: LIST
21511: PUSH
21512: LD_INT 78
21514: PUSH
21515: LD_INT 57
21517: PUSH
21518: EMPTY
21519: LIST
21520: LIST
21521: PUSH
21522: LD_INT 30
21524: PUSH
21525: LD_INT 44
21527: PUSH
21528: EMPTY
21529: LIST
21530: LIST
21531: PUSH
21532: LD_INT 56
21534: PUSH
21535: LD_INT 83
21537: PUSH
21538: EMPTY
21539: LIST
21540: LIST
21541: PUSH
21542: EMPTY
21543: LIST
21544: LIST
21545: LIST
21546: LIST
21547: ST_TO_ADDR
// ru_ar := [ [ [ 142 , 65 ] , [ 160 , 140 ] , [ 255 , 196 ] ] , [ [ 125 , 58 ] , [ 106 , 93 ] , [ 126 , 154 ] , [ 121 , 182 ] , [ 167 , 180 ] , [ 251 , 187 ] ] ] ;
21548: LD_ADDR_LOC 25
21552: PUSH
21553: LD_INT 142
21555: PUSH
21556: LD_INT 65
21558: PUSH
21559: EMPTY
21560: LIST
21561: LIST
21562: PUSH
21563: LD_INT 160
21565: PUSH
21566: LD_INT 140
21568: PUSH
21569: EMPTY
21570: LIST
21571: LIST
21572: PUSH
21573: LD_INT 255
21575: PUSH
21576: LD_INT 196
21578: PUSH
21579: EMPTY
21580: LIST
21581: LIST
21582: PUSH
21583: EMPTY
21584: LIST
21585: LIST
21586: LIST
21587: PUSH
21588: LD_INT 125
21590: PUSH
21591: LD_INT 58
21593: PUSH
21594: EMPTY
21595: LIST
21596: LIST
21597: PUSH
21598: LD_INT 106
21600: PUSH
21601: LD_INT 93
21603: PUSH
21604: EMPTY
21605: LIST
21606: LIST
21607: PUSH
21608: LD_INT 126
21610: PUSH
21611: LD_INT 154
21613: PUSH
21614: EMPTY
21615: LIST
21616: LIST
21617: PUSH
21618: LD_INT 121
21620: PUSH
21621: LD_INT 182
21623: PUSH
21624: EMPTY
21625: LIST
21626: LIST
21627: PUSH
21628: LD_INT 167
21630: PUSH
21631: LD_INT 180
21633: PUSH
21634: EMPTY
21635: LIST
21636: LIST
21637: PUSH
21638: LD_INT 251
21640: PUSH
21641: LD_INT 187
21643: PUSH
21644: EMPTY
21645: LIST
21646: LIST
21647: PUSH
21648: EMPTY
21649: LIST
21650: LIST
21651: LIST
21652: LIST
21653: LIST
21654: LIST
21655: PUSH
21656: EMPTY
21657: LIST
21658: LIST
21659: ST_TO_ADDR
// al_eliminate = [ [ 88 , 53 ] , [ 49 , 10 ] , [ 83 , 13 ] ] ;
21660: LD_ADDR_LOC 29
21664: PUSH
21665: LD_INT 88
21667: PUSH
21668: LD_INT 53
21670: PUSH
21671: EMPTY
21672: LIST
21673: LIST
21674: PUSH
21675: LD_INT 49
21677: PUSH
21678: LD_INT 10
21680: PUSH
21681: EMPTY
21682: LIST
21683: LIST
21684: PUSH
21685: LD_INT 83
21687: PUSH
21688: LD_INT 13
21690: PUSH
21691: EMPTY
21692: LIST
21693: LIST
21694: PUSH
21695: EMPTY
21696: LIST
21697: LIST
21698: LIST
21699: ST_TO_ADDR
// attack_timing = [ 50 , 40 , 30 ] [ difficulty ] ;
21700: LD_ADDR_LOC 27
21704: PUSH
21705: LD_INT 50
21707: PUSH
21708: LD_INT 40
21710: PUSH
21711: LD_INT 30
21713: PUSH
21714: EMPTY
21715: LIST
21716: LIST
21717: LIST
21718: PUSH
21719: LD_OWVAR 67
21723: ARRAY
21724: ST_TO_ADDR
// attack_limit = 0 ;
21725: LD_ADDR_LOC 28
21729: PUSH
21730: LD_INT 0
21732: ST_TO_ADDR
// last_ar_attack = TICK ;
21733: LD_ADDR_LOC 26
21737: PUSH
21738: LD_OWVAR 1
21742: ST_TO_ADDR
// pocet_odebrani = 0 ;
21743: LD_ADDR_LOC 30
21747: PUSH
21748: LD_INT 0
21750: ST_TO_ADDR
// end ;
21751: LD_VAR 0 1
21755: RET
// every 0 0$15.4 do var active_side , num_forces ;
21756: GO 21758
21758: DISABLE
21759: LD_INT 0
21761: PPUSH
21762: PPUSH
// begin num_forces := define_forces_strenght ;
21763: LD_ADDR_VAR 0 2
21767: PUSH
21768: CALL 21828 0 0
21772: ST_TO_ADDR
// for active_side in cpu_list do
21773: LD_ADDR_VAR 0 1
21777: PUSH
21778: LD_EXP 8
21782: PUSH
21783: FOR_IN
21784: IFFALSE 21822
// if ready_forces [ active_side ] >= num_forces then
21786: LD_EXP 67
21790: PUSH
21791: LD_VAR 0 1
21795: ARRAY
21796: PUSH
21797: LD_VAR 0 2
21801: GREATEREQUAL
21802: IFFALSE 21820
// begin let_the_war_begin ( active_side ) ;
21804: LD_VAR 0 1
21808: PPUSH
21809: CALL 23291 0 1
// wait ( 1 ) ;
21813: LD_INT 1
21815: PPUSH
21816: CALL_OW 67
// end ;
21820: GO 21783
21822: POP
21823: POP
// enable ;
21824: ENABLE
// end ;
21825: PPOPN 2
21827: END
// function define_forces_strenght ; var num ; begin
21828: LD_INT 0
21830: PPUSH
21831: PPUSH
// num := 3 ;
21832: LD_ADDR_VAR 0 2
21836: PUSH
21837: LD_INT 3
21839: ST_TO_ADDR
// if TICK > 7 7$0 then
21840: LD_OWVAR 1
21844: PUSH
21845: LD_INT 14700
21847: GREATER
21848: IFFALSE 21858
// num := 4 ;
21850: LD_ADDR_VAR 0 2
21854: PUSH
21855: LD_INT 4
21857: ST_TO_ADDR
// if TICK > 14 14$0 then
21858: LD_OWVAR 1
21862: PUSH
21863: LD_INT 29400
21865: GREATER
21866: IFFALSE 21876
// num := 6 ;
21868: LD_ADDR_VAR 0 2
21872: PUSH
21873: LD_INT 6
21875: ST_TO_ADDR
// result := num ;
21876: LD_ADDR_VAR 0 1
21880: PUSH
21881: LD_VAR 0 2
21885: ST_TO_ADDR
// end ;
21886: LD_VAR 0 1
21890: RET
// function define_target_priority ; var target ; begin
21891: LD_INT 0
21893: PPUSH
21894: PPUSH
// target := Rand ( 0 , attack_timing ) ;
21895: LD_ADDR_VAR 0 2
21899: PUSH
21900: LD_INT 0
21902: PPUSH
21903: LD_LOC 27
21907: PPUSH
21908: CALL_OW 12
21912: ST_TO_ADDR
// if target > attack_limit then
21913: LD_VAR 0 2
21917: PUSH
21918: LD_LOC 28
21922: GREATER
21923: IFFALSE 21935
// target := false else
21925: LD_ADDR_VAR 0 2
21929: PUSH
21930: LD_INT 0
21932: ST_TO_ADDR
21933: GO 21943
// target := true ;
21935: LD_ADDR_VAR 0 2
21939: PUSH
21940: LD_INT 1
21942: ST_TO_ADDR
// result := target ;
21943: LD_ADDR_VAR 0 1
21947: PUSH
21948: LD_VAR 0 2
21952: ST_TO_ADDR
// end ;
21953: LD_VAR 0 1
21957: RET
// every 1 1$0 trigger attack_timing > attack_limit do
21958: LD_LOC 27
21962: PUSH
21963: LD_LOC 28
21967: GREATER
21968: IFFALSE 22002
21970: GO 21972
21972: DISABLE
// begin attack_timing := attack_timing - 1 ;
21973: LD_ADDR_LOC 27
21977: PUSH
21978: LD_LOC 27
21982: PUSH
21983: LD_INT 1
21985: MINUS
21986: ST_TO_ADDR
// attack_limit := attack_limit + 1 ;
21987: LD_ADDR_LOC 28
21991: PUSH
21992: LD_LOC 28
21996: PUSH
21997: LD_INT 1
21999: PLUS
22000: ST_TO_ADDR
// enable ;
22001: ENABLE
// end ;
22002: END
// function Select_Weakest_Base ( areas ) ; var selected , un , list ; begin
22003: LD_INT 0
22005: PPUSH
22006: PPUSH
22007: PPUSH
22008: PPUSH
// selected := false ;
22009: LD_ADDR_VAR 0 3
22013: PUSH
22014: LD_INT 0
22016: ST_TO_ADDR
// for un in areas do
22017: LD_ADDR_VAR 0 4
22021: PUSH
22022: LD_VAR 0 1
22026: PUSH
22027: FOR_IN
22028: IFFALSE 22155
// begin list := FilterUnitsInArea ( un , [ [ f_side , you ] , [ f_type , unit_building ] , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] ] ) ;
22030: LD_ADDR_VAR 0 5
22034: PUSH
22035: LD_VAR 0 4
22039: PPUSH
22040: LD_INT 22
22042: PUSH
22043: LD_EXP 1
22047: PUSH
22048: EMPTY
22049: LIST
22050: LIST
22051: PUSH
22052: LD_INT 21
22054: PUSH
22055: LD_INT 3
22057: PUSH
22058: EMPTY
22059: LIST
22060: LIST
22061: PUSH
22062: LD_INT 2
22064: PUSH
22065: LD_INT 30
22067: PUSH
22068: LD_INT 33
22070: PUSH
22071: EMPTY
22072: LIST
22073: LIST
22074: PUSH
22075: LD_INT 30
22077: PUSH
22078: LD_INT 32
22080: PUSH
22081: EMPTY
22082: LIST
22083: LIST
22084: PUSH
22085: EMPTY
22086: LIST
22087: LIST
22088: LIST
22089: PUSH
22090: EMPTY
22091: LIST
22092: LIST
22093: LIST
22094: PPUSH
22095: CALL_OW 70
22099: ST_TO_ADDR
// if ( not selected ) or ( selected [ 1 ] < list ) then
22100: LD_VAR 0 3
22104: NOT
22105: PUSH
22106: LD_VAR 0 3
22110: PUSH
22111: LD_INT 1
22113: ARRAY
22114: PUSH
22115: LD_VAR 0 5
22119: LESS
22120: OR
22121: IFFALSE 22146
// selected := [ list + 0 , un ] ;
22123: LD_ADDR_VAR 0 3
22127: PUSH
22128: LD_VAR 0 5
22132: PUSH
22133: LD_INT 0
22135: PLUS
22136: PUSH
22137: LD_VAR 0 4
22141: PUSH
22142: EMPTY
22143: LIST
22144: LIST
22145: ST_TO_ADDR
// wait ( 1 ) ;
22146: LD_INT 1
22148: PPUSH
22149: CALL_OW 67
// end ;
22153: GO 22027
22155: POP
22156: POP
// if selected then
22157: LD_VAR 0 3
22161: IFFALSE 22177
// selected := selected [ 2 ] ;
22163: LD_ADDR_VAR 0 3
22167: PUSH
22168: LD_VAR 0 3
22172: PUSH
22173: LD_INT 2
22175: ARRAY
22176: ST_TO_ADDR
// result := selected ;
22177: LD_ADDR_VAR 0 2
22181: PUSH
22182: LD_VAR 0 3
22186: ST_TO_ADDR
// end ;
22187: LD_VAR 0 2
22191: RET
// function Find_Player_Base ; var list , un , goal , areas , defend_tought ; begin
22192: LD_INT 0
22194: PPUSH
22195: PPUSH
22196: PPUSH
22197: PPUSH
22198: PPUSH
22199: PPUSH
// goal := false ;
22200: LD_ADDR_VAR 0 4
22204: PUSH
22205: LD_INT 0
22207: ST_TO_ADDR
// areas := [ ] ;
22208: LD_ADDR_VAR 0 5
22212: PUSH
22213: EMPTY
22214: ST_TO_ADDR
// list := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_building ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
22215: LD_ADDR_VAR 0 2
22219: PUSH
22220: LD_INT 22
22222: PUSH
22223: LD_EXP 1
22227: PUSH
22228: EMPTY
22229: LIST
22230: LIST
22231: PUSH
22232: LD_INT 21
22234: PUSH
22235: LD_INT 3
22237: PUSH
22238: EMPTY
22239: LIST
22240: LIST
22241: PUSH
22242: LD_INT 2
22244: PUSH
22245: LD_INT 30
22247: PUSH
22248: LD_INT 0
22250: PUSH
22251: EMPTY
22252: LIST
22253: LIST
22254: PUSH
22255: LD_INT 30
22257: PUSH
22258: LD_INT 1
22260: PUSH
22261: EMPTY
22262: LIST
22263: LIST
22264: PUSH
22265: EMPTY
22266: LIST
22267: LIST
22268: LIST
22269: PUSH
22270: EMPTY
22271: LIST
22272: LIST
22273: LIST
22274: PPUSH
22275: CALL_OW 69
22279: ST_TO_ADDR
// for un in list do
22280: LD_ADDR_VAR 0 3
22284: PUSH
22285: LD_VAR 0 2
22289: PUSH
22290: FOR_IN
22291: IFFALSE 22390
// begin if IsInArea ( un , ar_base ) then
22293: LD_VAR 0 3
22297: PPUSH
22298: LD_INT 13
22300: PPUSH
22301: CALL_OW 308
22305: IFFALSE 22323
// areas := areas ^ ar_base else
22307: LD_ADDR_VAR 0 5
22311: PUSH
22312: LD_VAR 0 5
22316: PUSH
22317: LD_INT 13
22319: ADD
22320: ST_TO_ADDR
22321: GO 22381
// if IsInArea ( un , us_base ) then
22323: LD_VAR 0 3
22327: PPUSH
22328: LD_INT 11
22330: PPUSH
22331: CALL_OW 308
22335: IFFALSE 22353
// areas := areas ^ us_base else
22337: LD_ADDR_VAR 0 5
22341: PUSH
22342: LD_VAR 0 5
22346: PUSH
22347: LD_INT 11
22349: ADD
22350: ST_TO_ADDR
22351: GO 22381
// if IsInArea ( un , ru_base ) then
22353: LD_VAR 0 3
22357: PPUSH
22358: LD_INT 12
22360: PPUSH
22361: CALL_OW 308
22365: IFFALSE 22381
// areas := areas ^ ru_base ;
22367: LD_ADDR_VAR 0 5
22371: PUSH
22372: LD_VAR 0 5
22376: PUSH
22377: LD_INT 12
22379: ADD
22380: ST_TO_ADDR
// wait ( 1 ) ;
22381: LD_INT 1
22383: PPUSH
22384: CALL_OW 67
// end ;
22388: GO 22290
22390: POP
22391: POP
// if ( not areas ) or ( areas > 1 ) then
22392: LD_VAR 0 5
22396: NOT
22397: PUSH
22398: LD_VAR 0 5
22402: PUSH
22403: LD_INT 1
22405: GREATER
22406: OR
22407: IFFALSE 22426
// goal := Select_Weakest_Base ( areas ) else
22409: LD_ADDR_VAR 0 4
22413: PUSH
22414: LD_VAR 0 5
22418: PPUSH
22419: CALL 22003 0 1
22423: ST_TO_ADDR
22424: GO 22440
// goal := areas [ 1 ] ;
22426: LD_ADDR_VAR 0 4
22430: PUSH
22431: LD_VAR 0 5
22435: PUSH
22436: LD_INT 1
22438: ARRAY
22439: ST_TO_ADDR
// result := goal ;
22440: LD_ADDR_VAR 0 1
22444: PUSH
22445: LD_VAR 0 4
22449: ST_TO_ADDR
// end ;
22450: LD_VAR 0 1
22454: RET
// function GetUnitArea ( un ) ; var area ; begin
22455: LD_INT 0
22457: PPUSH
22458: PPUSH
// case un of 1 :
22459: LD_VAR 0 1
22463: PUSH
22464: LD_INT 1
22466: DOUBLE
22467: EQUAL
22468: IFTRUE 22472
22470: GO 22483
22472: POP
// area := us_base ; 2 :
22473: LD_ADDR_VAR 0 3
22477: PUSH
22478: LD_INT 11
22480: ST_TO_ADDR
22481: GO 22522
22483: LD_INT 2
22485: DOUBLE
22486: EQUAL
22487: IFTRUE 22491
22489: GO 22502
22491: POP
// area := ar_base ; 3 :
22492: LD_ADDR_VAR 0 3
22496: PUSH
22497: LD_INT 13
22499: ST_TO_ADDR
22500: GO 22522
22502: LD_INT 3
22504: DOUBLE
22505: EQUAL
22506: IFTRUE 22510
22508: GO 22521
22510: POP
// area := ru_base ; end ;
22511: LD_ADDR_VAR 0 3
22515: PUSH
22516: LD_INT 12
22518: ST_TO_ADDR
22519: GO 22522
22521: POP
// result := area ;
22522: LD_ADDR_VAR 0 2
22526: PUSH
22527: LD_VAR 0 3
22531: ST_TO_ADDR
// end ;
22532: LD_VAR 0 2
22536: RET
// function Find_CPU_Target ( side ) ; var un , goal , bases , list ; begin
22537: LD_INT 0
22539: PPUSH
22540: PPUSH
22541: PPUSH
22542: PPUSH
22543: PPUSH
// bases := [ ] ;
22544: LD_ADDR_VAR 0 5
22548: PUSH
22549: EMPTY
22550: ST_TO_ADDR
// list := FilterAllUnits ( [ [ f_type , unit_building ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
22551: LD_ADDR_VAR 0 6
22555: PUSH
22556: LD_INT 21
22558: PUSH
22559: LD_INT 3
22561: PUSH
22562: EMPTY
22563: LIST
22564: LIST
22565: PUSH
22566: LD_INT 2
22568: PUSH
22569: LD_INT 30
22571: PUSH
22572: LD_INT 0
22574: PUSH
22575: EMPTY
22576: LIST
22577: LIST
22578: PUSH
22579: LD_INT 30
22581: PUSH
22582: LD_INT 1
22584: PUSH
22585: EMPTY
22586: LIST
22587: LIST
22588: PUSH
22589: EMPTY
22590: LIST
22591: LIST
22592: LIST
22593: PUSH
22594: EMPTY
22595: LIST
22596: LIST
22597: PPUSH
22598: CALL_OW 69
22602: ST_TO_ADDR
// for un in list do
22603: LD_ADDR_VAR 0 3
22607: PUSH
22608: LD_VAR 0 6
22612: PUSH
22613: FOR_IN
22614: IFFALSE 22656
// if GetSide ( un ) <> side then
22616: LD_VAR 0 3
22620: PPUSH
22621: CALL_OW 255
22625: PUSH
22626: LD_VAR 0 1
22630: NONEQUAL
22631: IFFALSE 22654
// bases := bases ^ GetSide ( un ) ;
22633: LD_ADDR_VAR 0 5
22637: PUSH
22638: LD_VAR 0 5
22642: PUSH
22643: LD_VAR 0 3
22647: PPUSH
22648: CALL_OW 255
22652: ADD
22653: ST_TO_ADDR
22654: GO 22613
22656: POP
22657: POP
// bases := bases diff you ;
22658: LD_ADDR_VAR 0 5
22662: PUSH
22663: LD_VAR 0 5
22667: PUSH
22668: LD_EXP 1
22672: DIFF
22673: ST_TO_ADDR
// if bases then
22674: LD_VAR 0 5
22678: IFFALSE 22762
// begin if ( bases diff ar ) and Rand ( 0 , 2 ) then
22680: LD_VAR 0 5
22684: PUSH
22685: LD_EXP 4
22689: DIFF
22690: PUSH
22691: LD_INT 0
22693: PPUSH
22694: LD_INT 2
22696: PPUSH
22697: CALL_OW 12
22701: AND
22702: IFFALSE 22731
// goal := GetUnitArea ( ( bases diff ar ) [ 1 ] ) else
22704: LD_ADDR_VAR 0 4
22708: PUSH
22709: LD_VAR 0 5
22713: PUSH
22714: LD_EXP 4
22718: DIFF
22719: PUSH
22720: LD_INT 1
22722: ARRAY
22723: PPUSH
22724: CALL 22455 0 1
22728: ST_TO_ADDR
22729: GO 22760
// goal := GetUnitArea ( bases [ Rand ( 1 , bases ) ] ) ;
22731: LD_ADDR_VAR 0 4
22735: PUSH
22736: LD_VAR 0 5
22740: PUSH
22741: LD_INT 1
22743: PPUSH
22744: LD_VAR 0 5
22748: PPUSH
22749: CALL_OW 12
22753: ARRAY
22754: PPUSH
22755: CALL 22455 0 1
22759: ST_TO_ADDR
// end else
22760: GO 22772
// goal := Find_Player_Base ;
22762: LD_ADDR_VAR 0 4
22766: PUSH
22767: CALL 22192 0 0
22771: ST_TO_ADDR
// result := goal ;
22772: LD_ADDR_VAR 0 2
22776: PUSH
22777: LD_VAR 0 4
22781: ST_TO_ADDR
// end ;
22782: LD_VAR 0 2
22786: RET
// function Wrong_Base ; var un , vysledek ; begin
22787: LD_INT 0
22789: PPUSH
22790: PPUSH
22791: PPUSH
// un := FilterUnitsInArea ( top_area , [ [ f_side , you ] , [ f_type , unit_building ] ] ) ;
22792: LD_ADDR_VAR 0 2
22796: PUSH
22797: LD_INT 20
22799: PPUSH
22800: LD_INT 22
22802: PUSH
22803: LD_EXP 1
22807: PUSH
22808: EMPTY
22809: LIST
22810: LIST
22811: PUSH
22812: LD_INT 21
22814: PUSH
22815: LD_INT 3
22817: PUSH
22818: EMPTY
22819: LIST
22820: LIST
22821: PUSH
22822: EMPTY
22823: LIST
22824: LIST
22825: PPUSH
22826: CALL_OW 70
22830: ST_TO_ADDR
// if un then
22831: LD_VAR 0 2
22835: IFFALSE 22847
// vysledek := true else
22837: LD_ADDR_VAR 0 3
22841: PUSH
22842: LD_INT 1
22844: ST_TO_ADDR
22845: GO 22855
// vysledek := false ;
22847: LD_ADDR_VAR 0 3
22851: PUSH
22852: LD_INT 0
22854: ST_TO_ADDR
// result := vysledek ;
22855: LD_ADDR_VAR 0 1
22859: PUSH
22860: LD_VAR 0 3
22864: ST_TO_ADDR
// end ;
22865: LD_VAR 0 1
22869: RET
// function All_Tracked ( list ) ; var un , vysledek ; begin
22870: LD_INT 0
22872: PPUSH
22873: PPUSH
22874: PPUSH
// vysledek := true ;
22875: LD_ADDR_VAR 0 4
22879: PUSH
22880: LD_INT 1
22882: ST_TO_ADDR
// for un in list do
22883: LD_ADDR_VAR 0 3
22887: PUSH
22888: LD_VAR 0 1
22892: PUSH
22893: FOR_IN
22894: IFFALSE 22934
// if GetChassis ( un ) in [ us_light_wheeled , us_medium_wheeled , ru_medium_wheeled ] then
22896: LD_VAR 0 3
22900: PPUSH
22901: CALL_OW 265
22905: PUSH
22906: LD_INT 1
22908: PUSH
22909: LD_INT 2
22911: PUSH
22912: LD_INT 21
22914: PUSH
22915: EMPTY
22916: LIST
22917: LIST
22918: LIST
22919: IN
22920: IFFALSE 22932
// begin vysledek := false ;
22922: LD_ADDR_VAR 0 4
22926: PUSH
22927: LD_INT 0
22929: ST_TO_ADDR
// break ;
22930: GO 22934
// end ;
22932: GO 22893
22934: POP
22935: POP
// result := vysledek ;
22936: LD_ADDR_VAR 0 2
22940: PUSH
22941: LD_VAR 0 4
22945: ST_TO_ADDR
// end ;
22946: LD_VAR 0 2
22950: RET
// function Send_US_Forces ( target , side ) ; begin
22951: LD_INT 0
22953: PPUSH
// if target = ar_base then
22954: LD_VAR 0 1
22958: PUSH
22959: LD_INT 13
22961: EQUAL
22962: IFFALSE 23075
// begin if All_tracked ( attack_forces [ side ] ) then
22964: LD_EXP 68
22968: PUSH
22969: LD_VAR 0 2
22973: ARRAY
22974: PPUSH
22975: CALL 22870 0 1
22979: IFFALSE 23028
// McMove ( 15 , attack_forces [ side ] , us_ar [ 1 ] , [ mc_move_waitwp , mc_move_dontcapture , mc_move_agressive , mc_move_ownstuck ] ) else
22981: LD_INT 15
22983: PPUSH
22984: LD_EXP 68
22988: PUSH
22989: LD_VAR 0 2
22993: ARRAY
22994: PPUSH
22995: LD_LOC 23
22999: PUSH
23000: LD_INT 1
23002: ARRAY
23003: PPUSH
23004: LD_INT 3
23006: PUSH
23007: LD_INT 5
23009: PUSH
23010: LD_INT 6
23012: PUSH
23013: LD_INT 7
23015: PUSH
23016: EMPTY
23017: LIST
23018: LIST
23019: LIST
23020: LIST
23021: PPUSH
23022: CALL_OW 398
23026: GO 23073
// McMove ( 15 , attack_forces [ side ] , us_ar [ 2 ] , [ mc_move_waitwp , mc_move_dontcapture , mc_move_agressive , mc_move_ownstuck ] ) ;
23028: LD_INT 15
23030: PPUSH
23031: LD_EXP 68
23035: PUSH
23036: LD_VAR 0 2
23040: ARRAY
23041: PPUSH
23042: LD_LOC 23
23046: PUSH
23047: LD_INT 2
23049: ARRAY
23050: PPUSH
23051: LD_INT 3
23053: PUSH
23054: LD_INT 5
23056: PUSH
23057: LD_INT 6
23059: PUSH
23060: LD_INT 7
23062: PUSH
23063: EMPTY
23064: LIST
23065: LIST
23066: LIST
23067: LIST
23068: PPUSH
23069: CALL_OW 398
// end else
23073: GO 23116
// McMove ( 15 , attack_forces [ side ] , us_ru , [ mc_move_waitwp , mc_move_dontcapture , mc_move_agressive , mc_move_ownstuck ] ) ;
23075: LD_INT 15
23077: PPUSH
23078: LD_EXP 68
23082: PUSH
23083: LD_VAR 0 2
23087: ARRAY
23088: PPUSH
23089: LD_LOC 22
23093: PPUSH
23094: LD_INT 3
23096: PUSH
23097: LD_INT 5
23099: PUSH
23100: LD_INT 6
23102: PUSH
23103: LD_INT 7
23105: PUSH
23106: EMPTY
23107: LIST
23108: LIST
23109: LIST
23110: LIST
23111: PPUSH
23112: CALL_OW 398
// end ;
23116: LD_VAR 0 3
23120: RET
// function Send_RU_Forces ( target , side ) ; begin
23121: LD_INT 0
23123: PPUSH
// if target = ar_base then
23124: LD_VAR 0 1
23128: PUSH
23129: LD_INT 13
23131: EQUAL
23132: IFFALSE 23245
// begin if All_tracked ( attack_forces [ side ] ) then
23134: LD_EXP 68
23138: PUSH
23139: LD_VAR 0 2
23143: ARRAY
23144: PPUSH
23145: CALL 22870 0 1
23149: IFFALSE 23198
// McMove ( 15 , attack_forces [ side ] , ru_ar [ 1 ] , [ mc_move_waitwp , mc_move_dontcapture , mc_move_agressive , mc_move_ownstuck ] ) else
23151: LD_INT 15
23153: PPUSH
23154: LD_EXP 68
23158: PUSH
23159: LD_VAR 0 2
23163: ARRAY
23164: PPUSH
23165: LD_LOC 25
23169: PUSH
23170: LD_INT 1
23172: ARRAY
23173: PPUSH
23174: LD_INT 3
23176: PUSH
23177: LD_INT 5
23179: PUSH
23180: LD_INT 6
23182: PUSH
23183: LD_INT 7
23185: PUSH
23186: EMPTY
23187: LIST
23188: LIST
23189: LIST
23190: LIST
23191: PPUSH
23192: CALL_OW 398
23196: GO 23243
// McMove ( 15 , attack_forces [ side ] , ru_ar [ 2 ] , [ mc_move_waitwp , mc_move_dontcapture , mc_move_agressive , mc_move_ownstuck ] ) ;
23198: LD_INT 15
23200: PPUSH
23201: LD_EXP 68
23205: PUSH
23206: LD_VAR 0 2
23210: ARRAY
23211: PPUSH
23212: LD_LOC 25
23216: PUSH
23217: LD_INT 2
23219: ARRAY
23220: PPUSH
23221: LD_INT 3
23223: PUSH
23224: LD_INT 5
23226: PUSH
23227: LD_INT 6
23229: PUSH
23230: LD_INT 7
23232: PUSH
23233: EMPTY
23234: LIST
23235: LIST
23236: LIST
23237: LIST
23238: PPUSH
23239: CALL_OW 398
// end else
23243: GO 23286
// McMove ( 15 , attack_forces [ side ] , ru_us , [ mc_move_waitwp , mc_move_dontcapture , mc_move_agressive , mc_move_ownstuck ] ) ;
23245: LD_INT 15
23247: PPUSH
23248: LD_EXP 68
23252: PUSH
23253: LD_VAR 0 2
23257: ARRAY
23258: PPUSH
23259: LD_LOC 24
23263: PPUSH
23264: LD_INT 3
23266: PUSH
23267: LD_INT 5
23269: PUSH
23270: LD_INT 6
23272: PUSH
23273: LD_INT 7
23275: PUSH
23276: EMPTY
23277: LIST
23278: LIST
23279: LIST
23280: LIST
23281: PPUSH
23282: CALL_OW 398
// end ;
23286: LD_VAR 0 3
23290: RET
// function let_the_war_begin ( side ) ; var target ; begin
23291: LD_INT 0
23293: PPUSH
23294: PPUSH
// target := false ;
23295: LD_ADDR_VAR 0 3
23299: PUSH
23300: LD_INT 0
23302: ST_TO_ADDR
// if define_target_priority then
23303: CALL 21891 0 0
23307: IFFALSE 23319
// target := Find_Player_Base ;
23309: LD_ADDR_VAR 0 3
23313: PUSH
23314: CALL 22192 0 0
23318: ST_TO_ADDR
// if not target then
23319: LD_VAR 0 3
23323: NOT
23324: IFFALSE 23341
// target := Find_CPU_Target ( side ) ;
23326: LD_ADDR_VAR 0 3
23330: PUSH
23331: LD_VAR 0 1
23335: PPUSH
23336: CALL 22537 0 1
23340: ST_TO_ADDR
// if not target then
23341: LD_VAR 0 3
23345: NOT
23346: IFFALSE 23350
// exit ;
23348: GO 23573
// attack_forces := Replace ( attack_forces , side , ready_forces [ side ] ) ;
23350: LD_ADDR_EXP 68
23354: PUSH
23355: LD_EXP 68
23359: PPUSH
23360: LD_VAR 0 1
23364: PPUSH
23365: LD_EXP 67
23369: PUSH
23370: LD_VAR 0 1
23374: ARRAY
23375: PPUSH
23376: CALL_OW 1
23380: ST_TO_ADDR
// ready_forces := Replace ( ready_forces , side , [ ] ) ;
23381: LD_ADDR_EXP 67
23385: PUSH
23386: LD_EXP 67
23390: PPUSH
23391: LD_VAR 0 1
23395: PPUSH
23396: EMPTY
23397: PPUSH
23398: CALL_OW 1
23402: ST_TO_ADDR
// jammed_forces := Insert ( jammed_forces , side , jammed_forces [ side ] ^ attack_forces [ side ] ) ;
23403: LD_ADDR_EXP 71
23407: PUSH
23408: LD_EXP 71
23412: PPUSH
23413: LD_VAR 0 1
23417: PPUSH
23418: LD_EXP 71
23422: PUSH
23423: LD_VAR 0 1
23427: ARRAY
23428: PUSH
23429: LD_EXP 68
23433: PUSH
23434: LD_VAR 0 1
23438: ARRAY
23439: ADD
23440: PPUSH
23441: CALL_OW 2
23445: ST_TO_ADDR
// case side of 1 :
23446: LD_VAR 0 1
23450: PUSH
23451: LD_INT 1
23453: DOUBLE
23454: EQUAL
23455: IFTRUE 23459
23457: GO 23465
23459: POP
// enable ( 222 ) ; 3 :
23460: LD_INT 222
23462: ENABLE_MARKED
23463: GO 23480
23465: LD_INT 3
23467: DOUBLE
23468: EQUAL
23469: IFTRUE 23473
23471: GO 23479
23473: POP
// enable ( 223 ) ; end ;
23474: LD_INT 223
23476: ENABLE_MARKED
23477: GO 23480
23479: POP
// if Wrong_Base then
23480: CALL 22787 0 0
23484: IFFALSE 23517
// McMove ( 15 , attack_forces [ side ] , al_eliminate , [ mc_move_dontcapture ] ) else
23486: LD_INT 15
23488: PPUSH
23489: LD_EXP 68
23493: PUSH
23494: LD_VAR 0 1
23498: ARRAY
23499: PPUSH
23500: LD_LOC 29
23504: PPUSH
23505: LD_INT 5
23507: PUSH
23508: EMPTY
23509: LIST
23510: PPUSH
23511: CALL_OW 398
23515: GO 23573
// case side of 1 :
23517: LD_VAR 0 1
23521: PUSH
23522: LD_INT 1
23524: DOUBLE
23525: EQUAL
23526: IFTRUE 23530
23528: GO 23547
23530: POP
// Send_US_Forces ( target , side ) ; 3 :
23531: LD_VAR 0 3
23535: PPUSH
23536: LD_VAR 0 1
23540: PPUSH
23541: CALL 22951 0 2
23545: GO 23573
23547: LD_INT 3
23549: DOUBLE
23550: EQUAL
23551: IFTRUE 23555
23553: GO 23572
23555: POP
// Send_RU_Forces ( target , side ) ; end ;
23556: LD_VAR 0 3
23560: PPUSH
23561: LD_VAR 0 1
23565: PPUSH
23566: CALL 23121 0 2
23570: GO 23573
23572: POP
// end ;
23573: LD_VAR 0 2
23577: RET
// every 88 marked 222 do var list , late , un , i ;
23578: GO 23580
23580: DISABLE
23581: LD_INT 0
23583: PPUSH
23584: PPUSH
23585: PPUSH
23586: PPUSH
// begin wait ( 1 1$20 ) ;
23587: LD_INT 2800
23589: PPUSH
23590: CALL_OW 67
// list := FilterUnitsInArea ( us_tinny , [ [ f_side , us ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) ;
23594: LD_ADDR_VAR 0 1
23598: PUSH
23599: LD_INT 41
23601: PPUSH
23602: LD_INT 22
23604: PUSH
23605: LD_EXP 3
23609: PUSH
23610: EMPTY
23611: LIST
23612: LIST
23613: PUSH
23614: LD_INT 21
23616: PUSH
23617: LD_INT 2
23619: PUSH
23620: EMPTY
23621: LIST
23622: LIST
23623: PUSH
23624: LD_INT 50
23626: PUSH
23627: EMPTY
23628: LIST
23629: PUSH
23630: EMPTY
23631: LIST
23632: LIST
23633: LIST
23634: PPUSH
23635: CALL_OW 70
23639: ST_TO_ADDR
// late := jammed_forces [ us ] isect list ;
23640: LD_ADDR_VAR 0 2
23644: PUSH
23645: LD_EXP 71
23649: PUSH
23650: LD_EXP 3
23654: ARRAY
23655: PUSH
23656: LD_VAR 0 1
23660: ISECT
23661: ST_TO_ADDR
// if not late then
23662: LD_VAR 0 2
23666: NOT
23667: IFFALSE 23693
// begin jammed_forces := Replace ( jammed_forces , us , [ ] ) ;
23669: LD_ADDR_EXP 71
23673: PUSH
23674: LD_EXP 71
23678: PPUSH
23679: LD_EXP 3
23683: PPUSH
23684: EMPTY
23685: PPUSH
23686: CALL_OW 1
23690: ST_TO_ADDR
// exit ;
23691: GO 23971
// end ; if FilterUnitsInArea ( us_base , [ [ f_side , you ] ] ) then
23693: LD_INT 11
23695: PPUSH
23696: LD_INT 22
23698: PUSH
23699: LD_EXP 1
23703: PUSH
23704: EMPTY
23705: LIST
23706: LIST
23707: PUSH
23708: EMPTY
23709: LIST
23710: PPUSH
23711: CALL_OW 70
23715: IFFALSE 23720
// begin enable ;
23717: ENABLE
// exit ;
23718: GO 23971
// end ; for un in late do
23720: LD_ADDR_VAR 0 3
23724: PUSH
23725: LD_VAR 0 2
23729: PUSH
23730: FOR_IN
23731: IFFALSE 23760
// if GetUnitMc ( un ) then
23733: LD_VAR 0 3
23737: PPUSH
23738: CALL_OW 388
23742: IFFALSE 23758
// KillMc ( GetUnitMc ( un ) ) ;
23744: LD_VAR 0 3
23748: PPUSH
23749: CALL_OW 388
23753: PPUSH
23754: CALL_OW 387
23758: GO 23730
23760: POP
23761: POP
// while GetTag ( 83 ) do
23762: LD_INT 83
23764: PPUSH
23765: CALL_OW 110
23769: IFFALSE 23780
// wait ( 0 0$1 ) ;
23771: LD_INT 35
23773: PPUSH
23774: CALL_OW 67
23778: GO 23762
// i := 1 ;
23780: LD_ADDR_VAR 0 4
23784: PUSH
23785: LD_INT 1
23787: ST_TO_ADDR
// for un in jammed_forces [ us ] do
23788: LD_ADDR_VAR 0 3
23792: PUSH
23793: LD_EXP 71
23797: PUSH
23798: LD_EXP 3
23802: ARRAY
23803: PUSH
23804: FOR_IN
23805: IFFALSE 23910
// begin if ( i mod 2 ) and not See ( you , un ) then
23807: LD_VAR 0 4
23811: PUSH
23812: LD_INT 2
23814: MOD
23815: PUSH
23816: LD_EXP 1
23820: PPUSH
23821: LD_VAR 0 3
23825: PPUSH
23826: CALL_OW 292
23830: NOT
23831: AND
23832: IFFALSE 23894
// begin jammed_forces := Replace ( jammed_forces , us , jammed_forces [ us ] diff un ) ;
23834: LD_ADDR_EXP 71
23838: PUSH
23839: LD_EXP 71
23843: PPUSH
23844: LD_EXP 3
23848: PPUSH
23849: LD_EXP 71
23853: PUSH
23854: LD_EXP 3
23858: ARRAY
23859: PUSH
23860: LD_VAR 0 3
23864: DIFF
23865: PPUSH
23866: CALL_OW 1
23870: ST_TO_ADDR
// KillUnit ( un ) ;
23871: LD_VAR 0 3
23875: PPUSH
23876: CALL_OW 66
// pocet_odebrani := pocet_odebrani + 1 ;
23880: LD_ADDR_LOC 30
23884: PUSH
23885: LD_LOC 30
23889: PUSH
23890: LD_INT 1
23892: PLUS
23893: ST_TO_ADDR
// end ; i := i + 1 ;
23894: LD_ADDR_VAR 0 4
23898: PUSH
23899: LD_VAR 0 4
23903: PUSH
23904: LD_INT 1
23906: PLUS
23907: ST_TO_ADDR
// end ;
23908: GO 23804
23910: POP
23911: POP
// wait ( 0 0$10 ) ;
23912: LD_INT 350
23914: PPUSH
23915: CALL_OW 67
// ready_forces := Replace ( ready_forces , us , ready_forces [ us ] union jammed_forces [ us ] ) ;
23919: LD_ADDR_EXP 67
23923: PUSH
23924: LD_EXP 67
23928: PPUSH
23929: LD_EXP 3
23933: PPUSH
23934: LD_EXP 67
23938: PUSH
23939: LD_EXP 3
23943: ARRAY
23944: PUSH
23945: LD_EXP 71
23949: PUSH
23950: LD_EXP 3
23954: ARRAY
23955: UNION
23956: PPUSH
23957: CALL_OW 1
23961: ST_TO_ADDR
// let_the_war_begin ( us ) ;
23962: LD_EXP 3
23966: PPUSH
23967: CALL 23291 0 1
// end ;
23971: PPOPN 4
23973: END
// every 91 marked 223 do var list , late , un , i ;
23974: GO 23976
23976: DISABLE
23977: LD_INT 0
23979: PPUSH
23980: PPUSH
23981: PPUSH
23982: PPUSH
// begin wait ( 1 1$20 ) ;
23983: LD_INT 2800
23985: PPUSH
23986: CALL_OW 67
// list := FilterUnitsInArea ( ru_tinny , [ [ f_side , ru ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) ;
23990: LD_ADDR_VAR 0 1
23994: PUSH
23995: LD_INT 40
23997: PPUSH
23998: LD_INT 22
24000: PUSH
24001: LD_EXP 2
24005: PUSH
24006: EMPTY
24007: LIST
24008: LIST
24009: PUSH
24010: LD_INT 21
24012: PUSH
24013: LD_INT 2
24015: PUSH
24016: EMPTY
24017: LIST
24018: LIST
24019: PUSH
24020: LD_INT 50
24022: PUSH
24023: EMPTY
24024: LIST
24025: PUSH
24026: EMPTY
24027: LIST
24028: LIST
24029: LIST
24030: PPUSH
24031: CALL_OW 70
24035: ST_TO_ADDR
// late := jammed_forces [ ru ] isect list ;
24036: LD_ADDR_VAR 0 2
24040: PUSH
24041: LD_EXP 71
24045: PUSH
24046: LD_EXP 2
24050: ARRAY
24051: PUSH
24052: LD_VAR 0 1
24056: ISECT
24057: ST_TO_ADDR
// if not late then
24058: LD_VAR 0 2
24062: NOT
24063: IFFALSE 24089
// begin jammed_forces := Replace ( jammed_forces , ru , [ ] ) ;
24065: LD_ADDR_EXP 71
24069: PUSH
24070: LD_EXP 71
24074: PPUSH
24075: LD_EXP 2
24079: PPUSH
24080: EMPTY
24081: PPUSH
24082: CALL_OW 1
24086: ST_TO_ADDR
// exit ;
24087: GO 24367
// end ; if FilterUnitsInArea ( ru_base , [ [ f_side , you ] ] ) then
24089: LD_INT 12
24091: PPUSH
24092: LD_INT 22
24094: PUSH
24095: LD_EXP 1
24099: PUSH
24100: EMPTY
24101: LIST
24102: LIST
24103: PUSH
24104: EMPTY
24105: LIST
24106: PPUSH
24107: CALL_OW 70
24111: IFFALSE 24116
// begin enable ;
24113: ENABLE
// exit ;
24114: GO 24367
// end ; for un in late do
24116: LD_ADDR_VAR 0 3
24120: PUSH
24121: LD_VAR 0 2
24125: PUSH
24126: FOR_IN
24127: IFFALSE 24156
// if GetUnitMc ( un ) then
24129: LD_VAR 0 3
24133: PPUSH
24134: CALL_OW 388
24138: IFFALSE 24154
// KillMc ( GetUnitMc ( un ) ) ;
24140: LD_VAR 0 3
24144: PPUSH
24145: CALL_OW 388
24149: PPUSH
24150: CALL_OW 387
24154: GO 24126
24156: POP
24157: POP
// while GetTag ( 83 ) do
24158: LD_INT 83
24160: PPUSH
24161: CALL_OW 110
24165: IFFALSE 24176
// wait ( 0 0$1 ) ;
24167: LD_INT 35
24169: PPUSH
24170: CALL_OW 67
24174: GO 24158
// i := 1 ;
24176: LD_ADDR_VAR 0 4
24180: PUSH
24181: LD_INT 1
24183: ST_TO_ADDR
// for un in jammed_forces [ ru ] do
24184: LD_ADDR_VAR 0 3
24188: PUSH
24189: LD_EXP 71
24193: PUSH
24194: LD_EXP 2
24198: ARRAY
24199: PUSH
24200: FOR_IN
24201: IFFALSE 24306
// begin if ( i mod 2 ) and not See ( you , un ) then
24203: LD_VAR 0 4
24207: PUSH
24208: LD_INT 2
24210: MOD
24211: PUSH
24212: LD_EXP 1
24216: PPUSH
24217: LD_VAR 0 3
24221: PPUSH
24222: CALL_OW 292
24226: NOT
24227: AND
24228: IFFALSE 24290
// begin jammed_forces := Replace ( jammed_forces , ru , jammed_forces [ ru ] diff un ) ;
24230: LD_ADDR_EXP 71
24234: PUSH
24235: LD_EXP 71
24239: PPUSH
24240: LD_EXP 2
24244: PPUSH
24245: LD_EXP 71
24249: PUSH
24250: LD_EXP 2
24254: ARRAY
24255: PUSH
24256: LD_VAR 0 3
24260: DIFF
24261: PPUSH
24262: CALL_OW 1
24266: ST_TO_ADDR
// KillUnit ( un ) ;
24267: LD_VAR 0 3
24271: PPUSH
24272: CALL_OW 66
// pocet_odebrani := pocet_odebrani + 1 ;
24276: LD_ADDR_LOC 30
24280: PUSH
24281: LD_LOC 30
24285: PUSH
24286: LD_INT 1
24288: PLUS
24289: ST_TO_ADDR
// end ; i := i + 1 ;
24290: LD_ADDR_VAR 0 4
24294: PUSH
24295: LD_VAR 0 4
24299: PUSH
24300: LD_INT 1
24302: PLUS
24303: ST_TO_ADDR
// end ;
24304: GO 24200
24306: POP
24307: POP
// wait ( 0 0$10 ) ;
24308: LD_INT 350
24310: PPUSH
24311: CALL_OW 67
// ready_forces := Replace ( ready_forces , ru , ready_forces [ ru ] union jammed_forces [ ru ] ) ;
24315: LD_ADDR_EXP 67
24319: PUSH
24320: LD_EXP 67
24324: PPUSH
24325: LD_EXP 2
24329: PPUSH
24330: LD_EXP 67
24334: PUSH
24335: LD_EXP 2
24339: ARRAY
24340: PUSH
24341: LD_EXP 71
24345: PUSH
24346: LD_EXP 2
24350: ARRAY
24351: UNION
24352: PPUSH
24353: CALL_OW 1
24357: ST_TO_ADDR
// let_the_war_begin ( ru ) ;
24358: LD_EXP 2
24362: PPUSH
24363: CALL 23291 0 1
// end ; end_of_file
24367: PPOPN 4
24369: END
// var tech_list , weap_list , sib_list , comp_list , opto_list , bio_list , space_list ; var utech_basic , utech_weap , utech_sib , utech_comp , utech_bio , utech_space , utech_opto ; var basic_tech , upgrade_tech ; var first_technology , last_technology , recomended_technology ; export scientistic_wanted ; var all_invented ; export function init_research ; begin
24370: LD_INT 0
24372: PPUSH
// all_invented := [ false , false , false , false , false , false , false , false ] ;
24373: LD_ADDR_LOC 50
24377: PUSH
24378: LD_INT 0
24380: PUSH
24381: LD_INT 0
24383: PUSH
24384: LD_INT 0
24386: PUSH
24387: LD_INT 0
24389: PUSH
24390: LD_INT 0
24392: PUSH
24393: LD_INT 0
24395: PUSH
24396: LD_INT 0
24398: PUSH
24399: LD_INT 0
24401: PUSH
24402: EMPTY
24403: LIST
24404: LIST
24405: LIST
24406: LIST
24407: LIST
24408: LIST
24409: LIST
24410: LIST
24411: ST_TO_ADDR
// tech_list := [ tech_SolPow , tech_SolEng , tech_OilPow , tech_OilEng , tech_SibDet , tech_ApeLang , tech_ApePsych , tech_ApeAgres ] ;
24412: LD_ADDR_LOC 31
24416: PUSH
24417: LD_INT 35
24419: PUSH
24420: LD_INT 45
24422: PUSH
24423: LD_INT 46
24425: PUSH
24426: LD_INT 47
24428: PUSH
24429: LD_INT 20
24431: PUSH
24432: LD_INT 1
24434: PUSH
24435: LD_INT 2
24437: PUSH
24438: LD_INT 11
24440: PUSH
24441: EMPTY
24442: LIST
24443: LIST
24444: LIST
24445: LIST
24446: LIST
24447: LIST
24448: LIST
24449: LIST
24450: ST_TO_ADDR
// weap_list := [ tech_Gatling , tech_Gun , tech_Explos , tech_AdvMet , tech_Rocket , tech_AdvRocket , tech_Bazooka , tech_Mortar , tech_AdvChassis , tech_Soporific , tech_Flame , tech_Behemoth , tech_SelfDest ] ;
24451: LD_ADDR_LOC 32
24455: PUSH
24456: LD_INT 69
24458: PUSH
24459: LD_INT 39
24461: PUSH
24462: LD_INT 42
24464: PUSH
24465: LD_INT 34
24467: PUSH
24468: LD_INT 40
24470: PUSH
24471: LD_INT 71
24473: PUSH
24474: LD_INT 44
24476: PUSH
24477: LD_INT 41
24479: PUSH
24480: LD_INT 36
24482: PUSH
24483: LD_INT 13
24485: PUSH
24486: LD_INT 70
24488: PUSH
24489: LD_INT 23
24491: PUSH
24492: LD_INT 43
24494: PUSH
24495: EMPTY
24496: LIST
24497: LIST
24498: LIST
24499: LIST
24500: LIST
24501: LIST
24502: LIST
24503: LIST
24504: LIST
24505: LIST
24506: LIST
24507: LIST
24508: LIST
24509: ST_TO_ADDR
// sib_list := [ tech_SibPow , tech_SibEng , tech_SibFiss ] ;
24510: LD_ADDR_LOC 33
24514: PUSH
24515: LD_INT 21
24517: PUSH
24518: LD_INT 22
24520: PUSH
24521: LD_INT 25
24523: PUSH
24524: EMPTY
24525: LIST
24526: LIST
24527: LIST
24528: ST_TO_ADDR
// comp_list := [ tech_AI , tech_AdvAI , tech_Virus , tech_TargTeleport ] ;
24529: LD_ADDR_LOC 34
24533: PUSH
24534: LD_INT 32
24536: PUSH
24537: LD_INT 27
24539: PUSH
24540: LD_INT 33
24542: PUSH
24543: LD_INT 38
24545: PUSH
24546: EMPTY
24547: LIST
24548: LIST
24549: LIST
24550: LIST
24551: ST_TO_ADDR
// opto_list := [ tech_Radar , tech_LasSight , tech_RemCont , tech_Laser , tech_MatDet , tech_PartInvis , tech_RemCharge ] ;
24552: LD_ADDR_LOC 35
24556: PUSH
24557: LD_INT 6
24559: PUSH
24560: LD_INT 12
24562: PUSH
24563: LD_INT 15
24565: PUSH
24566: LD_INT 10
24568: PUSH
24569: LD_INT 7
24571: PUSH
24572: LD_INT 16
24574: PUSH
24575: LD_INT 18
24577: PUSH
24578: EMPTY
24579: LIST
24580: LIST
24581: LIST
24582: LIST
24583: LIST
24584: LIST
24585: LIST
24586: ST_TO_ADDR
// bio_list := [ tech_ApeNeural , tech_ApeBrain , tech_StimDrugs , tech_BioDet ] ;
24587: LD_ADDR_LOC 36
24591: PUSH
24592: LD_INT 3
24594: PUSH
24595: LD_INT 4
24597: PUSH
24598: LD_INT 5
24600: PUSH
24601: LD_INT 8
24603: PUSH
24604: EMPTY
24605: LIST
24606: LIST
24607: LIST
24608: LIST
24609: ST_TO_ADDR
// space_list := [ tech_TauField , tech_Lapser , tech_LimTeleport , tech_TauRad , tech_SpacAnom ] ;
24610: LD_ADDR_LOC 37
24614: PUSH
24615: LD_INT 30
24617: PUSH
24618: LD_INT 31
24620: PUSH
24621: LD_INT 37
24623: PUSH
24624: LD_INT 28
24626: PUSH
24627: LD_INT 29
24629: PUSH
24630: EMPTY
24631: LIST
24632: LIST
24633: LIST
24634: LIST
24635: LIST
24636: ST_TO_ADDR
// basic_tech := [ tech_list , weap_list , sib_list , comp_list , bio_list , space_list , opto_list ] ;
24637: LD_ADDR_LOC 45
24641: PUSH
24642: LD_LOC 31
24646: PUSH
24647: LD_LOC 32
24651: PUSH
24652: LD_LOC 33
24656: PUSH
24657: LD_LOC 34
24661: PUSH
24662: LD_LOC 36
24666: PUSH
24667: LD_LOC 37
24671: PUSH
24672: LD_LOC 35
24676: PUSH
24677: EMPTY
24678: LIST
24679: LIST
24680: LIST
24681: LIST
24682: LIST
24683: LIST
24684: LIST
24685: ST_TO_ADDR
// utech_basic := [ tech_Tech1 , tech_Tech2 , tech_Tech3 ] ;
24686: LD_ADDR_LOC 38
24690: PUSH
24691: LD_INT 48
24693: PUSH
24694: LD_INT 49
24696: PUSH
24697: LD_INT 50
24699: PUSH
24700: EMPTY
24701: LIST
24702: LIST
24703: LIST
24704: ST_TO_ADDR
// utech_weap := [ tech_Weap1 , tech_Weap2 , tech_Weap3 ] ;
24705: LD_ADDR_LOC 39
24709: PUSH
24710: LD_INT 51
24712: PUSH
24713: LD_INT 52
24715: PUSH
24716: LD_INT 53
24718: PUSH
24719: EMPTY
24720: LIST
24721: LIST
24722: LIST
24723: ST_TO_ADDR
// utech_sib := [ tech_Sib1 , tech_Sib2 , tech_Sib3 ] ;
24724: LD_ADDR_LOC 40
24728: PUSH
24729: LD_INT 54
24731: PUSH
24732: LD_INT 55
24734: PUSH
24735: LD_INT 56
24737: PUSH
24738: EMPTY
24739: LIST
24740: LIST
24741: LIST
24742: ST_TO_ADDR
// utech_comp := [ tech_Comp1 , tech_Comp2 , tech_Comp3 ] ;
24743: LD_ADDR_LOC 41
24747: PUSH
24748: LD_INT 57
24750: PUSH
24751: LD_INT 58
24753: PUSH
24754: LD_INT 59
24756: PUSH
24757: EMPTY
24758: LIST
24759: LIST
24760: LIST
24761: ST_TO_ADDR
// utech_bio := [ tech_Bio1 , tech_Bio2 , tech_Bio3 ] ;
24762: LD_ADDR_LOC 42
24766: PUSH
24767: LD_INT 66
24769: PUSH
24770: LD_INT 67
24772: PUSH
24773: LD_INT 68
24775: PUSH
24776: EMPTY
24777: LIST
24778: LIST
24779: LIST
24780: ST_TO_ADDR
// utech_space := [ tech_ST1 , tech_ST2 , tech_ST3 ] ;
24781: LD_ADDR_LOC 43
24785: PUSH
24786: LD_INT 63
24788: PUSH
24789: LD_INT 64
24791: PUSH
24792: LD_INT 65
24794: PUSH
24795: EMPTY
24796: LIST
24797: LIST
24798: LIST
24799: ST_TO_ADDR
// utech_opto := [ tech_Opto1 , tech_Opto2 , tech_Opto3 ] ;
24800: LD_ADDR_LOC 44
24804: PUSH
24805: LD_INT 60
24807: PUSH
24808: LD_INT 61
24810: PUSH
24811: LD_INT 62
24813: PUSH
24814: EMPTY
24815: LIST
24816: LIST
24817: LIST
24818: ST_TO_ADDR
// end ;
24819: LD_VAR 0 1
24823: RET
// function init_upgrade_by_nations ( side_nation ) ; begin
24824: LD_INT 0
24826: PPUSH
// first_technology := [ tech_SolPow , tech_OilPow , tech_OilEng , tech_SibDet , tech_SibPow , tech_AI , tech_AdvAI ] ;
24827: LD_ADDR_LOC 47
24831: PUSH
24832: LD_INT 35
24834: PUSH
24835: LD_INT 46
24837: PUSH
24838: LD_INT 47
24840: PUSH
24841: LD_INT 20
24843: PUSH
24844: LD_INT 21
24846: PUSH
24847: LD_INT 32
24849: PUSH
24850: LD_INT 27
24852: PUSH
24853: EMPTY
24854: LIST
24855: LIST
24856: LIST
24857: LIST
24858: LIST
24859: LIST
24860: LIST
24861: ST_TO_ADDR
// last_technology := [ tech_ApeBrain , tech_Flame , tech_Soporific , tech_SibFiss ] ;
24862: LD_ADDR_LOC 48
24866: PUSH
24867: LD_INT 4
24869: PUSH
24870: LD_INT 70
24872: PUSH
24873: LD_INT 13
24875: PUSH
24876: LD_INT 25
24878: PUSH
24879: EMPTY
24880: LIST
24881: LIST
24882: LIST
24883: LIST
24884: ST_TO_ADDR
// recomended_technology := [ tech_Gun , tech_Tech1 , tech_Comp1 , tech_Tech2 , tech_Comp2 , tech_Tech3 , tech_Comp3 ] ;
24885: LD_ADDR_LOC 49
24889: PUSH
24890: LD_INT 39
24892: PUSH
24893: LD_INT 48
24895: PUSH
24896: LD_INT 57
24898: PUSH
24899: LD_INT 49
24901: PUSH
24902: LD_INT 58
24904: PUSH
24905: LD_INT 50
24907: PUSH
24908: LD_INT 59
24910: PUSH
24911: EMPTY
24912: LIST
24913: LIST
24914: LIST
24915: LIST
24916: LIST
24917: LIST
24918: LIST
24919: ST_TO_ADDR
// case side_nation of 1 :
24920: LD_VAR 0 1
24924: PUSH
24925: LD_INT 1
24927: DOUBLE
24928: EQUAL
24929: IFTRUE 24933
24931: GO 24973
24933: POP
// upgrade_tech := [ utech_basic , utech_weap , utech_sib , utech_comp , utech_opto ] ; 2 :
24934: LD_ADDR_LOC 46
24938: PUSH
24939: LD_LOC 38
24943: PUSH
24944: LD_LOC 39
24948: PUSH
24949: LD_LOC 40
24953: PUSH
24954: LD_LOC 41
24958: PUSH
24959: LD_LOC 44
24963: PUSH
24964: EMPTY
24965: LIST
24966: LIST
24967: LIST
24968: LIST
24969: LIST
24970: ST_TO_ADDR
24971: GO 25070
24973: LD_INT 2
24975: DOUBLE
24976: EQUAL
24977: IFTRUE 24981
24979: GO 25021
24981: POP
// upgrade_tech := [ utech_basic , utech_weap , utech_sib , utech_bio , utech_opto ] ; 3 :
24982: LD_ADDR_LOC 46
24986: PUSH
24987: LD_LOC 38
24991: PUSH
24992: LD_LOC 39
24996: PUSH
24997: LD_LOC 40
25001: PUSH
25002: LD_LOC 42
25006: PUSH
25007: LD_LOC 44
25011: PUSH
25012: EMPTY
25013: LIST
25014: LIST
25015: LIST
25016: LIST
25017: LIST
25018: ST_TO_ADDR
25019: GO 25070
25021: LD_INT 3
25023: DOUBLE
25024: EQUAL
25025: IFTRUE 25029
25027: GO 25069
25029: POP
// upgrade_tech := [ utech_basic , utech_weap , utech_sib , utech_comp , utech_space ] ; end ;
25030: LD_ADDR_LOC 46
25034: PUSH
25035: LD_LOC 38
25039: PUSH
25040: LD_LOC 39
25044: PUSH
25045: LD_LOC 40
25049: PUSH
25050: LD_LOC 41
25054: PUSH
25055: LD_LOC 43
25059: PUSH
25060: EMPTY
25061: LIST
25062: LIST
25063: LIST
25064: LIST
25065: LIST
25066: ST_TO_ADDR
25067: GO 25070
25069: POP
// end ;
25070: LD_VAR 0 2
25074: RET
// every 0 0$5.5 do var un , active_side , active_nation , lab_list , still_researching ;
25075: GO 25077
25077: DISABLE
25078: LD_INT 0
25080: PPUSH
25081: PPUSH
25082: PPUSH
25083: PPUSH
25084: PPUSH
// begin for active_side in cpu_list do
25085: LD_ADDR_VAR 0 2
25089: PUSH
25090: LD_EXP 8
25094: PUSH
25095: FOR_IN
25096: IFFALSE 25205
// begin still_researching := false ;
25098: LD_ADDR_VAR 0 5
25102: PUSH
25103: LD_INT 0
25105: ST_TO_ADDR
// lab_list := get_labs ( active_side ) ;
25106: LD_ADDR_VAR 0 4
25110: PUSH
25111: LD_VAR 0 2
25115: PPUSH
25116: CALL 25292 0 1
25120: ST_TO_ADDR
// for un in lab_list do
25121: LD_ADDR_VAR 0 1
25125: PUSH
25126: LD_VAR 0 4
25130: PUSH
25131: FOR_IN
25132: IFFALSE 25159
// if BuildingStatus ( un ) = bs_working then
25134: LD_VAR 0 1
25138: PPUSH
25139: CALL_OW 461
25143: PUSH
25144: LD_INT 3
25146: EQUAL
25147: IFFALSE 25157
// still_researching := true ;
25149: LD_ADDR_VAR 0 5
25153: PUSH
25154: LD_INT 1
25156: ST_TO_ADDR
25157: GO 25131
25159: POP
25160: POP
// active_nation := GetCPUNation ( active_side ) ;
25161: LD_ADDR_VAR 0 3
25165: PUSH
25166: LD_VAR 0 2
25170: PPUSH
25171: CALL 26893 0 1
25175: ST_TO_ADDR
// if ( not still_researching ) and active_nation then
25176: LD_VAR 0 5
25180: NOT
25181: PUSH
25182: LD_VAR 0 3
25186: AND
25187: IFFALSE 25203
// start_new_research ( active_side , active_nation ) ;
25189: LD_VAR 0 2
25193: PPUSH
25194: LD_VAR 0 3
25198: PPUSH
25199: CALL 25365 0 2
// end ;
25203: GO 25095
25205: POP
25206: POP
// if ( cpu_list ) and ( not all_cpu_invented ) then
25207: LD_EXP 8
25211: PUSH
25212: CALL 25224 0 0
25216: NOT
25217: AND
25218: IFFALSE 25221
// enable ;
25220: ENABLE
// end ;
25221: PPOPN 5
25223: END
// function all_cpu_invented ; var un , vysledek ; begin
25224: LD_INT 0
25226: PPUSH
25227: PPUSH
25228: PPUSH
// vysledek := true ;
25229: LD_ADDR_VAR 0 3
25233: PUSH
25234: LD_INT 1
25236: ST_TO_ADDR
// for un in cpu_list do
25237: LD_ADDR_VAR 0 2
25241: PUSH
25242: LD_EXP 8
25246: PUSH
25247: FOR_IN
25248: IFFALSE 25275
// if not all_invented [ un ] then
25250: LD_LOC 50
25254: PUSH
25255: LD_VAR 0 2
25259: ARRAY
25260: NOT
25261: IFFALSE 25273
// begin vysledek := false ;
25263: LD_ADDR_VAR 0 3
25267: PUSH
25268: LD_INT 0
25270: ST_TO_ADDR
// break ;
25271: GO 25275
// end ;
25273: GO 25247
25275: POP
25276: POP
// result := vysledek ;
25277: LD_ADDR_VAR 0 1
25281: PUSH
25282: LD_VAR 0 3
25286: ST_TO_ADDR
// end ;
25287: LD_VAR 0 1
25291: RET
// function get_labs ( side ) ; var lab_list ; begin
25292: LD_INT 0
25294: PPUSH
25295: PPUSH
// lab_list := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab ] ] ] ) ;
25296: LD_ADDR_VAR 0 3
25300: PUSH
25301: LD_INT 22
25303: PUSH
25304: LD_VAR 0 1
25308: PUSH
25309: EMPTY
25310: LIST
25311: LIST
25312: PUSH
25313: LD_INT 2
25315: PUSH
25316: LD_INT 30
25318: PUSH
25319: LD_INT 8
25321: PUSH
25322: EMPTY
25323: LIST
25324: LIST
25325: PUSH
25326: LD_INT 30
25328: PUSH
25329: LD_INT 6
25331: PUSH
25332: EMPTY
25333: LIST
25334: LIST
25335: PUSH
25336: EMPTY
25337: LIST
25338: LIST
25339: LIST
25340: PUSH
25341: EMPTY
25342: LIST
25343: LIST
25344: PPUSH
25345: CALL_OW 69
25349: ST_TO_ADDR
// result := lab_list ;
25350: LD_ADDR_VAR 0 2
25354: PUSH
25355: LD_VAR 0 3
25359: ST_TO_ADDR
// end ;
25360: LD_VAR 0 2
25364: RET
// function start_new_research ( side , nation ) ; var lab_list , possible , to_research , lab , scientistic ; begin
25365: LD_INT 0
25367: PPUSH
25368: PPUSH
25369: PPUSH
25370: PPUSH
25371: PPUSH
25372: PPUSH
// scientistic := request_people ( side , class_scientistic , 1 ) ;
25373: LD_ADDR_VAR 0 8
25377: PUSH
25378: LD_VAR 0 1
25382: PPUSH
25383: LD_INT 4
25385: PPUSH
25386: LD_INT 1
25388: PPUSH
25389: CALL 26825 0 3
25393: ST_TO_ADDR
// lab_list := get_labs ( side ) ;
25394: LD_ADDR_VAR 0 4
25398: PUSH
25399: LD_VAR 0 1
25403: PPUSH
25404: CALL 25292 0 1
25408: ST_TO_ADDR
// init_upgrade_by_nations ( nation ) ;
25409: LD_VAR 0 2
25413: PPUSH
25414: CALL 24824 0 1
// possible := get_possible_research ( side ) ;
25418: LD_ADDR_VAR 0 5
25422: PUSH
25423: LD_VAR 0 1
25427: PPUSH
25428: CALL 25512 0 1
25432: ST_TO_ADDR
// to_research := select_next_technology ( side , possible ) ;
25433: LD_ADDR_VAR 0 6
25437: PUSH
25438: LD_VAR 0 1
25442: PPUSH
25443: LD_VAR 0 5
25447: PPUSH
25448: CALL 25963 0 2
25452: ST_TO_ADDR
// lab := research_possible ( side , to_research ) ;
25453: LD_ADDR_VAR 0 7
25457: PUSH
25458: LD_VAR 0 1
25462: PPUSH
25463: LD_VAR 0 6
25467: PPUSH
25468: CALL 26522 0 2
25472: ST_TO_ADDR
// if lab then
25473: LD_VAR 0 7
25477: IFFALSE 25507
// begin transfer_scientistic ( scientistic , lab ) ;
25479: LD_VAR 0 8
25483: PPUSH
25484: LD_VAR 0 7
25488: PPUSH
25489: CALL 26643 0 2
// begin_of_research ( lab , to_research ) ;
25493: LD_VAR 0 7
25497: PPUSH
25498: LD_VAR 0 6
25502: PPUSH
25503: CALL 26751 0 2
// end ; end ;
25507: LD_VAR 0 3
25511: RET
// function get_possible_research ( side ) ; var un , vysledek , lab_list , upgrade ; begin
25512: LD_INT 0
25514: PPUSH
25515: PPUSH
25516: PPUSH
25517: PPUSH
25518: PPUSH
// vysledek := [ ] ;
25519: LD_ADDR_VAR 0 4
25523: PUSH
25524: EMPTY
25525: ST_TO_ADDR
// upgrade := [ ] ;
25526: LD_ADDR_VAR 0 6
25530: PUSH
25531: EMPTY
25532: ST_TO_ADDR
// lab_list := get_labs ( side ) ;
25533: LD_ADDR_VAR 0 5
25537: PUSH
25538: LD_VAR 0 1
25542: PPUSH
25543: CALL 25292 0 1
25547: ST_TO_ADDR
// for un in lab_list do
25548: LD_ADDR_VAR 0 3
25552: PUSH
25553: LD_VAR 0 5
25557: PUSH
25558: FOR_IN
25559: IFFALSE 25601
// upgrade := upgrade ^ GetLabKind ( un , 1 ) ^ GetLabKind ( un , 2 ) ;
25561: LD_ADDR_VAR 0 6
25565: PUSH
25566: LD_VAR 0 6
25570: PUSH
25571: LD_VAR 0 3
25575: PPUSH
25576: LD_INT 1
25578: PPUSH
25579: CALL_OW 268
25583: ADD
25584: PUSH
25585: LD_VAR 0 3
25589: PPUSH
25590: LD_INT 2
25592: PPUSH
25593: CALL_OW 268
25597: ADD
25598: ST_TO_ADDR
25599: GO 25558
25601: POP
25602: POP
// for un in upgrade do
25603: LD_ADDR_VAR 0 3
25607: PUSH
25608: LD_VAR 0 6
25612: PUSH
25613: FOR_IN
25614: IFFALSE 25638
// vysledek := vysledek ^ ( un - 8 ) ;
25616: LD_ADDR_VAR 0 4
25620: PUSH
25621: LD_VAR 0 4
25625: PUSH
25626: LD_VAR 0 3
25630: PUSH
25631: LD_INT 8
25633: MINUS
25634: ADD
25635: ST_TO_ADDR
25636: GO 25613
25638: POP
25639: POP
// result := vysledek ;
25640: LD_ADDR_VAR 0 2
25644: PUSH
25645: LD_VAR 0 4
25649: ST_TO_ADDR
// end ;
25650: LD_VAR 0 2
25654: RET
// function shake_it_baby ( list ) ; var vysledek , pom , i , n ; begin
25655: LD_INT 0
25657: PPUSH
25658: PPUSH
25659: PPUSH
25660: PPUSH
25661: PPUSH
// vysledek := [ ] ;
25662: LD_ADDR_VAR 0 3
25666: PUSH
25667: EMPTY
25668: ST_TO_ADDR
// for i = 1 to list do
25669: LD_ADDR_VAR 0 5
25673: PUSH
25674: DOUBLE
25675: LD_INT 1
25677: DEC
25678: ST_TO_ADDR
25679: LD_VAR 0 1
25683: PUSH
25684: FOR_TO
25685: IFFALSE 25759
// begin n := Rand ( 1 , list ) ;
25687: LD_ADDR_VAR 0 6
25691: PUSH
25692: LD_INT 1
25694: PPUSH
25695: LD_VAR 0 1
25699: PPUSH
25700: CALL_OW 12
25704: ST_TO_ADDR
// pom := list [ n ] ;
25705: LD_ADDR_VAR 0 4
25709: PUSH
25710: LD_VAR 0 1
25714: PUSH
25715: LD_VAR 0 6
25719: ARRAY
25720: ST_TO_ADDR
// list := Delete ( list , n ) ;
25721: LD_ADDR_VAR 0 1
25725: PUSH
25726: LD_VAR 0 1
25730: PPUSH
25731: LD_VAR 0 6
25735: PPUSH
25736: CALL_OW 3
25740: ST_TO_ADDR
// vysledek := vysledek ^ pom ;
25741: LD_ADDR_VAR 0 3
25745: PUSH
25746: LD_VAR 0 3
25750: PUSH
25751: LD_VAR 0 4
25755: ADD
25756: ST_TO_ADDR
// end ;
25757: GO 25684
25759: POP
25760: POP
// result := vysledek ;
25761: LD_ADDR_VAR 0 2
25765: PUSH
25766: LD_VAR 0 3
25770: ST_TO_ADDR
// end ;
25771: LD_VAR 0 2
25775: RET
// function GetBasicTechnology ; var list , un , vysledek ; begin
25776: LD_INT 0
25778: PPUSH
25779: PPUSH
25780: PPUSH
25781: PPUSH
// list := [ ] ;
25782: LD_ADDR_VAR 0 2
25786: PUSH
25787: EMPTY
25788: ST_TO_ADDR
// for un in basic_tech do
25789: LD_ADDR_VAR 0 3
25793: PUSH
25794: LD_LOC 45
25798: PUSH
25799: FOR_IN
25800: IFFALSE 25829
// if un then
25802: LD_VAR 0 3
25806: IFFALSE 25827
// list := list ^ [ un ] ;
25808: LD_ADDR_VAR 0 2
25812: PUSH
25813: LD_VAR 0 2
25817: PUSH
25818: LD_VAR 0 3
25822: PUSH
25823: EMPTY
25824: LIST
25825: ADD
25826: ST_TO_ADDR
25827: GO 25799
25829: POP
25830: POP
// if list > 1 then
25831: LD_VAR 0 2
25835: PUSH
25836: LD_INT 1
25838: GREATER
25839: IFFALSE 25856
// vysledek := shake_it_baby ( list ) ;
25841: LD_ADDR_VAR 0 4
25845: PUSH
25846: LD_VAR 0 2
25850: PPUSH
25851: CALL 25655 0 1
25855: ST_TO_ADDR
// result := vysledek ;
25856: LD_ADDR_VAR 0 1
25860: PUSH
25861: LD_VAR 0 4
25865: ST_TO_ADDR
// end ;
25866: LD_VAR 0 1
25870: RET
// function GetUpgradeTechnology ; var list , un , vysledek ; begin
25871: LD_INT 0
25873: PPUSH
25874: PPUSH
25875: PPUSH
25876: PPUSH
// vysledek := [ ] ;
25877: LD_ADDR_VAR 0 4
25881: PUSH
25882: EMPTY
25883: ST_TO_ADDR
// list := [ ] ;
25884: LD_ADDR_VAR 0 2
25888: PUSH
25889: EMPTY
25890: ST_TO_ADDR
// for un in upgrade_tech do
25891: LD_ADDR_VAR 0 3
25895: PUSH
25896: LD_LOC 46
25900: PUSH
25901: FOR_IN
25902: IFFALSE 25931
// if un then
25904: LD_VAR 0 3
25908: IFFALSE 25929
// list := list ^ [ un ] ;
25910: LD_ADDR_VAR 0 2
25914: PUSH
25915: LD_VAR 0 2
25919: PUSH
25920: LD_VAR 0 3
25924: PUSH
25925: EMPTY
25926: LIST
25927: ADD
25928: ST_TO_ADDR
25929: GO 25901
25931: POP
25932: POP
// vysledek := shake_it_baby ( list ) ;
25933: LD_ADDR_VAR 0 4
25937: PUSH
25938: LD_VAR 0 2
25942: PPUSH
25943: CALL 25655 0 1
25947: ST_TO_ADDR
// result := vysledek ;
25948: LD_ADDR_VAR 0 1
25952: PUSH
25953: LD_VAR 0 4
25957: ST_TO_ADDR
// end ;
25958: LD_VAR 0 1
25962: RET
// function select_next_technology ( side , possible ) ; var un , pom , new , vysledek , select ; begin
25963: LD_INT 0
25965: PPUSH
25966: PPUSH
25967: PPUSH
25968: PPUSH
25969: PPUSH
25970: PPUSH
// new := true ;
25971: LD_ADDR_VAR 0 6
25975: PUSH
25976: LD_INT 1
25978: ST_TO_ADDR
// vysledek := [ ] ;
25979: LD_ADDR_VAR 0 7
25983: PUSH
25984: EMPTY
25985: ST_TO_ADDR
// select := [ ] ;
25986: LD_ADDR_VAR 0 8
25990: PUSH
25991: EMPTY
25992: ST_TO_ADDR
// for un in first_technology do
25993: LD_ADDR_VAR 0 4
25997: PUSH
25998: LD_LOC 47
26002: PUSH
26003: FOR_IN
26004: IFFALSE 26046
// begin pom := research_possible ( side , un ) ;
26006: LD_ADDR_VAR 0 5
26010: PUSH
26011: LD_VAR 0 1
26015: PPUSH
26016: LD_VAR 0 4
26020: PPUSH
26021: CALL 26522 0 2
26025: ST_TO_ADDR
// if pom then
26026: LD_VAR 0 5
26030: IFFALSE 26044
// begin vysledek := un ;
26032: LD_ADDR_VAR 0 7
26036: PUSH
26037: LD_VAR 0 4
26041: ST_TO_ADDR
// break ;
26042: GO 26046
// end ; end ;
26044: GO 26003
26046: POP
26047: POP
// if not first_technology then
26048: LD_LOC 47
26052: NOT
26053: IFFALSE 26063
// new := false ;
26055: LD_ADDR_VAR 0 6
26059: PUSH
26060: LD_INT 0
26062: ST_TO_ADDR
// if not vysledek and ( Rand ( 0 , 10 ) < 3 ) then
26063: LD_VAR 0 7
26067: NOT
26068: PUSH
26069: LD_INT 0
26071: PPUSH
26072: LD_INT 10
26074: PPUSH
26075: CALL_OW 12
26079: PUSH
26080: LD_INT 3
26082: LESS
26083: AND
26084: IFFALSE 26141
// for un in recomended_technology do
26086: LD_ADDR_VAR 0 4
26090: PUSH
26091: LD_LOC 49
26095: PUSH
26096: FOR_IN
26097: IFFALSE 26139
// begin pom := research_possible ( side , un ) ;
26099: LD_ADDR_VAR 0 5
26103: PUSH
26104: LD_VAR 0 1
26108: PPUSH
26109: LD_VAR 0 4
26113: PPUSH
26114: CALL 26522 0 2
26118: ST_TO_ADDR
// if pom then
26119: LD_VAR 0 5
26123: IFFALSE 26137
// begin vysledek := un ;
26125: LD_ADDR_VAR 0 7
26129: PUSH
26130: LD_VAR 0 4
26134: ST_TO_ADDR
// break ;
26135: GO 26139
// end ; end ;
26137: GO 26096
26139: POP
26140: POP
// if not recomended_technology then
26141: LD_LOC 49
26145: NOT
26146: IFFALSE 26156
// new := false ;
26148: LD_ADDR_VAR 0 6
26152: PUSH
26153: LD_INT 0
26155: ST_TO_ADDR
// if not vysledek then
26156: LD_VAR 0 7
26160: NOT
26161: IFFALSE 26248
// begin select := GetBasicTechnology ;
26163: LD_ADDR_VAR 0 8
26167: PUSH
26168: CALL 25776 0 0
26172: ST_TO_ADDR
// for un in select do
26173: LD_ADDR_VAR 0 4
26177: PUSH
26178: LD_VAR 0 8
26182: PUSH
26183: FOR_IN
26184: IFFALSE 26246
// begin pom := [ ] ;
26186: LD_ADDR_VAR 0 5
26190: PUSH
26191: EMPTY
26192: ST_TO_ADDR
// if not un in last_technology then
26193: LD_VAR 0 4
26197: PUSH
26198: LD_LOC 48
26202: IN
26203: NOT
26204: IFFALSE 26226
// pom := research_possible ( side , un ) ;
26206: LD_ADDR_VAR 0 5
26210: PUSH
26211: LD_VAR 0 1
26215: PPUSH
26216: LD_VAR 0 4
26220: PPUSH
26221: CALL 26522 0 2
26225: ST_TO_ADDR
// if pom then
26226: LD_VAR 0 5
26230: IFFALSE 26244
// begin vysledek := un ;
26232: LD_ADDR_VAR 0 7
26236: PUSH
26237: LD_VAR 0 4
26241: ST_TO_ADDR
// break ;
26242: GO 26246
// end ; end ;
26244: GO 26183
26246: POP
26247: POP
// end ; if not select then
26248: LD_VAR 0 8
26252: NOT
26253: IFFALSE 26263
// new := false ;
26255: LD_ADDR_VAR 0 6
26259: PUSH
26260: LD_INT 0
26262: ST_TO_ADDR
// if not vysledek then
26263: LD_VAR 0 7
26267: NOT
26268: IFFALSE 26355
// begin select := GetUpgradeTechnology ;
26270: LD_ADDR_VAR 0 8
26274: PUSH
26275: CALL 25871 0 0
26279: ST_TO_ADDR
// for un in select do
26280: LD_ADDR_VAR 0 4
26284: PUSH
26285: LD_VAR 0 8
26289: PUSH
26290: FOR_IN
26291: IFFALSE 26353
// begin pom := [ ] ;
26293: LD_ADDR_VAR 0 5
26297: PUSH
26298: EMPTY
26299: ST_TO_ADDR
// if not un in last_technology then
26300: LD_VAR 0 4
26304: PUSH
26305: LD_LOC 48
26309: IN
26310: NOT
26311: IFFALSE 26333
// pom := research_possible ( side , un ) ;
26313: LD_ADDR_VAR 0 5
26317: PUSH
26318: LD_VAR 0 1
26322: PPUSH
26323: LD_VAR 0 4
26327: PPUSH
26328: CALL 26522 0 2
26332: ST_TO_ADDR
// if pom then
26333: LD_VAR 0 5
26337: IFFALSE 26351
// begin vysledek := un ;
26339: LD_ADDR_VAR 0 7
26343: PUSH
26344: LD_VAR 0 4
26348: ST_TO_ADDR
// break ;
26349: GO 26353
// end ; end ;
26351: GO 26290
26353: POP
26354: POP
// end ; if not select then
26355: LD_VAR 0 8
26359: NOT
26360: IFFALSE 26370
// new := false ;
26362: LD_ADDR_VAR 0 6
26366: PUSH
26367: LD_INT 0
26369: ST_TO_ADDR
// if not vysledek then
26370: LD_VAR 0 7
26374: NOT
26375: IFFALSE 26432
// for un in last_technology do
26377: LD_ADDR_VAR 0 4
26381: PUSH
26382: LD_LOC 48
26386: PUSH
26387: FOR_IN
26388: IFFALSE 26430
// begin pom := research_possible ( side , un ) ;
26390: LD_ADDR_VAR 0 5
26394: PUSH
26395: LD_VAR 0 1
26399: PPUSH
26400: LD_VAR 0 4
26404: PPUSH
26405: CALL 26522 0 2
26409: ST_TO_ADDR
// if pom then
26410: LD_VAR 0 5
26414: IFFALSE 26428
// begin vysledek := un ;
26416: LD_ADDR_VAR 0 7
26420: PUSH
26421: LD_VAR 0 4
26425: ST_TO_ADDR
// break ;
26426: GO 26430
// end ; end ;
26428: GO 26387
26430: POP
26431: POP
// if not last_technology then
26432: LD_LOC 48
26436: NOT
26437: IFFALSE 26447
// new := false ;
26439: LD_ADDR_VAR 0 6
26443: PUSH
26444: LD_INT 0
26446: ST_TO_ADDR
// if not ( vysledek or new ) then
26447: LD_VAR 0 7
26451: PUSH
26452: LD_VAR 0 6
26456: OR
26457: NOT
26458: IFFALSE 26507
// begin all_invented := Insert ( all_invented , side , true ) ;
26460: LD_ADDR_LOC 50
26464: PUSH
26465: LD_LOC 50
26469: PPUSH
26470: LD_VAR 0 1
26474: PPUSH
26475: LD_INT 1
26477: PPUSH
26478: CALL_OW 2
26482: ST_TO_ADDR
// all_invented := Delete ( all_invented , side + 1 ) ;
26483: LD_ADDR_LOC 50
26487: PUSH
26488: LD_LOC 50
26492: PPUSH
26493: LD_VAR 0 1
26497: PUSH
26498: LD_INT 1
26500: PLUS
26501: PPUSH
26502: CALL_OW 3
26506: ST_TO_ADDR
// end ; result := vysledek ;
26507: LD_ADDR_VAR 0 3
26511: PUSH
26512: LD_VAR 0 7
26516: ST_TO_ADDR
// end ;
26517: LD_VAR 0 3
26521: RET
// function research_possible ( side , tech ) ; var un , vysledek , lab_list ; begin
26522: LD_INT 0
26524: PPUSH
26525: PPUSH
26526: PPUSH
26527: PPUSH
// lab_list := get_labs ( side ) ;
26528: LD_ADDR_VAR 0 6
26532: PUSH
26533: LD_VAR 0 1
26537: PPUSH
26538: CALL 25292 0 1
26542: ST_TO_ADDR
// if GetTech ( tech , side ) in [ state_disabled , state_researched ] then
26543: LD_VAR 0 2
26547: PPUSH
26548: LD_VAR 0 1
26552: PPUSH
26553: CALL_OW 321
26557: PUSH
26558: LD_INT 0
26560: PUSH
26561: LD_INT 2
26563: PUSH
26564: EMPTY
26565: LIST
26566: LIST
26567: IN
26568: IFFALSE 26579
// vysledek := [ ] else
26570: LD_ADDR_VAR 0 5
26574: PUSH
26575: EMPTY
26576: ST_TO_ADDR
26577: GO 26628
// for un in lab_list do
26579: LD_ADDR_VAR 0 4
26583: PUSH
26584: LD_VAR 0 6
26588: PUSH
26589: FOR_IN
26590: IFFALSE 26626
// if CanBeResearched ( un , tech ) then
26592: LD_VAR 0 4
26596: PPUSH
26597: LD_VAR 0 2
26601: PPUSH
26602: CALL_OW 430
26606: IFFALSE 26624
// vysledek := vysledek ^ un ;
26608: LD_ADDR_VAR 0 5
26612: PUSH
26613: LD_VAR 0 5
26617: PUSH
26618: LD_VAR 0 4
26622: ADD
26623: ST_TO_ADDR
26624: GO 26589
26626: POP
26627: POP
// result := vysledek ;
26628: LD_ADDR_VAR 0 3
26632: PUSH
26633: LD_VAR 0 5
26637: ST_TO_ADDR
// end ;
26638: LD_VAR 0 3
26642: RET
// function transfer_scientistic ( scients , to_lab ) ; var un , i ; begin
26643: LD_INT 0
26645: PPUSH
26646: PPUSH
26647: PPUSH
// i = 1 ;
26648: LD_ADDR_VAR 0 5
26652: PUSH
26653: LD_INT 1
26655: ST_TO_ADDR
// to_lab := to_lab diff [ 0 ] ;
26656: LD_ADDR_VAR 0 2
26660: PUSH
26661: LD_VAR 0 2
26665: PUSH
26666: LD_INT 0
26668: PUSH
26669: EMPTY
26670: LIST
26671: DIFF
26672: ST_TO_ADDR
// for un in scients do
26673: LD_ADDR_VAR 0 4
26677: PUSH
26678: LD_VAR 0 1
26682: PUSH
26683: FOR_IN
26684: IFFALSE 26732
// begin ComEnterUnit ( un , to_lab [ ( i mod to_lab ) + 1 ] ) ;
26686: LD_VAR 0 4
26690: PPUSH
26691: LD_VAR 0 2
26695: PUSH
26696: LD_VAR 0 5
26700: PUSH
26701: LD_VAR 0 2
26705: MOD
26706: PUSH
26707: LD_INT 1
26709: PLUS
26710: ARRAY
26711: PPUSH
26712: CALL_OW 120
// i := i + 1 ;
26716: LD_ADDR_VAR 0 5
26720: PUSH
26721: LD_VAR 0 5
26725: PUSH
26726: LD_INT 1
26728: PLUS
26729: ST_TO_ADDR
// end ;
26730: GO 26683
26732: POP
26733: POP
// AddComChangeProfession ( scients , class_scientistic ) ;
26734: LD_VAR 0 1
26738: PPUSH
26739: LD_INT 4
26741: PPUSH
26742: CALL_OW 183
// end ;
26746: LD_VAR 0 3
26750: RET
// function begin_of_research ( lab , to_research ) ; begin
26751: LD_INT 0
26753: PPUSH
// ComResearch ( lab , to_research ) ;
26754: LD_VAR 0 1
26758: PPUSH
26759: LD_VAR 0 2
26763: PPUSH
26764: CALL_OW 124
// end ; end_of_file
26768: LD_VAR 0 3
26772: RET
// export reserved_people ; var vysledek ; export function init_distribution ; var un ; begin
26773: LD_INT 0
26775: PPUSH
26776: PPUSH
// reserved_people := [ ] ;
26777: LD_ADDR_EXP 73
26781: PUSH
26782: EMPTY
26783: ST_TO_ADDR
// for un = 1 to 8 do
26784: LD_ADDR_VAR 0 2
26788: PUSH
26789: DOUBLE
26790: LD_INT 1
26792: DEC
26793: ST_TO_ADDR
26794: LD_INT 8
26796: PUSH
26797: FOR_TO
26798: IFFALSE 26818
// reserved_people := reserved_people ^ [ [ ] ] ;
26800: LD_ADDR_EXP 73
26804: PUSH
26805: LD_EXP 73
26809: PUSH
26810: EMPTY
26811: PUSH
26812: EMPTY
26813: LIST
26814: ADD
26815: ST_TO_ADDR
26816: GO 26797
26818: POP
26819: POP
// end ;
26820: LD_VAR 0 1
26824: RET
// export function request_people ( side , man_class , priority ) ; begin
26825: LD_INT 0
26827: PPUSH
// vysledek := FilterAllUnits ( [ [ f_side , side ] , [ f_class , man_class ] ] ) diff reserved_people [ side ] ;
26828: LD_ADDR_LOC 51
26832: PUSH
26833: LD_INT 22
26835: PUSH
26836: LD_VAR 0 1
26840: PUSH
26841: EMPTY
26842: LIST
26843: LIST
26844: PUSH
26845: LD_INT 25
26847: PUSH
26848: LD_VAR 0 2
26852: PUSH
26853: EMPTY
26854: LIST
26855: LIST
26856: PUSH
26857: EMPTY
26858: LIST
26859: LIST
26860: PPUSH
26861: CALL_OW 69
26865: PUSH
26866: LD_EXP 73
26870: PUSH
26871: LD_VAR 0 1
26875: ARRAY
26876: DIFF
26877: ST_TO_ADDR
// result := vysledek ;
26878: LD_ADDR_VAR 0 4
26882: PUSH
26883: LD_LOC 51
26887: ST_TO_ADDR
// end ;
26888: LD_VAR 0 4
26892: RET
// export function GetCPUNation ( side ) ; var un , vysledek ; begin
26893: LD_INT 0
26895: PPUSH
26896: PPUSH
26897: PPUSH
// un := FilterAllUnits ( [ [ f_side , side ] ] ) ;
26898: LD_ADDR_VAR 0 3
26902: PUSH
26903: LD_INT 22
26905: PUSH
26906: LD_VAR 0 1
26910: PUSH
26911: EMPTY
26912: LIST
26913: LIST
26914: PUSH
26915: EMPTY
26916: LIST
26917: PPUSH
26918: CALL_OW 69
26922: ST_TO_ADDR
// if un then
26923: LD_VAR 0 3
26927: IFFALSE 26950
// vysledek := GetSide ( un [ 1 ] ) else
26929: LD_ADDR_VAR 0 4
26933: PUSH
26934: LD_VAR 0 3
26938: PUSH
26939: LD_INT 1
26941: ARRAY
26942: PPUSH
26943: CALL_OW 255
26947: ST_TO_ADDR
26948: GO 26958
// vysledek := false ;
26950: LD_ADDR_VAR 0 4
26954: PUSH
26955: LD_INT 0
26957: ST_TO_ADDR
// result := vysledek ;
26958: LD_ADDR_VAR 0 2
26962: PUSH
26963: LD_VAR 0 4
26967: ST_TO_ADDR
// end ; end_of_file
26968: LD_VAR 0 2
26972: RET
// var us_weapons , ar_weapons , ru_weapons ; var sib_engine , oil_engine ; var prefered ; var main_extensions ; var hovers_recomended , flat_land ; export mechanics_wanted , extension_wanted ; function init_priority ( side , side_nation ) ; var us_main_control ; begin
26973: LD_INT 0
26975: PPUSH
26976: PPUSH
// us_main_control := b_ext_computer ;
26977: LD_ADDR_VAR 0 4
26981: PUSH
26982: LD_INT 24
26984: ST_TO_ADDR
// prefered_control := control_computer ;
26985: LD_ADDR_EXP 61
26989: PUSH
26990: LD_INT 3
26992: ST_TO_ADDR
// case side_nation of 1 :
26993: LD_VAR 0 2
26997: PUSH
26998: LD_INT 1
27000: DOUBLE
27001: EQUAL
27002: IFTRUE 27006
27004: GO 27038
27006: POP
// main_extensions := [ b_ext_track , b_ext_siberium , b_ext_laser , b_ext_rocket , us_main_control ] ; 2 :
27007: LD_ADDR_LOC 58
27011: PUSH
27012: LD_INT 16
27014: PUSH
27015: LD_INT 21
27017: PUSH
27018: LD_INT 25
27020: PUSH
27021: LD_INT 18
27023: PUSH
27024: LD_VAR 0 4
27028: PUSH
27029: EMPTY
27030: LIST
27031: LIST
27032: LIST
27033: LIST
27034: LIST
27035: ST_TO_ADDR
27036: GO 27115
27038: LD_INT 2
27040: DOUBLE
27041: EQUAL
27042: IFTRUE 27046
27044: GO 27076
27046: POP
// main_extensions := [ b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radar , b_ext_siberium ] ; 3 :
27047: LD_ADDR_LOC 58
27051: PUSH
27052: LD_INT 16
27054: PUSH
27055: LD_INT 17
27057: PUSH
27058: LD_INT 18
27060: PUSH
27061: LD_INT 20
27063: PUSH
27064: LD_INT 21
27066: PUSH
27067: EMPTY
27068: LIST
27069: LIST
27070: LIST
27071: LIST
27072: LIST
27073: ST_TO_ADDR
27074: GO 27115
27076: LD_INT 3
27078: DOUBLE
27079: EQUAL
27080: IFTRUE 27084
27082: GO 27114
27084: POP
// main_extensions := [ b_ext_track , b_ext_gun , b_ext_rocket , b_ext_computer , b_ext_siberium ] ; end ;
27085: LD_ADDR_LOC 58
27089: PUSH
27090: LD_INT 16
27092: PUSH
27093: LD_INT 17
27095: PUSH
27096: LD_INT 18
27098: PUSH
27099: LD_INT 24
27101: PUSH
27102: LD_INT 21
27104: PUSH
27105: EMPTY
27106: LIST
27107: LIST
27108: LIST
27109: LIST
27110: LIST
27111: ST_TO_ADDR
27112: GO 27115
27114: POP
// end ;
27115: LD_VAR 0 3
27119: RET
// export function init_manufacture ; begin
27120: LD_INT 0
27122: PPUSH
// hovers_recomended := false ;
27123: LD_ADDR_LOC 59
27127: PUSH
27128: LD_INT 0
27130: ST_TO_ADDR
// flat_land := false ;
27131: LD_ADDR_LOC 60
27135: PUSH
27136: LD_INT 0
27138: ST_TO_ADDR
// sib_engine := 10 ;
27139: LD_ADDR_LOC 55
27143: PUSH
27144: LD_INT 10
27146: ST_TO_ADDR
// oil_engine := 30 ;
27147: LD_ADDR_LOC 56
27151: PUSH
27152: LD_INT 30
27154: ST_TO_ADDR
// us_weapons := [ [ [ us_machine_gun , [ ] , 0 ] , [ us_light_gun , [ tech_Gun ] , b_ext_gun ] , [ us_radar , [ tech_Radar ] , b_ext_radar ] , [ us_crane , [ ] , b_ext_noncombat ] ] , [ [ us_gatling_gun , [ tech_Gatling ] , 0 ] , [ us_double_gun , [ tech_Gun ] , b_ext_gun ] , [ us_rocket_launcher , [ tech_Rocket ] , b_ext_rocket ] , [ us_laser , [ tech_Laser ] , b_ext_laser ] , [ us_cargo_bay , [ ] , b_ext_noncombat ] ] , [ [ us_bulldozer , [ ] , b_ext_noncombat ] , [ us_siberium_rocket , [ tech_SibEng , tech_Rocket ] , b_ext_siberium ] , [ us_heavy_gun , [ tech_AdvMet ] , b_ext_gun ] ] ] ;
27155: LD_ADDR_LOC 52
27159: PUSH
27160: LD_INT 2
27162: PUSH
27163: EMPTY
27164: PUSH
27165: LD_INT 0
27167: PUSH
27168: EMPTY
27169: LIST
27170: LIST
27171: LIST
27172: PUSH
27173: LD_INT 3
27175: PUSH
27176: LD_INT 39
27178: PUSH
27179: EMPTY
27180: LIST
27181: PUSH
27182: LD_INT 17
27184: PUSH
27185: EMPTY
27186: LIST
27187: LIST
27188: LIST
27189: PUSH
27190: LD_INT 11
27192: PUSH
27193: LD_INT 6
27195: PUSH
27196: EMPTY
27197: LIST
27198: PUSH
27199: LD_INT 20
27201: PUSH
27202: EMPTY
27203: LIST
27204: LIST
27205: LIST
27206: PUSH
27207: LD_INT 13
27209: PUSH
27210: EMPTY
27211: PUSH
27212: LD_INT 19
27214: PUSH
27215: EMPTY
27216: LIST
27217: LIST
27218: LIST
27219: PUSH
27220: EMPTY
27221: LIST
27222: LIST
27223: LIST
27224: LIST
27225: PUSH
27226: LD_INT 4
27228: PUSH
27229: LD_INT 69
27231: PUSH
27232: EMPTY
27233: LIST
27234: PUSH
27235: LD_INT 0
27237: PUSH
27238: EMPTY
27239: LIST
27240: LIST
27241: LIST
27242: PUSH
27243: LD_INT 5
27245: PUSH
27246: LD_INT 39
27248: PUSH
27249: EMPTY
27250: LIST
27251: PUSH
27252: LD_INT 17
27254: PUSH
27255: EMPTY
27256: LIST
27257: LIST
27258: LIST
27259: PUSH
27260: LD_INT 7
27262: PUSH
27263: LD_INT 40
27265: PUSH
27266: EMPTY
27267: LIST
27268: PUSH
27269: LD_INT 18
27271: PUSH
27272: EMPTY
27273: LIST
27274: LIST
27275: LIST
27276: PUSH
27277: LD_INT 9
27279: PUSH
27280: LD_INT 10
27282: PUSH
27283: EMPTY
27284: LIST
27285: PUSH
27286: LD_INT 25
27288: PUSH
27289: EMPTY
27290: LIST
27291: LIST
27292: LIST
27293: PUSH
27294: LD_INT 12
27296: PUSH
27297: EMPTY
27298: PUSH
27299: LD_INT 19
27301: PUSH
27302: EMPTY
27303: LIST
27304: LIST
27305: LIST
27306: PUSH
27307: EMPTY
27308: LIST
27309: LIST
27310: LIST
27311: LIST
27312: LIST
27313: PUSH
27314: LD_INT 14
27316: PUSH
27317: EMPTY
27318: PUSH
27319: LD_INT 19
27321: PUSH
27322: EMPTY
27323: LIST
27324: LIST
27325: LIST
27326: PUSH
27327: LD_INT 8
27329: PUSH
27330: LD_INT 22
27332: PUSH
27333: LD_INT 40
27335: PUSH
27336: EMPTY
27337: LIST
27338: LIST
27339: PUSH
27340: LD_INT 21
27342: PUSH
27343: EMPTY
27344: LIST
27345: LIST
27346: LIST
27347: PUSH
27348: LD_INT 6
27350: PUSH
27351: LD_INT 34
27353: PUSH
27354: EMPTY
27355: LIST
27356: PUSH
27357: LD_INT 17
27359: PUSH
27360: EMPTY
27361: LIST
27362: LIST
27363: LIST
27364: PUSH
27365: EMPTY
27366: LIST
27367: LIST
27368: LIST
27369: PUSH
27370: EMPTY
27371: LIST
27372: LIST
27373: LIST
27374: ST_TO_ADDR
// ar_weapons := [ [ [ ar_multimissile_ballista , [ ] , 0 ] , [ ar_double_machine_gun , [ ] , 0 ] , [ ar_light_gun , [ tech_Gun ] , b_ext_gun ] ] , [ [ ar_gatling_gun , [ tech_Gatling ] , 0 ] , [ ar_flame_thrower , [ tech_Flame ] , b_ext_stitch ] , [ ar_gun , [ tech_Gun ] , b_ext_gun ] , [ ar_rocket_launcher , [ tech_Rocket ] , b_ext_rocket ] , [ ar_selfpropelled_bomb , [ tech_Explos ] , b_ext_siberium ] , [ ar_radar , [ tech_Radar ] , b_ext_radar ] , [ ar_control_tower , [ tech_RemCont ] , b_ext_radar ] , [ ar_cargo_bay , [ ] , b_ext_stitch ] ] , [ ] ] ;
27375: LD_ADDR_LOC 53
27379: PUSH
27380: LD_INT 22
27382: PUSH
27383: EMPTY
27384: PUSH
27385: LD_INT 0
27387: PUSH
27388: EMPTY
27389: LIST
27390: LIST
27391: LIST
27392: PUSH
27393: LD_INT 24
27395: PUSH
27396: EMPTY
27397: PUSH
27398: LD_INT 0
27400: PUSH
27401: EMPTY
27402: LIST
27403: LIST
27404: LIST
27405: PUSH
27406: LD_INT 23
27408: PUSH
27409: LD_INT 39
27411: PUSH
27412: EMPTY
27413: LIST
27414: PUSH
27415: LD_INT 17
27417: PUSH
27418: EMPTY
27419: LIST
27420: LIST
27421: LIST
27422: PUSH
27423: EMPTY
27424: LIST
27425: LIST
27426: LIST
27427: PUSH
27428: LD_INT 25
27430: PUSH
27431: LD_INT 69
27433: PUSH
27434: EMPTY
27435: LIST
27436: PUSH
27437: LD_INT 0
27439: PUSH
27440: EMPTY
27441: LIST
27442: LIST
27443: LIST
27444: PUSH
27445: LD_INT 26
27447: PUSH
27448: LD_INT 70
27450: PUSH
27451: EMPTY
27452: LIST
27453: PUSH
27454: LD_INT 23
27456: PUSH
27457: EMPTY
27458: LIST
27459: LIST
27460: LIST
27461: PUSH
27462: LD_INT 27
27464: PUSH
27465: LD_INT 39
27467: PUSH
27468: EMPTY
27469: LIST
27470: PUSH
27471: LD_INT 17
27473: PUSH
27474: EMPTY
27475: LIST
27476: LIST
27477: LIST
27478: PUSH
27479: LD_INT 28
27481: PUSH
27482: LD_INT 40
27484: PUSH
27485: EMPTY
27486: LIST
27487: PUSH
27488: LD_INT 18
27490: PUSH
27491: EMPTY
27492: LIST
27493: LIST
27494: LIST
27495: PUSH
27496: LD_INT 29
27498: PUSH
27499: LD_INT 42
27501: PUSH
27502: EMPTY
27503: LIST
27504: PUSH
27505: LD_INT 21
27507: PUSH
27508: EMPTY
27509: LIST
27510: LIST
27511: LIST
27512: PUSH
27513: LD_INT 30
27515: PUSH
27516: LD_INT 6
27518: PUSH
27519: EMPTY
27520: LIST
27521: PUSH
27522: LD_INT 20
27524: PUSH
27525: EMPTY
27526: LIST
27527: LIST
27528: LIST
27529: PUSH
27530: LD_INT 31
27532: PUSH
27533: LD_INT 15
27535: PUSH
27536: EMPTY
27537: LIST
27538: PUSH
27539: LD_INT 20
27541: PUSH
27542: EMPTY
27543: LIST
27544: LIST
27545: LIST
27546: PUSH
27547: LD_INT 32
27549: PUSH
27550: EMPTY
27551: PUSH
27552: LD_INT 23
27554: PUSH
27555: EMPTY
27556: LIST
27557: LIST
27558: LIST
27559: PUSH
27560: EMPTY
27561: LIST
27562: LIST
27563: LIST
27564: LIST
27565: LIST
27566: LIST
27567: LIST
27568: LIST
27569: PUSH
27570: EMPTY
27571: PUSH
27572: EMPTY
27573: LIST
27574: LIST
27575: LIST
27576: ST_TO_ADDR
// ru_weapons := [ [ ] , [ [ ru_heavy_machine_gun , [ ] , 0 ] , [ ru_gatling_gun , [ tech_Gatling ] , 0 ] , [ ru_gun , [ tech_Gun ] , b_ext_gun ] , [ ru_rocket_launcher , [ tech_Rocket ] , b_ext_rocket ] , [ ru_cargo_bay , [ ] , b_ext_noncombat ] ] , [ [ ru_heavy_gun , [ tech_AdvMet ] , b_ext_gun ] , [ ru_rocket , [ tech_AdvRocket ] , b_ext_rocket ] , [ ru_siberium_rocket , [ tech_SibEng , tech_SibFiss ] , b_ext_siberium ] , [ ru_time_lapser , [ tech_Lapser ] , b_ext_siberium ] , [ ru_bulldozer , [ ] , b_ext_noncombat ] ] ] ;
27577: LD_ADDR_LOC 54
27581: PUSH
27582: EMPTY
27583: PUSH
27584: LD_INT 42
27586: PUSH
27587: EMPTY
27588: PUSH
27589: LD_INT 0
27591: PUSH
27592: EMPTY
27593: LIST
27594: LIST
27595: LIST
27596: PUSH
27597: LD_INT 43
27599: PUSH
27600: LD_INT 69
27602: PUSH
27603: EMPTY
27604: LIST
27605: PUSH
27606: LD_INT 0
27608: PUSH
27609: EMPTY
27610: LIST
27611: LIST
27612: LIST
27613: PUSH
27614: LD_INT 44
27616: PUSH
27617: LD_INT 39
27619: PUSH
27620: EMPTY
27621: LIST
27622: PUSH
27623: LD_INT 17
27625: PUSH
27626: EMPTY
27627: LIST
27628: LIST
27629: LIST
27630: PUSH
27631: LD_INT 45
27633: PUSH
27634: LD_INT 40
27636: PUSH
27637: EMPTY
27638: LIST
27639: PUSH
27640: LD_INT 18
27642: PUSH
27643: EMPTY
27644: LIST
27645: LIST
27646: LIST
27647: PUSH
27648: LD_INT 51
27650: PUSH
27651: EMPTY
27652: PUSH
27653: LD_INT 19
27655: PUSH
27656: EMPTY
27657: LIST
27658: LIST
27659: LIST
27660: PUSH
27661: EMPTY
27662: LIST
27663: LIST
27664: LIST
27665: LIST
27666: LIST
27667: PUSH
27668: LD_INT 46
27670: PUSH
27671: LD_INT 34
27673: PUSH
27674: EMPTY
27675: LIST
27676: PUSH
27677: LD_INT 17
27679: PUSH
27680: EMPTY
27681: LIST
27682: LIST
27683: LIST
27684: PUSH
27685: LD_INT 47
27687: PUSH
27688: LD_INT 71
27690: PUSH
27691: EMPTY
27692: LIST
27693: PUSH
27694: LD_INT 18
27696: PUSH
27697: EMPTY
27698: LIST
27699: LIST
27700: LIST
27701: PUSH
27702: LD_INT 48
27704: PUSH
27705: LD_INT 22
27707: PUSH
27708: LD_INT 25
27710: PUSH
27711: EMPTY
27712: LIST
27713: LIST
27714: PUSH
27715: LD_INT 21
27717: PUSH
27718: EMPTY
27719: LIST
27720: LIST
27721: LIST
27722: PUSH
27723: LD_INT 49
27725: PUSH
27726: LD_INT 31
27728: PUSH
27729: EMPTY
27730: LIST
27731: PUSH
27732: LD_INT 21
27734: PUSH
27735: EMPTY
27736: LIST
27737: LIST
27738: LIST
27739: PUSH
27740: LD_INT 53
27742: PUSH
27743: EMPTY
27744: PUSH
27745: LD_INT 19
27747: PUSH
27748: EMPTY
27749: LIST
27750: LIST
27751: LIST
27752: PUSH
27753: EMPTY
27754: LIST
27755: LIST
27756: LIST
27757: LIST
27758: LIST
27759: PUSH
27760: EMPTY
27761: LIST
27762: LIST
27763: LIST
27764: ST_TO_ADDR
// end ;
27765: LD_VAR 0 1
27769: RET
// function init_prefered_vehicles ( side_nation ) ; begin
27770: LD_INT 0
27772: PPUSH
// case side_nation of 1 :
27773: LD_VAR 0 1
27777: PUSH
27778: LD_INT 1
27780: DOUBLE
27781: EQUAL
27782: IFTRUE 27786
27784: GO 27870
27786: POP
// prefered := [ [ [ us_medium_wheeled , us_medium_wheeled , us_morphling ] [ difficulty ] , 0 , control_remote , us_laser ] , [ us_morphling , 0 , control_remote , us_heavy_gun ] , [ us_morphling , 0 , control_remote , us_rocket_launcher ] ] ; 2 :
27787: LD_ADDR_LOC 57
27791: PUSH
27792: LD_INT 2
27794: PUSH
27795: LD_INT 2
27797: PUSH
27798: LD_INT 5
27800: PUSH
27801: EMPTY
27802: LIST
27803: LIST
27804: LIST
27805: PUSH
27806: LD_OWVAR 67
27810: ARRAY
27811: PUSH
27812: LD_INT 0
27814: PUSH
27815: LD_INT 2
27817: PUSH
27818: LD_INT 9
27820: PUSH
27821: EMPTY
27822: LIST
27823: LIST
27824: LIST
27825: LIST
27826: PUSH
27827: LD_INT 5
27829: PUSH
27830: LD_INT 0
27832: PUSH
27833: LD_INT 2
27835: PUSH
27836: LD_INT 6
27838: PUSH
27839: EMPTY
27840: LIST
27841: LIST
27842: LIST
27843: LIST
27844: PUSH
27845: LD_INT 5
27847: PUSH
27848: LD_INT 0
27850: PUSH
27851: LD_INT 2
27853: PUSH
27854: LD_INT 7
27856: PUSH
27857: EMPTY
27858: LIST
27859: LIST
27860: LIST
27861: LIST
27862: PUSH
27863: EMPTY
27864: LIST
27865: LIST
27866: LIST
27867: ST_TO_ADDR
27868: GO 27983
27870: LD_INT 2
27872: DOUBLE
27873: EQUAL
27874: IFTRUE 27878
27876: GO 27926
27878: POP
// prefered := [ [ ar_medium_trike , 0 , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , 0 , control_remote , ar_gun ] ] ; 3 :
27879: LD_ADDR_LOC 57
27883: PUSH
27884: LD_INT 13
27886: PUSH
27887: LD_INT 0
27889: PUSH
27890: LD_INT 2
27892: PUSH
27893: LD_INT 28
27895: PUSH
27896: EMPTY
27897: LIST
27898: LIST
27899: LIST
27900: LIST
27901: PUSH
27902: LD_INT 13
27904: PUSH
27905: LD_INT 0
27907: PUSH
27908: LD_INT 2
27910: PUSH
27911: LD_INT 27
27913: PUSH
27914: EMPTY
27915: LIST
27916: LIST
27917: LIST
27918: LIST
27919: PUSH
27920: EMPTY
27921: LIST
27922: LIST
27923: ST_TO_ADDR
27924: GO 27983
27926: LD_INT 3
27928: DOUBLE
27929: EQUAL
27930: IFTRUE 27934
27932: GO 27982
27934: POP
// prefered := [ [ 0 , engine_siberite , control_computer , ru_heavy_gun ] , [ 0 , engine_siberite , control_computer , ru_rocket ] ] ; end ;
27935: LD_ADDR_LOC 57
27939: PUSH
27940: LD_INT 0
27942: PUSH
27943: LD_INT 3
27945: PUSH
27946: LD_INT 3
27948: PUSH
27949: LD_INT 46
27951: PUSH
27952: EMPTY
27953: LIST
27954: LIST
27955: LIST
27956: LIST
27957: PUSH
27958: LD_INT 0
27960: PUSH
27961: LD_INT 3
27963: PUSH
27964: LD_INT 3
27966: PUSH
27967: LD_INT 47
27969: PUSH
27970: EMPTY
27971: LIST
27972: LIST
27973: LIST
27974: LIST
27975: PUSH
27976: EMPTY
27977: LIST
27978: LIST
27979: ST_TO_ADDR
27980: GO 27983
27982: POP
// end ;
27983: LD_VAR 0 2
27987: RET
// every 0 0$1.9 do var un , factories , active_side , active_nation , wait_timers , construction_order_given ;
27988: GO 27990
27990: DISABLE
27991: LD_INT 0
27993: PPUSH
27994: PPUSH
27995: PPUSH
27996: PPUSH
27997: PPUSH
27998: PPUSH
// begin wait_timers = [ ] ;
27999: LD_ADDR_VAR 0 5
28003: PUSH
28004: EMPTY
28005: ST_TO_ADDR
// for un = 1 to 8 do
28006: LD_ADDR_VAR 0 1
28010: PUSH
28011: DOUBLE
28012: LD_INT 1
28014: DEC
28015: ST_TO_ADDR
28016: LD_INT 8
28018: PUSH
28019: FOR_TO
28020: IFFALSE 28038
// wait_timers = wait_timers ^ 0 0$15.9 ;
28022: LD_ADDR_VAR 0 5
28026: PUSH
28027: LD_VAR 0 5
28031: PUSH
28032: LD_INT 557
28034: ADD
28035: ST_TO_ADDR
28036: GO 28019
28038: POP
28039: POP
// repeat wait ( 0 0$1 ) ;
28040: LD_INT 35
28042: PPUSH
28043: CALL_OW 67
// for active_side in cpu_list do
28047: LD_ADDR_VAR 0 3
28051: PUSH
28052: LD_EXP 8
28056: PUSH
28057: FOR_IN
28058: IFFALSE 28411
// begin if wait_timers [ active_side ] > 0 0$0 then
28060: LD_VAR 0 5
28064: PUSH
28065: LD_VAR 0 3
28069: ARRAY
28070: PUSH
28071: LD_INT 0
28073: GREATER
28074: IFFALSE 28113
// begin wait_timers = Replace ( wait_timers , active_side , wait_timers [ active_side ] - 0 0$1 ) ;
28076: LD_ADDR_VAR 0 5
28080: PUSH
28081: LD_VAR 0 5
28085: PPUSH
28086: LD_VAR 0 3
28090: PPUSH
28091: LD_VAR 0 5
28095: PUSH
28096: LD_VAR 0 3
28100: ARRAY
28101: PUSH
28102: LD_INT 35
28104: MINUS
28105: PPUSH
28106: CALL_OW 1
28110: ST_TO_ADDR
// continue ;
28111: GO 28057
// end ; if ( Get_Resources ( active_side ) [ 2 ] > 29 ) or ( Get_resources ( active_side ) [ 3 ] > 9 ) then
28113: LD_VAR 0 3
28117: PPUSH
28118: CALL 28420 0 1
28122: PUSH
28123: LD_INT 2
28125: ARRAY
28126: PUSH
28127: LD_INT 29
28129: GREATER
28130: PUSH
28131: LD_VAR 0 3
28135: PPUSH
28136: CALL 28420 0 1
28140: PUSH
28141: LD_INT 3
28143: ARRAY
28144: PUSH
28145: LD_INT 9
28147: GREATER
28148: OR
28149: IFFALSE 28409
// begin case active_side of us :
28151: LD_VAR 0 3
28155: PUSH
28156: LD_EXP 3
28160: DOUBLE
28161: EQUAL
28162: IFTRUE 28166
28164: GO 28177
28166: POP
// if us_sib_wait then
28167: LD_EXP 76
28171: IFFALSE 28175
// continue ; ru :
28173: GO 28057
28175: GO 28199
28177: LD_EXP 2
28181: DOUBLE
28182: EQUAL
28183: IFTRUE 28187
28185: GO 28198
28187: POP
// if ru_sib_wait then
28188: LD_EXP 77
28192: IFFALSE 28196
// continue ; end ;
28194: GO 28057
28196: GO 28199
28198: POP
// factories := FilterAllUnits ( [ [ f_side , active_side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ;
28199: LD_ADDR_VAR 0 2
28203: PUSH
28204: LD_INT 22
28206: PUSH
28207: LD_VAR 0 3
28211: PUSH
28212: EMPTY
28213: LIST
28214: LIST
28215: PUSH
28216: LD_INT 2
28218: PUSH
28219: LD_INT 30
28221: PUSH
28222: LD_INT 2
28224: PUSH
28225: EMPTY
28226: LIST
28227: LIST
28228: PUSH
28229: LD_INT 30
28231: PUSH
28232: LD_INT 3
28234: PUSH
28235: EMPTY
28236: LIST
28237: LIST
28238: PUSH
28239: EMPTY
28240: LIST
28241: LIST
28242: LIST
28243: PUSH
28244: EMPTY
28245: LIST
28246: LIST
28247: PPUSH
28248: CALL_OW 69
28252: ST_TO_ADDR
// if factories = 0 then
28253: LD_VAR 0 2
28257: PUSH
28258: LD_INT 0
28260: EQUAL
28261: IFFALSE 28265
// continue ;
28263: GO 28057
// un = factories [ 1 ] ;
28265: LD_ADDR_VAR 0 1
28269: PUSH
28270: LD_VAR 0 2
28274: PUSH
28275: LD_INT 1
28277: ARRAY
28278: ST_TO_ADDR
// active_nation := GetCPUNation ( active_side ) ;
28279: LD_ADDR_VAR 0 4
28283: PUSH
28284: LD_VAR 0 3
28288: PPUSH
28289: CALL 26893 0 1
28293: ST_TO_ADDR
// init_priority ( active_side , active_nation ) ;
28294: LD_VAR 0 3
28298: PPUSH
28299: LD_VAR 0 4
28303: PPUSH
28304: CALL 26973 0 2
// init_prefered_vehicles ( active_nation ) ;
28308: LD_VAR 0 4
28312: PPUSH
28313: CALL 27770 0 1
// if not BuildingStatus ( un ) = bs_working then
28317: LD_VAR 0 1
28321: PPUSH
28322: CALL_OW 461
28326: PUSH
28327: LD_INT 3
28329: EQUAL
28330: NOT
28331: IFFALSE 28409
// begin construction_order_given = build_new_vehicle ( active_side , active_nation , un ) ;
28333: LD_ADDR_VAR 0 6
28337: PUSH
28338: LD_VAR 0 3
28342: PPUSH
28343: LD_VAR 0 4
28347: PPUSH
28348: LD_VAR 0 1
28352: PPUSH
28353: CALL 28538 0 3
28357: ST_TO_ADDR
// if construction_order_given then
28358: LD_VAR 0 6
28362: IFFALSE 28409
// begin wait ( 10 ) ;
28364: LD_INT 10
28366: PPUSH
28367: CALL_OW 67
// if BuildingStatus ( un ) = bs_working then
28371: LD_VAR 0 1
28375: PPUSH
28376: CALL_OW 461
28380: PUSH
28381: LD_INT 3
28383: EQUAL
28384: IFFALSE 28409
// wait_timers = Replace ( wait_timers , active_side , 0 0$15.9 ) ;
28386: LD_ADDR_VAR 0 5
28390: PUSH
28391: LD_VAR 0 5
28395: PPUSH
28396: LD_VAR 0 3
28400: PPUSH
28401: LD_INT 557
28403: PPUSH
28404: CALL_OW 1
28408: ST_TO_ADDR
// end ; end ; end ; end ;
28409: GO 28057
28411: POP
28412: POP
// until false ;
28413: LD_INT 0
28415: IFFALSE 28040
// end ;
28417: PPOPN 6
28419: END
// function Get_Resources ( side ) ; var depots ; begin
28420: LD_INT 0
28422: PPUSH
28423: PPUSH
// depots = FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
28424: LD_ADDR_VAR 0 3
28428: PUSH
28429: LD_INT 22
28431: PUSH
28432: LD_VAR 0 1
28436: PUSH
28437: EMPTY
28438: LIST
28439: LIST
28440: PUSH
28441: LD_INT 2
28443: PUSH
28444: LD_INT 30
28446: PUSH
28447: LD_INT 0
28449: PUSH
28450: EMPTY
28451: LIST
28452: LIST
28453: PUSH
28454: LD_INT 30
28456: PUSH
28457: LD_INT 1
28459: PUSH
28460: EMPTY
28461: LIST
28462: LIST
28463: PUSH
28464: EMPTY
28465: LIST
28466: LIST
28467: LIST
28468: PUSH
28469: EMPTY
28470: LIST
28471: LIST
28472: PPUSH
28473: CALL_OW 69
28477: ST_TO_ADDR
// if depots > 0 then
28478: LD_VAR 0 3
28482: PUSH
28483: LD_INT 0
28485: GREATER
28486: IFFALSE 28514
// result := GetResources ( GetBase ( depots [ 1 ] ) ) else
28488: LD_ADDR_VAR 0 2
28492: PUSH
28493: LD_VAR 0 3
28497: PUSH
28498: LD_INT 1
28500: ARRAY
28501: PPUSH
28502: CALL_OW 274
28506: PPUSH
28507: CALL_OW 279
28511: ST_TO_ADDR
28512: GO 28533
// result = [ 0 , 0 , 0 ] ;
28514: LD_ADDR_VAR 0 2
28518: PUSH
28519: LD_INT 0
28521: PUSH
28522: LD_INT 0
28524: PUSH
28525: LD_INT 0
28527: PUSH
28528: EMPTY
28529: LIST
28530: LIST
28531: LIST
28532: ST_TO_ADDR
// end ;
28533: LD_VAR 0 2
28537: RET
// function build_new_vehicle ( side , nation , factory ) ; var can_made , mechanics , wanted ; begin
28538: LD_INT 0
28540: PPUSH
28541: PPUSH
28542: PPUSH
28543: PPUSH
// result = false ;
28544: LD_ADDR_VAR 0 4
28548: PUSH
28549: LD_INT 0
28551: ST_TO_ADDR
// mechanics := request_people ( side , class_mechanic , 1 ) ;
28552: LD_ADDR_VAR 0 6
28556: PUSH
28557: LD_VAR 0 1
28561: PPUSH
28562: LD_INT 3
28564: PPUSH
28565: LD_INT 1
28567: PPUSH
28568: CALL 26825 0 3
28572: ST_TO_ADDR
// can_made := get_progress ( side , nation , factory ) ;
28573: LD_ADDR_VAR 0 5
28577: PUSH
28578: LD_VAR 0 1
28582: PPUSH
28583: LD_VAR 0 2
28587: PPUSH
28588: LD_VAR 0 3
28592: PPUSH
28593: CALL 28709 0 3
28597: ST_TO_ADDR
// if can_made then
28598: LD_VAR 0 5
28602: IFFALSE 28685
// begin wanted := get_next_vehicle ( side , nation , factory , can_made ) ;
28604: LD_ADDR_VAR 0 7
28608: PUSH
28609: LD_VAR 0 1
28613: PPUSH
28614: LD_VAR 0 2
28618: PPUSH
28619: LD_VAR 0 3
28623: PPUSH
28624: LD_VAR 0 5
28628: PPUSH
28629: CALL 29188 0 4
28633: ST_TO_ADDR
// if transfer_mechanics ( side , mechanics , factory , wanted ) then
28634: LD_VAR 0 1
28638: PPUSH
28639: LD_VAR 0 6
28643: PPUSH
28644: LD_VAR 0 3
28648: PPUSH
28649: LD_VAR 0 7
28653: PPUSH
28654: CALL 31657 0 4
28658: IFFALSE 28685
// result = start_building_vehicle ( nation , factory , wanted ) ;
28660: LD_ADDR_VAR 0 4
28664: PUSH
28665: LD_VAR 0 2
28669: PPUSH
28670: LD_VAR 0 3
28674: PPUSH
28675: LD_VAR 0 7
28679: PPUSH
28680: CALL 32089 0 3
28684: ST_TO_ADDR
// end ; cleanup_extensions ( side , nation , factory ) ;
28685: LD_VAR 0 1
28689: PPUSH
28690: LD_VAR 0 2
28694: PPUSH
28695: LD_VAR 0 3
28699: PPUSH
28700: CALL 32323 0 3
// end ;
28704: LD_VAR 0 4
28708: RET
// function get_progress ( side , nation , factory ) ; var vysledek , chassis , weapon , list ; begin
28709: LD_INT 0
28711: PPUSH
28712: PPUSH
28713: PPUSH
28714: PPUSH
28715: PPUSH
// vysledek := [ ] ;
28716: LD_ADDR_VAR 0 5
28720: PUSH
28721: EMPTY
28722: ST_TO_ADDR
// list := [ ] ;
28723: LD_ADDR_VAR 0 8
28727: PUSH
28728: EMPTY
28729: ST_TO_ADDR
// case nation of 1 :
28730: LD_VAR 0 2
28734: PUSH
28735: LD_INT 1
28737: DOUBLE
28738: EQUAL
28739: IFTRUE 28743
28741: GO 28756
28743: POP
// list := us_weapons ; 2 :
28744: LD_ADDR_VAR 0 8
28748: PUSH
28749: LD_LOC 52
28753: ST_TO_ADDR
28754: GO 28799
28756: LD_INT 2
28758: DOUBLE
28759: EQUAL
28760: IFTRUE 28764
28762: GO 28777
28764: POP
// list := ar_weapons ; 3 :
28765: LD_ADDR_VAR 0 8
28769: PUSH
28770: LD_LOC 53
28774: ST_TO_ADDR
28775: GO 28799
28777: LD_INT 3
28779: DOUBLE
28780: EQUAL
28781: IFTRUE 28785
28783: GO 28798
28785: POP
// list := ru_weapons ; end ;
28786: LD_ADDR_VAR 0 8
28790: PUSH
28791: LD_LOC 54
28795: ST_TO_ADDR
28796: GO 28799
28798: POP
// for chassis = 1 to 3 do
28799: LD_ADDR_VAR 0 6
28803: PUSH
28804: DOUBLE
28805: LD_INT 1
28807: DEC
28808: ST_TO_ADDR
28809: LD_INT 3
28811: PUSH
28812: FOR_TO
28813: IFFALSE 28975
// if ( chassis < 3 ) or ( nation = nation_russian ) or ( TrackExtension ( factory ) ) then
28815: LD_VAR 0 6
28819: PUSH
28820: LD_INT 3
28822: LESS
28823: PUSH
28824: LD_VAR 0 2
28828: PUSH
28829: LD_INT 3
28831: EQUAL
28832: OR
28833: PUSH
28834: LD_VAR 0 3
28838: PPUSH
28839: CALL 29883 0 1
28843: OR
28844: IFFALSE 28973
// for weapon in list [ chassis ] do
28846: LD_ADDR_VAR 0 7
28850: PUSH
28851: LD_VAR 0 8
28855: PUSH
28856: LD_VAR 0 6
28860: ARRAY
28861: PUSH
28862: FOR_IN
28863: IFFALSE 28971
// if Technology_Researched ( side , weapon [ 2 ] ) or not weapon [ 2 ] then
28865: LD_VAR 0 1
28869: PPUSH
28870: LD_VAR 0 7
28874: PUSH
28875: LD_INT 2
28877: ARRAY
28878: PPUSH
28879: CALL 28992 0 2
28883: PUSH
28884: LD_VAR 0 7
28888: PUSH
28889: LD_INT 2
28891: ARRAY
28892: NOT
28893: OR
28894: IFFALSE 28969
// begin if ExtensionBuild ( factory , weapon [ 3 ] ) or not weapon [ 3 ] then
28896: LD_VAR 0 3
28900: PPUSH
28901: LD_VAR 0 7
28905: PUSH
28906: LD_INT 3
28908: ARRAY
28909: PPUSH
28910: CALL 29062 0 2
28914: PUSH
28915: LD_VAR 0 7
28919: PUSH
28920: LD_INT 3
28922: ARRAY
28923: NOT
28924: OR
28925: IFFALSE 28949
// vysledek := vysledek ^ weapon [ 1 ] else
28927: LD_ADDR_VAR 0 5
28931: PUSH
28932: LD_VAR 0 5
28936: PUSH
28937: LD_VAR 0 7
28941: PUSH
28942: LD_INT 1
28944: ARRAY
28945: ADD
28946: ST_TO_ADDR
28947: GO 28969
// extension_wanted := extension_wanted ^ weapon [ 3 ] ;
28949: LD_ADDR_EXP 75
28953: PUSH
28954: LD_EXP 75
28958: PUSH
28959: LD_VAR 0 7
28963: PUSH
28964: LD_INT 3
28966: ARRAY
28967: ADD
28968: ST_TO_ADDR
// end ;
28969: GO 28862
28971: POP
28972: POP
28973: GO 28812
28975: POP
28976: POP
// result := vysledek ;
28977: LD_ADDR_VAR 0 4
28981: PUSH
28982: LD_VAR 0 5
28986: ST_TO_ADDR
// end ;
28987: LD_VAR 0 4
28991: RET
// function Technology_Researched ( side , list ) ; var tech , vysledek ; begin
28992: LD_INT 0
28994: PPUSH
28995: PPUSH
28996: PPUSH
// vysledek := true ;
28997: LD_ADDR_VAR 0 5
29001: PUSH
29002: LD_INT 1
29004: ST_TO_ADDR
// for tech in list do
29005: LD_ADDR_VAR 0 4
29009: PUSH
29010: LD_VAR 0 2
29014: PUSH
29015: FOR_IN
29016: IFFALSE 29045
// if not Researched ( side , tech ) then
29018: LD_VAR 0 1
29022: PPUSH
29023: LD_VAR 0 4
29027: PPUSH
29028: CALL_OW 325
29032: NOT
29033: IFFALSE 29043
// vysledek := false ;
29035: LD_ADDR_VAR 0 5
29039: PUSH
29040: LD_INT 0
29042: ST_TO_ADDR
29043: GO 29015
29045: POP
29046: POP
// result := vysledek ;
29047: LD_ADDR_VAR 0 3
29051: PUSH
29052: LD_VAR 0 5
29056: ST_TO_ADDR
// end ;
29057: LD_VAR 0 3
29061: RET
// function ExtensionBuild ( factory , extension ) ; var i , vysledek , list ; begin
29062: LD_INT 0
29064: PPUSH
29065: PPUSH
29066: PPUSH
29067: PPUSH
// vysledek := false ;
29068: LD_ADDR_VAR 0 5
29072: PUSH
29073: LD_INT 0
29075: ST_TO_ADDR
// if extension > 0 then
29076: LD_VAR 0 2
29080: PUSH
29081: LD_INT 0
29083: GREATER
29084: IFFALSE 29165
// begin list := GetExtPositions ( factory ) ;
29086: LD_ADDR_VAR 0 6
29090: PUSH
29091: LD_VAR 0 1
29095: PPUSH
29096: CALL_OW 270
29100: ST_TO_ADDR
// for i in list do
29101: LD_ADDR_VAR 0 4
29105: PUSH
29106: LD_VAR 0 6
29110: PUSH
29111: FOR_IN
29112: IFFALSE 29161
// if GetBType ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) = extension then
29114: LD_VAR 0 4
29118: PUSH
29119: LD_INT 1
29121: ARRAY
29122: PPUSH
29123: LD_VAR 0 4
29127: PUSH
29128: LD_INT 2
29130: ARRAY
29131: PPUSH
29132: CALL_OW 428
29136: PPUSH
29137: CALL_OW 266
29141: PUSH
29142: LD_VAR 0 2
29146: EQUAL
29147: IFFALSE 29159
// begin vysledek := true ;
29149: LD_ADDR_VAR 0 5
29153: PUSH
29154: LD_INT 1
29156: ST_TO_ADDR
// break ;
29157: GO 29161
// end ;
29159: GO 29111
29161: POP
29162: POP
// end else
29163: GO 29173
// vysledek := true ;
29165: LD_ADDR_VAR 0 5
29169: PUSH
29170: LD_INT 1
29172: ST_TO_ADDR
// result := vysledek ;
29173: LD_ADDR_VAR 0 3
29177: PUSH
29178: LD_VAR 0 5
29182: ST_TO_ADDR
// end ;
29183: LD_VAR 0 3
29187: RET
// function get_next_vehicle ( side , nation , factory , possible ) ; var un , pom , list , cargo_bay , crane , nation_cargo , nation_crane , weapon_prefered , weapon_else , vysledek ; begin
29188: LD_INT 0
29190: PPUSH
29191: PPUSH
29192: PPUSH
29193: PPUSH
29194: PPUSH
29195: PPUSH
29196: PPUSH
29197: PPUSH
29198: PPUSH
29199: PPUSH
29200: PPUSH
// vysledek := [ ] ;
29201: LD_ADDR_VAR 0 15
29205: PUSH
29206: EMPTY
29207: ST_TO_ADDR
// case nation of 1 :
29208: LD_VAR 0 2
29212: PUSH
29213: LD_INT 1
29215: DOUBLE
29216: EQUAL
29217: IFTRUE 29221
29219: GO 29250
29221: POP
// begin list := us_weapons ;
29222: LD_ADDR_VAR 0 8
29226: PUSH
29227: LD_LOC 52
29231: ST_TO_ADDR
// nation_cargo := us_cargo_bay ;
29232: LD_ADDR_VAR 0 11
29236: PUSH
29237: LD_INT 12
29239: ST_TO_ADDR
// nation_crane := us_crane ;
29240: LD_ADDR_VAR 0 12
29244: PUSH
29245: LD_INT 13
29247: ST_TO_ADDR
// end ; 2 :
29248: GO 29325
29250: LD_INT 2
29252: DOUBLE
29253: EQUAL
29254: IFTRUE 29258
29256: GO 29287
29258: POP
// begin list := ar_weapons ;
29259: LD_ADDR_VAR 0 8
29263: PUSH
29264: LD_LOC 53
29268: ST_TO_ADDR
// nation_cargo := ar_cargo_bay ;
29269: LD_ADDR_VAR 0 11
29273: PUSH
29274: LD_INT 32
29276: ST_TO_ADDR
// nation_crane := 0 ;
29277: LD_ADDR_VAR 0 12
29281: PUSH
29282: LD_INT 0
29284: ST_TO_ADDR
// end ; 3 :
29285: GO 29325
29287: LD_INT 3
29289: DOUBLE
29290: EQUAL
29291: IFTRUE 29295
29293: GO 29324
29295: POP
// begin list := ru_weapons ;
29296: LD_ADDR_VAR 0 8
29300: PUSH
29301: LD_LOC 54
29305: ST_TO_ADDR
// nation_cargo := ru_cargo_bay ;
29306: LD_ADDR_VAR 0 11
29310: PUSH
29311: LD_INT 51
29313: ST_TO_ADDR
// nation_crane := ru_crane ;
29314: LD_ADDR_VAR 0 12
29318: PUSH
29319: LD_INT 52
29321: ST_TO_ADDR
// end ; end ;
29322: GO 29325
29324: POP
// pom := AvailableWeaponList ( factory ) ;
29325: LD_ADDR_VAR 0 7
29329: PUSH
29330: LD_VAR 0 3
29334: PPUSH
29335: CALL_OW 478
29339: ST_TO_ADDR
// cargo_bay := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_weapon , nation_cargo ] ] ) ;
29340: LD_ADDR_VAR 0 9
29344: PUSH
29345: LD_INT 22
29347: PUSH
29348: LD_VAR 0 1
29352: PUSH
29353: EMPTY
29354: LIST
29355: LIST
29356: PUSH
29357: LD_INT 21
29359: PUSH
29360: LD_INT 2
29362: PUSH
29363: EMPTY
29364: LIST
29365: LIST
29366: PUSH
29367: LD_INT 34
29369: PUSH
29370: LD_VAR 0 11
29374: PUSH
29375: EMPTY
29376: LIST
29377: LIST
29378: PUSH
29379: EMPTY
29380: LIST
29381: LIST
29382: LIST
29383: PPUSH
29384: CALL_OW 69
29388: ST_TO_ADDR
// if ( not cargo_bay ) and ( nation_cargo in pom ) and Remote_or_Computer ( factory ) and TrackExtension ( factory ) then
29389: LD_VAR 0 9
29393: NOT
29394: PUSH
29395: LD_VAR 0 11
29399: PUSH
29400: LD_VAR 0 7
29404: IN
29405: AND
29406: PUSH
29407: LD_VAR 0 3
29411: PPUSH
29412: CALL 29820 0 1
29416: AND
29417: PUSH
29418: LD_VAR 0 3
29422: PPUSH
29423: CALL 29883 0 1
29427: AND
29428: IFFALSE 29462
// vysledek := Define_NonCombat ( side , nation , factory , nation_cargo ) else
29430: LD_ADDR_VAR 0 15
29434: PUSH
29435: LD_VAR 0 1
29439: PPUSH
29440: LD_VAR 0 2
29444: PPUSH
29445: LD_VAR 0 3
29449: PPUSH
29450: LD_VAR 0 11
29454: PPUSH
29455: CALL 29909 0 4
29459: ST_TO_ADDR
29460: GO 29478
// possible := possible diff nation_cargo ;
29462: LD_ADDR_VAR 0 4
29466: PUSH
29467: LD_VAR 0 4
29471: PUSH
29472: LD_VAR 0 11
29476: DIFF
29477: ST_TO_ADDR
// if not vysledek then
29478: LD_VAR 0 15
29482: NOT
29483: IFFALSE 29623
// begin crane := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_weapon , nation_crane ] ] ) ;
29485: LD_ADDR_VAR 0 10
29489: PUSH
29490: LD_INT 22
29492: PUSH
29493: LD_VAR 0 1
29497: PUSH
29498: EMPTY
29499: LIST
29500: LIST
29501: PUSH
29502: LD_INT 21
29504: PUSH
29505: LD_INT 2
29507: PUSH
29508: EMPTY
29509: LIST
29510: LIST
29511: PUSH
29512: LD_INT 34
29514: PUSH
29515: LD_VAR 0 12
29519: PUSH
29520: EMPTY
29521: LIST
29522: LIST
29523: PUSH
29524: EMPTY
29525: LIST
29526: LIST
29527: LIST
29528: PPUSH
29529: CALL_OW 69
29533: ST_TO_ADDR
// if ( not crane ) and ( nation_crane in pom ) and Remote_or_Computer ( factory ) and TrackExtension ( factory ) then
29534: LD_VAR 0 10
29538: NOT
29539: PUSH
29540: LD_VAR 0 12
29544: PUSH
29545: LD_VAR 0 7
29549: IN
29550: AND
29551: PUSH
29552: LD_VAR 0 3
29556: PPUSH
29557: CALL 29820 0 1
29561: AND
29562: PUSH
29563: LD_VAR 0 3
29567: PPUSH
29568: CALL 29883 0 1
29572: AND
29573: IFFALSE 29607
// vysledek := Define_NonCombat ( side , nation , factory , nation_crane ) else
29575: LD_ADDR_VAR 0 15
29579: PUSH
29580: LD_VAR 0 1
29584: PPUSH
29585: LD_VAR 0 2
29589: PPUSH
29590: LD_VAR 0 3
29594: PPUSH
29595: LD_VAR 0 12
29599: PPUSH
29600: CALL 29909 0 4
29604: ST_TO_ADDR
29605: GO 29623
// possible := possible diff nation_crane ;
29607: LD_ADDR_VAR 0 4
29611: PUSH
29612: LD_VAR 0 4
29616: PUSH
29617: LD_VAR 0 12
29621: DIFF
29622: ST_TO_ADDR
// end ; if not vysledek then
29623: LD_VAR 0 15
29627: NOT
29628: IFFALSE 29805
// begin weapon_prefered := [ ] ;
29630: LD_ADDR_VAR 0 13
29634: PUSH
29635: EMPTY
29636: ST_TO_ADDR
// weapon_else := 0 ;
29637: LD_ADDR_VAR 0 14
29641: PUSH
29642: LD_INT 0
29644: ST_TO_ADDR
// for un in prefered do
29645: LD_ADDR_VAR 0 6
29649: PUSH
29650: LD_LOC 57
29654: PUSH
29655: FOR_IN
29656: IFFALSE 29695
// if ( un [ 4 ] in possible ) then
29658: LD_VAR 0 6
29662: PUSH
29663: LD_INT 4
29665: ARRAY
29666: PUSH
29667: LD_VAR 0 4
29671: IN
29672: IFFALSE 29693
// weapon_prefered := weapon_prefered ^ [ un ] ;
29674: LD_ADDR_VAR 0 13
29678: PUSH
29679: LD_VAR 0 13
29683: PUSH
29684: LD_VAR 0 6
29688: PUSH
29689: EMPTY
29690: LIST
29691: ADD
29692: ST_TO_ADDR
29693: GO 29655
29695: POP
29696: POP
// if not weapon_prefered then
29697: LD_VAR 0 13
29701: NOT
29702: IFFALSE 29775
// begin for un in possible do
29704: LD_ADDR_VAR 0 6
29708: PUSH
29709: LD_VAR 0 4
29713: PUSH
29714: FOR_IN
29715: IFFALSE 29741
// if un > weapon_else then
29717: LD_VAR 0 6
29721: PUSH
29722: LD_VAR 0 14
29726: GREATER
29727: IFFALSE 29739
// weapon_else := un ;
29729: LD_ADDR_VAR 0 14
29733: PUSH
29734: LD_VAR 0 6
29738: ST_TO_ADDR
29739: GO 29714
29741: POP
29742: POP
// vysledek := Define_Vehicle ( side , nation , factory , weapon_else ) ;
29743: LD_ADDR_VAR 0 15
29747: PUSH
29748: LD_VAR 0 1
29752: PPUSH
29753: LD_VAR 0 2
29757: PPUSH
29758: LD_VAR 0 3
29762: PPUSH
29763: LD_VAR 0 14
29767: PPUSH
29768: CALL 30709 0 4
29772: ST_TO_ADDR
// end else
29773: GO 29805
// vysledek := Select_from_Prefered ( side , nation , factory , weapon_prefered ) ;
29775: LD_ADDR_VAR 0 15
29779: PUSH
29780: LD_VAR 0 1
29784: PPUSH
29785: LD_VAR 0 2
29789: PPUSH
29790: LD_VAR 0 3
29794: PPUSH
29795: LD_VAR 0 13
29799: PPUSH
29800: CALL 30181 0 4
29804: ST_TO_ADDR
// end ; result := vysledek ;
29805: LD_ADDR_VAR 0 5
29809: PUSH
29810: LD_VAR 0 15
29814: ST_TO_ADDR
// end ;
29815: LD_VAR 0 5
29819: RET
// function Remote_or_Computer ( factory ) ; var vysledek ; begin
29820: LD_INT 0
29822: PPUSH
29823: PPUSH
// vysledek := false ;
29824: LD_ADDR_VAR 0 3
29828: PUSH
29829: LD_INT 0
29831: ST_TO_ADDR
// if ExtensionBuild ( factory , b_ext_computer ) or ExtensionBuild ( factory , b_ext_radar ) then
29832: LD_VAR 0 1
29836: PPUSH
29837: LD_INT 24
29839: PPUSH
29840: CALL 29062 0 2
29844: PUSH
29845: LD_VAR 0 1
29849: PPUSH
29850: LD_INT 20
29852: PPUSH
29853: CALL 29062 0 2
29857: OR
29858: IFFALSE 29868
// vysledek := true ;
29860: LD_ADDR_VAR 0 3
29864: PUSH
29865: LD_INT 1
29867: ST_TO_ADDR
// result := vysledek ;
29868: LD_ADDR_VAR 0 2
29872: PUSH
29873: LD_VAR 0 3
29877: ST_TO_ADDR
// end ;
29878: LD_VAR 0 2
29882: RET
// function TrackExtension ( factory ) ; begin
29883: LD_INT 0
29885: PPUSH
// result := ExtensionBuild ( factory , b_ext_track ) ;
29886: LD_ADDR_VAR 0 2
29890: PUSH
29891: LD_VAR 0 1
29895: PPUSH
29896: LD_INT 16
29898: PPUSH
29899: CALL 29062 0 2
29903: ST_TO_ADDR
// end ;
29904: LD_VAR 0 2
29908: RET
// function Define_NonCombat ( side , nation , factory , weapon ) ; var components ; begin
29909: LD_INT 0
29911: PPUSH
29912: PPUSH
// components := [ ] ;
29913: LD_ADDR_VAR 0 6
29917: PUSH
29918: EMPTY
29919: ST_TO_ADDR
// case nation of 1 :
29920: LD_VAR 0 2
29924: PUSH
29925: LD_INT 1
29927: DOUBLE
29928: EQUAL
29929: IFTRUE 29933
29931: GO 29950
29933: POP
// components := components ^ us_medium_tracked ; 2 :
29934: LD_ADDR_VAR 0 6
29938: PUSH
29939: LD_VAR 0 6
29943: PUSH
29944: LD_INT 3
29946: ADD
29947: ST_TO_ADDR
29948: GO 30001
29950: LD_INT 2
29952: DOUBLE
29953: EQUAL
29954: IFTRUE 29958
29956: GO 29975
29958: POP
// components := components ^ ar_half_tracked ; 3 :
29959: LD_ADDR_VAR 0 6
29963: PUSH
29964: LD_VAR 0 6
29968: PUSH
29969: LD_INT 14
29971: ADD
29972: ST_TO_ADDR
29973: GO 30001
29975: LD_INT 3
29977: DOUBLE
29978: EQUAL
29979: IFTRUE 29983
29981: GO 30000
29983: POP
// components := components ^ ru_medium_tracked ; end ;
29984: LD_ADDR_VAR 0 6
29988: PUSH
29989: LD_VAR 0 6
29993: PUSH
29994: LD_INT 22
29996: ADD
29997: ST_TO_ADDR
29998: GO 30001
30000: POP
// if ExtensionBuild ( factory , b_ext_siberium ) and ( Get_Resources ( side ) [ 3 ] >= sib_engine ) then
30001: LD_VAR 0 3
30005: PPUSH
30006: LD_INT 21
30008: PPUSH
30009: CALL 29062 0 2
30013: PUSH
30014: LD_VAR 0 1
30018: PPUSH
30019: CALL 28420 0 1
30023: PUSH
30024: LD_INT 3
30026: ARRAY
30027: PUSH
30028: LD_LOC 55
30032: GREATEREQUAL
30033: AND
30034: IFFALSE 30052
// components := components ^ engine_siberite else
30036: LD_ADDR_VAR 0 6
30040: PUSH
30041: LD_VAR 0 6
30045: PUSH
30046: LD_INT 3
30048: ADD
30049: ST_TO_ADDR
30050: GO 30066
// components := components ^ engine_combustion ;
30052: LD_ADDR_VAR 0 6
30056: PUSH
30057: LD_VAR 0 6
30061: PUSH
30062: LD_INT 1
30064: ADD
30065: ST_TO_ADDR
// if ( nation = nation_arabian ) and ApemanCanDrive ( side ) then
30066: LD_VAR 0 2
30070: PUSH
30071: LD_INT 2
30073: EQUAL
30074: PUSH
30075: LD_VAR 0 1
30079: PPUSH
30080: CALL 31594 0 1
30084: AND
30085: IFFALSE 30103
// components := components ^ control_apeman else
30087: LD_ADDR_VAR 0 6
30091: PUSH
30092: LD_VAR 0 6
30096: PUSH
30097: LD_INT 5
30099: ADD
30100: ST_TO_ADDR
30101: GO 30147
// if ExtensionBuild ( factory , b_ext_computer ) then
30103: LD_VAR 0 3
30107: PPUSH
30108: LD_INT 24
30110: PPUSH
30111: CALL 29062 0 2
30115: IFFALSE 30133
// components := components ^ control_computer else
30117: LD_ADDR_VAR 0 6
30121: PUSH
30122: LD_VAR 0 6
30126: PUSH
30127: LD_INT 3
30129: ADD
30130: ST_TO_ADDR
30131: GO 30147
// components := components ^ control_remote ;
30133: LD_ADDR_VAR 0 6
30137: PUSH
30138: LD_VAR 0 6
30142: PUSH
30143: LD_INT 2
30145: ADD
30146: ST_TO_ADDR
// components := components ^ [ weapon ] ;
30147: LD_ADDR_VAR 0 6
30151: PUSH
30152: LD_VAR 0 6
30156: PUSH
30157: LD_VAR 0 4
30161: PUSH
30162: EMPTY
30163: LIST
30164: ADD
30165: ST_TO_ADDR
// result := components ;
30166: LD_ADDR_VAR 0 5
30170: PUSH
30171: LD_VAR 0 6
30175: ST_TO_ADDR
// end ;
30176: LD_VAR 0 5
30180: RET
// function Select_from_Prefered ( side , nation , factory , possible ) ; var un , i , count , components , controls , vysledek ; begin
30181: LD_INT 0
30183: PPUSH
30184: PPUSH
30185: PPUSH
30186: PPUSH
30187: PPUSH
30188: PPUSH
30189: PPUSH
// count := [ - 1 , 0 ] ;
30190: LD_ADDR_VAR 0 8
30194: PUSH
30195: LD_INT 1
30197: NEG
30198: PUSH
30199: LD_INT 0
30201: PUSH
30202: EMPTY
30203: LIST
30204: LIST
30205: ST_TO_ADDR
// for un in possible do
30206: LD_ADDR_VAR 0 6
30210: PUSH
30211: LD_VAR 0 4
30215: PUSH
30216: FOR_IN
30217: IFFALSE 30316
// begin i := 0 + FilterAllUnits ( [ [ f_side , side ] , [ f_weapon , un [ 4 ] ] ] ) ;
30219: LD_ADDR_VAR 0 7
30223: PUSH
30224: LD_INT 0
30226: PUSH
30227: LD_INT 22
30229: PUSH
30230: LD_VAR 0 1
30234: PUSH
30235: EMPTY
30236: LIST
30237: LIST
30238: PUSH
30239: LD_INT 34
30241: PUSH
30242: LD_VAR 0 6
30246: PUSH
30247: LD_INT 4
30249: ARRAY
30250: PUSH
30251: EMPTY
30252: LIST
30253: LIST
30254: PUSH
30255: EMPTY
30256: LIST
30257: LIST
30258: PPUSH
30259: CALL_OW 69
30263: PLUS
30264: ST_TO_ADDR
// if ( count [ 1 ] < 0 ) or ( count [ 1 ] > i ) then
30265: LD_VAR 0 8
30269: PUSH
30270: LD_INT 1
30272: ARRAY
30273: PUSH
30274: LD_INT 0
30276: LESS
30277: PUSH
30278: LD_VAR 0 8
30282: PUSH
30283: LD_INT 1
30285: ARRAY
30286: PUSH
30287: LD_VAR 0 7
30291: GREATER
30292: OR
30293: IFFALSE 30314
// count := [ i , un ] ;
30295: LD_ADDR_VAR 0 8
30299: PUSH
30300: LD_VAR 0 7
30304: PUSH
30305: LD_VAR 0 6
30309: PUSH
30310: EMPTY
30311: LIST
30312: LIST
30313: ST_TO_ADDR
// end ;
30314: GO 30216
30316: POP
30317: POP
// un := count [ 2 ] ;
30318: LD_ADDR_VAR 0 6
30322: PUSH
30323: LD_VAR 0 8
30327: PUSH
30328: LD_INT 2
30330: ARRAY
30331: ST_TO_ADDR
// components := [ ] ;
30332: LD_ADDR_VAR 0 9
30336: PUSH
30337: EMPTY
30338: ST_TO_ADDR
// controls := AvailableControlList ( factory ) ;
30339: LD_ADDR_VAR 0 10
30343: PUSH
30344: LD_VAR 0 3
30348: PPUSH
30349: CALL_OW 477
30353: ST_TO_ADDR
// if un [ 1 ] in AvailableChassisList ( factory ) then
30354: LD_VAR 0 6
30358: PUSH
30359: LD_INT 1
30361: ARRAY
30362: PUSH
30363: LD_VAR 0 3
30367: PPUSH
30368: CALL_OW 475
30372: IN
30373: IFFALSE 30397
// components := components ^ un [ 1 ] else
30375: LD_ADDR_VAR 0 9
30379: PUSH
30380: LD_VAR 0 9
30384: PUSH
30385: LD_VAR 0 6
30389: PUSH
30390: LD_INT 1
30392: ARRAY
30393: ADD
30394: ST_TO_ADDR
30395: GO 30447
// components := components ^ SelectChassis ( side , nation , factory , ChassisWeight ( nation , un [ 4 ] ) ) ;
30397: LD_ADDR_VAR 0 9
30401: PUSH
30402: LD_VAR 0 9
30406: PUSH
30407: LD_VAR 0 1
30411: PPUSH
30412: LD_VAR 0 2
30416: PPUSH
30417: LD_VAR 0 3
30421: PPUSH
30422: LD_VAR 0 2
30426: PPUSH
30427: LD_VAR 0 6
30431: PUSH
30432: LD_INT 4
30434: ARRAY
30435: PPUSH
30436: CALL 31417 0 2
30440: PPUSH
30441: CALL 31051 0 4
30445: ADD
30446: ST_TO_ADDR
// if un [ 2 ] in AvailableEngineList ( factory ) then
30447: LD_VAR 0 6
30451: PUSH
30452: LD_INT 2
30454: ARRAY
30455: PUSH
30456: LD_VAR 0 3
30460: PPUSH
30461: CALL_OW 476
30465: IN
30466: IFFALSE 30490
// components := components ^ un [ 2 ] else
30468: LD_ADDR_VAR 0 9
30472: PUSH
30473: LD_VAR 0 9
30477: PUSH
30478: LD_VAR 0 6
30482: PUSH
30483: LD_INT 2
30485: ARRAY
30486: ADD
30487: ST_TO_ADDR
30488: GO 30565
// if ( not components [ 1 ] in [ us_light_wheeled , ar_hovercraft , ar_light_trike ] ) and ( Get_Resources ( side ) [ 3 ] > 9 ) then
30490: LD_VAR 0 9
30494: PUSH
30495: LD_INT 1
30497: ARRAY
30498: PUSH
30499: LD_INT 1
30501: PUSH
30502: LD_INT 11
30504: PUSH
30505: LD_INT 12
30507: PUSH
30508: EMPTY
30509: LIST
30510: LIST
30511: LIST
30512: IN
30513: NOT
30514: PUSH
30515: LD_VAR 0 1
30519: PPUSH
30520: CALL 28420 0 1
30524: PUSH
30525: LD_INT 3
30527: ARRAY
30528: PUSH
30529: LD_INT 9
30531: GREATER
30532: AND
30533: IFFALSE 30551
// components := components ^ engine_siberite else
30535: LD_ADDR_VAR 0 9
30539: PUSH
30540: LD_VAR 0 9
30544: PUSH
30545: LD_INT 3
30547: ADD
30548: ST_TO_ADDR
30549: GO 30565
// components := components ^ engine_combustion ;
30551: LD_ADDR_VAR 0 9
30555: PUSH
30556: LD_VAR 0 9
30560: PUSH
30561: LD_INT 1
30563: ADD
30564: ST_TO_ADDR
// if un [ 3 ] in AvailableControlList ( factory ) then
30565: LD_VAR 0 6
30569: PUSH
30570: LD_INT 3
30572: ARRAY
30573: PUSH
30574: LD_VAR 0 3
30578: PPUSH
30579: CALL_OW 477
30583: IN
30584: IFFALSE 30608
// components := components ^ un [ 3 ] else
30586: LD_ADDR_VAR 0 9
30590: PUSH
30591: LD_VAR 0 9
30595: PUSH
30596: LD_VAR 0 6
30600: PUSH
30601: LD_INT 3
30603: ARRAY
30604: ADD
30605: ST_TO_ADDR
30606: GO 30674
// begin if control_remote in controls then
30608: LD_INT 2
30610: PUSH
30611: LD_VAR 0 10
30615: IN
30616: IFFALSE 30634
// components := components ^ control_remote else
30618: LD_ADDR_VAR 0 9
30622: PUSH
30623: LD_VAR 0 9
30627: PUSH
30628: LD_INT 2
30630: ADD
30631: ST_TO_ADDR
30632: GO 30674
// if control_computer in controls then
30634: LD_INT 3
30636: PUSH
30637: LD_VAR 0 10
30641: IN
30642: IFFALSE 30660
// components := components ^ control_computer else
30644: LD_ADDR_VAR 0 9
30648: PUSH
30649: LD_VAR 0 9
30653: PUSH
30654: LD_INT 3
30656: ADD
30657: ST_TO_ADDR
30658: GO 30674
// components := components ^ control_manual ;
30660: LD_ADDR_VAR 0 9
30664: PUSH
30665: LD_VAR 0 9
30669: PUSH
30670: LD_INT 1
30672: ADD
30673: ST_TO_ADDR
// end ; components := components ^ un [ 4 ] ;
30674: LD_ADDR_VAR 0 9
30678: PUSH
30679: LD_VAR 0 9
30683: PUSH
30684: LD_VAR 0 6
30688: PUSH
30689: LD_INT 4
30691: ARRAY
30692: ADD
30693: ST_TO_ADDR
// result := components ;
30694: LD_ADDR_VAR 0 5
30698: PUSH
30699: LD_VAR 0 9
30703: ST_TO_ADDR
// end ;
30704: LD_VAR 0 5
30708: RET
// function Define_Vehicle ( side , nation , factory , weapon ) ; var components ; begin
30709: LD_INT 0
30711: PPUSH
30712: PPUSH
// components := [ ] ;
30713: LD_ADDR_VAR 0 6
30717: PUSH
30718: EMPTY
30719: ST_TO_ADDR
// case ChassisWeight ( nation , weapon ) of 1 :
30720: LD_VAR 0 2
30724: PPUSH
30725: LD_VAR 0 4
30729: PPUSH
30730: CALL 31417 0 2
30734: PUSH
30735: LD_INT 1
30737: DOUBLE
30738: EQUAL
30739: IFTRUE 30743
30741: GO 30780
30743: POP
// components := components ^ SelectChassis ( side , nation , factory , 1 ) ; 2 :
30744: LD_ADDR_VAR 0 6
30748: PUSH
30749: LD_VAR 0 6
30753: PUSH
30754: LD_VAR 0 1
30758: PPUSH
30759: LD_VAR 0 2
30763: PPUSH
30764: LD_VAR 0 3
30768: PPUSH
30769: LD_INT 1
30771: PPUSH
30772: CALL 31051 0 4
30776: ADD
30777: ST_TO_ADDR
30778: GO 30871
30780: LD_INT 2
30782: DOUBLE
30783: EQUAL
30784: IFTRUE 30788
30786: GO 30825
30788: POP
// components := components ^ SelectChassis ( side , nation , factory , 2 ) ; 3 :
30789: LD_ADDR_VAR 0 6
30793: PUSH
30794: LD_VAR 0 6
30798: PUSH
30799: LD_VAR 0 1
30803: PPUSH
30804: LD_VAR 0 2
30808: PPUSH
30809: LD_VAR 0 3
30813: PPUSH
30814: LD_INT 2
30816: PPUSH
30817: CALL 31051 0 4
30821: ADD
30822: ST_TO_ADDR
30823: GO 30871
30825: LD_INT 3
30827: DOUBLE
30828: EQUAL
30829: IFTRUE 30833
30831: GO 30870
30833: POP
// components := components ^ SelectChassis ( side , nation , factory , 3 ) ; end ;
30834: LD_ADDR_VAR 0 6
30838: PUSH
30839: LD_VAR 0 6
30843: PUSH
30844: LD_VAR 0 1
30848: PPUSH
30849: LD_VAR 0 2
30853: PPUSH
30854: LD_VAR 0 3
30858: PPUSH
30859: LD_INT 3
30861: PPUSH
30862: CALL 31051 0 4
30866: ADD
30867: ST_TO_ADDR
30868: GO 30871
30870: POP
// if ExtensionBuild ( factory , b_ext_siberium ) and ( Get_Resources ( side ) [ 3 ] >= sib_engine ) then
30871: LD_VAR 0 3
30875: PPUSH
30876: LD_INT 21
30878: PPUSH
30879: CALL 29062 0 2
30883: PUSH
30884: LD_VAR 0 1
30888: PPUSH
30889: CALL 28420 0 1
30893: PUSH
30894: LD_INT 3
30896: ARRAY
30897: PUSH
30898: LD_LOC 55
30902: GREATEREQUAL
30903: AND
30904: IFFALSE 30922
// components := components ^ engine_siberite else
30906: LD_ADDR_VAR 0 6
30910: PUSH
30911: LD_VAR 0 6
30915: PUSH
30916: LD_INT 3
30918: ADD
30919: ST_TO_ADDR
30920: GO 30936
// components := components ^ engine_combustion ;
30922: LD_ADDR_VAR 0 6
30926: PUSH
30927: LD_VAR 0 6
30931: PUSH
30932: LD_INT 1
30934: ADD
30935: ST_TO_ADDR
// if ( nation = nation_arabian ) and ApemanCanDrive ( side ) then
30936: LD_VAR 0 2
30940: PUSH
30941: LD_INT 2
30943: EQUAL
30944: PUSH
30945: LD_VAR 0 1
30949: PPUSH
30950: CALL 31594 0 1
30954: AND
30955: IFFALSE 30973
// components := components ^ control_apeman else
30957: LD_ADDR_VAR 0 6
30961: PUSH
30962: LD_VAR 0 6
30966: PUSH
30967: LD_INT 5
30969: ADD
30970: ST_TO_ADDR
30971: GO 31017
// if ExtensionBuild ( factory , b_ext_computer ) then
30973: LD_VAR 0 3
30977: PPUSH
30978: LD_INT 24
30980: PPUSH
30981: CALL 29062 0 2
30985: IFFALSE 31003
// components := components ^ control_computer else
30987: LD_ADDR_VAR 0 6
30991: PUSH
30992: LD_VAR 0 6
30996: PUSH
30997: LD_INT 3
30999: ADD
31000: ST_TO_ADDR
31001: GO 31017
// components := components ^ control_remote ;
31003: LD_ADDR_VAR 0 6
31007: PUSH
31008: LD_VAR 0 6
31012: PUSH
31013: LD_INT 2
31015: ADD
31016: ST_TO_ADDR
// components := components ^ [ weapon ] ;
31017: LD_ADDR_VAR 0 6
31021: PUSH
31022: LD_VAR 0 6
31026: PUSH
31027: LD_VAR 0 4
31031: PUSH
31032: EMPTY
31033: LIST
31034: ADD
31035: ST_TO_ADDR
// result := components ;
31036: LD_ADDR_VAR 0 5
31040: PUSH
31041: LD_VAR 0 6
31045: ST_TO_ADDR
// end ;
31046: LD_VAR 0 5
31050: RET
// function SelectChassis ( side , nation , factory , weight ) ; var un , vysledek ; begin
31051: LD_INT 0
31053: PPUSH
31054: PPUSH
31055: PPUSH
// vysledek := 0 ;
31056: LD_ADDR_VAR 0 7
31060: PUSH
31061: LD_INT 0
31063: ST_TO_ADDR
// case weight of 1 :
31064: LD_VAR 0 4
31068: PUSH
31069: LD_INT 1
31071: DOUBLE
31072: EQUAL
31073: IFTRUE 31077
31075: GO 31140
31077: POP
// begin case nation of 1 :
31078: LD_VAR 0 2
31082: PUSH
31083: LD_INT 1
31085: DOUBLE
31086: EQUAL
31087: IFTRUE 31091
31089: GO 31102
31091: POP
// vysledek := us_light_wheeled ; 2 :
31092: LD_ADDR_VAR 0 7
31096: PUSH
31097: LD_INT 1
31099: ST_TO_ADDR
31100: GO 31138
31102: LD_INT 2
31104: DOUBLE
31105: EQUAL
31106: IFTRUE 31110
31108: GO 31137
31110: POP
// if hovers_recomended then
31111: LD_LOC 59
31115: IFFALSE 31127
// vysledek := ar_hovercraft else
31117: LD_ADDR_VAR 0 7
31121: PUSH
31122: LD_INT 11
31124: ST_TO_ADDR
31125: GO 31135
// vysledek := ar_light_trike ; end ;
31127: LD_ADDR_VAR 0 7
31131: PUSH
31132: LD_INT 12
31134: ST_TO_ADDR
31135: GO 31138
31137: POP
// end ; 2 :
31138: GO 31402
31140: LD_INT 2
31142: DOUBLE
31143: EQUAL
31144: IFTRUE 31148
31146: GO 31297
31148: POP
// begin if ( not flat_land ) and TrackExtension ( factory ) then
31149: LD_LOC 60
31153: NOT
31154: PUSH
31155: LD_VAR 0 3
31159: PPUSH
31160: CALL 29883 0 1
31164: AND
31165: IFFALSE 31232
// case nation of 1 :
31167: LD_VAR 0 2
31171: PUSH
31172: LD_INT 1
31174: DOUBLE
31175: EQUAL
31176: IFTRUE 31180
31178: GO 31191
31180: POP
// vysledek := us_medium_tracked ; 2 :
31181: LD_ADDR_VAR 0 7
31185: PUSH
31186: LD_INT 3
31188: ST_TO_ADDR
31189: GO 31230
31191: LD_INT 2
31193: DOUBLE
31194: EQUAL
31195: IFTRUE 31199
31197: GO 31210
31199: POP
// vysledek := ar_half_tracked ; 3 :
31200: LD_ADDR_VAR 0 7
31204: PUSH
31205: LD_INT 14
31207: ST_TO_ADDR
31208: GO 31230
31210: LD_INT 3
31212: DOUBLE
31213: EQUAL
31214: IFTRUE 31218
31216: GO 31229
31218: POP
// vysledek := ru_medium_tracked ; end else
31219: LD_ADDR_VAR 0 7
31223: PUSH
31224: LD_INT 22
31226: ST_TO_ADDR
31227: GO 31230
31229: POP
31230: GO 31295
// case nation of 1 :
31232: LD_VAR 0 2
31236: PUSH
31237: LD_INT 1
31239: DOUBLE
31240: EQUAL
31241: IFTRUE 31245
31243: GO 31256
31245: POP
// vysledek := us_medium_wheeled ; 2 :
31246: LD_ADDR_VAR 0 7
31250: PUSH
31251: LD_INT 2
31253: ST_TO_ADDR
31254: GO 31295
31256: LD_INT 2
31258: DOUBLE
31259: EQUAL
31260: IFTRUE 31264
31262: GO 31275
31264: POP
// vysledek := ar_medium_trike ; 3 :
31265: LD_ADDR_VAR 0 7
31269: PUSH
31270: LD_INT 13
31272: ST_TO_ADDR
31273: GO 31295
31275: LD_INT 3
31277: DOUBLE
31278: EQUAL
31279: IFTRUE 31283
31281: GO 31294
31283: POP
// vysledek := ru_medium_wheeled ; end end ; 3 :
31284: LD_ADDR_VAR 0 7
31288: PUSH
31289: LD_INT 21
31291: ST_TO_ADDR
31292: GO 31295
31294: POP
31295: GO 31402
31297: LD_INT 3
31299: DOUBLE
31300: EQUAL
31301: IFTRUE 31305
31303: GO 31401
31305: POP
// begin case nation of 1 :
31306: LD_VAR 0 2
31310: PUSH
31311: LD_INT 1
31313: DOUBLE
31314: EQUAL
31315: IFTRUE 31319
31317: GO 31358
31319: POP
// if GetTech ( side , tech_AdvChassis ) = state_researched then
31320: LD_VAR 0 1
31324: PPUSH
31325: LD_INT 36
31327: PPUSH
31328: CALL_OW 321
31332: PUSH
31333: LD_INT 2
31335: EQUAL
31336: IFFALSE 31348
// vysledek := us_morphling else
31338: LD_ADDR_VAR 0 7
31342: PUSH
31343: LD_INT 5
31345: ST_TO_ADDR
31346: GO 31356
// vysledek := us_heavy_tracked ; 3 :
31348: LD_ADDR_VAR 0 7
31352: PUSH
31353: LD_INT 4
31355: ST_TO_ADDR
31356: GO 31399
31358: LD_INT 3
31360: DOUBLE
31361: EQUAL
31362: IFTRUE 31366
31364: GO 31398
31366: POP
// if TrackExtension ( factory ) then
31367: LD_VAR 0 3
31371: PPUSH
31372: CALL 29883 0 1
31376: IFFALSE 31388
// vysledek := ru_heavy_tracked else
31378: LD_ADDR_VAR 0 7
31382: PUSH
31383: LD_INT 24
31385: ST_TO_ADDR
31386: GO 31396
// vysledek := ru_heavy_wheeled ; end end ; end ;
31388: LD_ADDR_VAR 0 7
31392: PUSH
31393: LD_INT 23
31395: ST_TO_ADDR
31396: GO 31399
31398: POP
31399: GO 31402
31401: POP
// result := vysledek ;
31402: LD_ADDR_VAR 0 5
31406: PUSH
31407: LD_VAR 0 7
31411: ST_TO_ADDR
// end ;
31412: LD_VAR 0 5
31416: RET
// function ChassisWeight ( nation , weapon ) ; var chassis , un , vysledek , weapon_list ; begin
31417: LD_INT 0
31419: PPUSH
31420: PPUSH
31421: PPUSH
31422: PPUSH
31423: PPUSH
// case nation of 1 :
31424: LD_VAR 0 1
31428: PUSH
31429: LD_INT 1
31431: DOUBLE
31432: EQUAL
31433: IFTRUE 31437
31435: GO 31450
31437: POP
// weapon_list := us_weapons ; 2 :
31438: LD_ADDR_VAR 0 7
31442: PUSH
31443: LD_LOC 52
31447: ST_TO_ADDR
31448: GO 31493
31450: LD_INT 2
31452: DOUBLE
31453: EQUAL
31454: IFTRUE 31458
31456: GO 31471
31458: POP
// weapon_list := ar_weapons ; 3 :
31459: LD_ADDR_VAR 0 7
31463: PUSH
31464: LD_LOC 53
31468: ST_TO_ADDR
31469: GO 31493
31471: LD_INT 3
31473: DOUBLE
31474: EQUAL
31475: IFTRUE 31479
31477: GO 31492
31479: POP
// weapon_list := ru_weapons ; end ;
31480: LD_ADDR_VAR 0 7
31484: PUSH
31485: LD_LOC 54
31489: ST_TO_ADDR
31490: GO 31493
31492: POP
// vysledek := false ;
31493: LD_ADDR_VAR 0 6
31497: PUSH
31498: LD_INT 0
31500: ST_TO_ADDR
// for chassis = 1 to 3 do
31501: LD_ADDR_VAR 0 4
31505: PUSH
31506: DOUBLE
31507: LD_INT 1
31509: DEC
31510: ST_TO_ADDR
31511: LD_INT 3
31513: PUSH
31514: FOR_TO
31515: IFFALSE 31577
// if not vysledek then
31517: LD_VAR 0 6
31521: NOT
31522: IFFALSE 31575
// for un in weapon_list [ chassis ] do
31524: LD_ADDR_VAR 0 5
31528: PUSH
31529: LD_VAR 0 7
31533: PUSH
31534: LD_VAR 0 4
31538: ARRAY
31539: PUSH
31540: FOR_IN
31541: IFFALSE 31573
// if weapon = un [ 1 ] then
31543: LD_VAR 0 2
31547: PUSH
31548: LD_VAR 0 5
31552: PUSH
31553: LD_INT 1
31555: ARRAY
31556: EQUAL
31557: IFFALSE 31571
// begin vysledek := chassis ;
31559: LD_ADDR_VAR 0 6
31563: PUSH
31564: LD_VAR 0 4
31568: ST_TO_ADDR
// break ;
31569: GO 31573
// end ;
31571: GO 31540
31573: POP
31574: POP
31575: GO 31514
31577: POP
31578: POP
// result := vysledek ;
31579: LD_ADDR_VAR 0 3
31583: PUSH
31584: LD_VAR 0 6
31588: ST_TO_ADDR
// end ;
31589: LD_VAR 0 3
31593: RET
// function ApemanCanDrive ( side ) ; var un ; begin
31594: LD_INT 0
31596: PPUSH
31597: PPUSH
// result := ( GetTech ( side , tech_ApeNeural ) = state_researched ) and FilterAllUnits ( [ [ f_side , side ] , [ f_class , class_apeman ] ] ) ;
31598: LD_ADDR_VAR 0 2
31602: PUSH
31603: LD_VAR 0 1
31607: PPUSH
31608: LD_INT 3
31610: PPUSH
31611: CALL_OW 321
31615: PUSH
31616: LD_INT 2
31618: EQUAL
31619: PUSH
31620: LD_INT 22
31622: PUSH
31623: LD_VAR 0 1
31627: PUSH
31628: EMPTY
31629: LIST
31630: LIST
31631: PUSH
31632: LD_INT 25
31634: PUSH
31635: LD_INT 12
31637: PUSH
31638: EMPTY
31639: LIST
31640: LIST
31641: PUSH
31642: EMPTY
31643: LIST
31644: LIST
31645: PPUSH
31646: CALL_OW 69
31650: AND
31651: ST_TO_ADDR
// end ;
31652: LD_VAR 0 2
31656: RET
// function transfer_mechanics ( side , mechanics , factory , components ) ; var un , isin ; begin
31657: LD_INT 0
31659: PPUSH
31660: PPUSH
31661: PPUSH
// isin := UnitsInside ( factory ) ;
31662: LD_ADDR_VAR 0 7
31666: PUSH
31667: LD_VAR 0 3
31671: PPUSH
31672: CALL_OW 313
31676: ST_TO_ADDR
// if ( 0 + isin ) > 5 then
31677: LD_INT 0
31679: PUSH
31680: LD_VAR 0 7
31684: PLUS
31685: PUSH
31686: LD_INT 5
31688: GREATER
31689: IFFALSE 31701
// begin result := true ;
31691: LD_ADDR_VAR 0 5
31695: PUSH
31696: LD_INT 1
31698: ST_TO_ADDR
// exit ;
31699: GO 31923
// end ; un := true ;
31701: LD_ADDR_VAR 0 6
31705: PUSH
31706: LD_INT 1
31708: ST_TO_ADDR
// if side = ar then
31709: LD_VAR 0 1
31713: PUSH
31714: LD_EXP 4
31718: EQUAL
31719: IFFALSE 31749
// mechanics := UnitFilter ( mechanics , [ f_not , [ f_driving ] ] ) ;
31721: LD_ADDR_VAR 0 2
31725: PUSH
31726: LD_VAR 0 2
31730: PPUSH
31731: LD_INT 3
31733: PUSH
31734: LD_INT 55
31736: PUSH
31737: EMPTY
31738: LIST
31739: PUSH
31740: EMPTY
31741: LIST
31742: LIST
31743: PPUSH
31744: CALL_OW 72
31748: ST_TO_ADDR
// DoEnterUnit ( mechanics , factory ) ;
31749: LD_VAR 0 2
31753: PPUSH
31754: LD_VAR 0 3
31758: PPUSH
31759: CALL 31928 0 2
// if components [ 3 ] = control_apeman then
31763: LD_VAR 0 4
31767: PUSH
31768: LD_INT 3
31770: ARRAY
31771: PUSH
31772: LD_INT 5
31774: EQUAL
31775: IFFALSE 31913
// begin un := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class_apeman ] , [ f_not , [ f_hastask ] ] ] ) ;
31777: LD_ADDR_VAR 0 6
31781: PUSH
31782: LD_INT 22
31784: PUSH
31785: LD_VAR 0 1
31789: PUSH
31790: EMPTY
31791: LIST
31792: LIST
31793: PUSH
31794: LD_INT 25
31796: PUSH
31797: LD_INT 12
31799: PUSH
31800: EMPTY
31801: LIST
31802: LIST
31803: PUSH
31804: LD_INT 3
31806: PUSH
31807: LD_INT 60
31809: PUSH
31810: EMPTY
31811: LIST
31812: PUSH
31813: EMPTY
31814: LIST
31815: LIST
31816: PUSH
31817: EMPTY
31818: LIST
31819: LIST
31820: LIST
31821: PPUSH
31822: CALL_OW 69
31826: ST_TO_ADDR
// if un then
31827: LD_VAR 0 6
31831: IFFALSE 31853
// DoEnterUnit ( un [ 1 ] , factory ) else
31833: LD_VAR 0 6
31837: PUSH
31838: LD_INT 1
31840: ARRAY
31841: PPUSH
31842: LD_VAR 0 3
31846: PPUSH
31847: CALL 31928 0 2
31851: GO 31913
// begin un := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class_apeman ] ] ) ;
31853: LD_ADDR_VAR 0 6
31857: PUSH
31858: LD_INT 22
31860: PUSH
31861: LD_VAR 0 1
31865: PUSH
31866: EMPTY
31867: LIST
31868: LIST
31869: PUSH
31870: LD_INT 25
31872: PUSH
31873: LD_INT 12
31875: PUSH
31876: EMPTY
31877: LIST
31878: LIST
31879: PUSH
31880: EMPTY
31881: LIST
31882: LIST
31883: PPUSH
31884: CALL_OW 69
31888: ST_TO_ADDR
// if un then
31889: LD_VAR 0 6
31893: IFFALSE 31913
// DoEnterUnit ( un [ 1 ] , factory ) ;
31895: LD_VAR 0 6
31899: PUSH
31900: LD_INT 1
31902: ARRAY
31903: PPUSH
31904: LD_VAR 0 3
31908: PPUSH
31909: CALL 31928 0 2
// end ; end ; result := un ;
31913: LD_ADDR_VAR 0 5
31917: PUSH
31918: LD_VAR 0 6
31922: ST_TO_ADDR
// end ;
31923: LD_VAR 0 5
31927: RET
// function DoEnterUnit ( moving_un_list , into_un ) ; var inside_un , t , moving_un ; begin
31928: LD_INT 0
31930: PPUSH
31931: PPUSH
31932: PPUSH
31933: PPUSH
// for moving_un in moving_un_list do
31934: LD_ADDR_VAR 0 6
31938: PUSH
31939: LD_VAR 0 1
31943: PUSH
31944: FOR_IN
31945: IFFALSE 32082
// begin inside_un = IsInUnit ( moving_un ) ;
31947: LD_ADDR_VAR 0 4
31951: PUSH
31952: LD_VAR 0 6
31956: PPUSH
31957: CALL_OW 310
31961: ST_TO_ADDR
// if inside_un <> into_un then
31962: LD_VAR 0 4
31966: PUSH
31967: LD_VAR 0 2
31971: NONEQUAL
31972: IFFALSE 32080
// begin if inside_un > 0 then
31974: LD_VAR 0 4
31978: PUSH
31979: LD_INT 0
31981: GREATER
31982: IFFALSE 32001
// t = GetType ( inside_un ) else
31984: LD_ADDR_VAR 0 5
31988: PUSH
31989: LD_VAR 0 4
31993: PPUSH
31994: CALL_OW 247
31998: ST_TO_ADDR
31999: GO 32009
// t = 0 ;
32001: LD_ADDR_VAR 0 5
32005: PUSH
32006: LD_INT 0
32008: ST_TO_ADDR
// case t of unit_vehicle :
32009: LD_VAR 0 5
32013: PUSH
32014: LD_INT 2
32016: DOUBLE
32017: EQUAL
32018: IFTRUE 32022
32020: GO 32034
32022: POP
// ComExitVehicle ( moving_un ) ; unit_building :
32023: LD_VAR 0 6
32027: PPUSH
32028: CALL_OW 121
32032: GO 32080
32034: LD_INT 3
32036: DOUBLE
32037: EQUAL
32038: IFTRUE 32042
32040: GO 32054
32042: POP
// ComExitBuilding ( moving_un ) ; 0 :
32043: LD_VAR 0 6
32047: PPUSH
32048: CALL_OW 122
32052: GO 32080
32054: LD_INT 0
32056: DOUBLE
32057: EQUAL
32058: IFTRUE 32062
32060: GO 32079
32062: POP
// ComEnterUnit ( moving_un , into_un ) ; end ;
32063: LD_VAR 0 6
32067: PPUSH
32068: LD_VAR 0 2
32072: PPUSH
32073: CALL_OW 120
32077: GO 32080
32079: POP
// end ; end ;
32080: GO 31944
32082: POP
32083: POP
// end ;
32084: LD_VAR 0 3
32088: RET
// function start_building_vehicle ( nation , factory , vehicle ) ; begin
32089: LD_INT 0
32091: PPUSH
// if ( not UnitsInside ( factory ) ) and ( nation <> ar ) then
32092: LD_VAR 0 2
32096: PPUSH
32097: CALL_OW 313
32101: NOT
32102: PUSH
32103: LD_VAR 0 1
32107: PUSH
32108: LD_EXP 4
32112: NONEQUAL
32113: AND
32114: IFFALSE 32126
// begin result = false ;
32116: LD_ADDR_VAR 0 4
32120: PUSH
32121: LD_INT 0
32123: ST_TO_ADDR
// exit ;
32124: GO 32232
// end ; if vehicle [ 3 ] = control_apeman and not ApemanInFactory ( factory ) then
32126: LD_VAR 0 3
32130: PUSH
32131: LD_INT 3
32133: ARRAY
32134: PUSH
32135: LD_INT 5
32137: EQUAL
32138: PUSH
32139: LD_VAR 0 2
32143: PPUSH
32144: CALL 32237 0 1
32148: NOT
32149: AND
32150: IFFALSE 32162
// begin result = false ;
32152: LD_ADDR_VAR 0 4
32156: PUSH
32157: LD_INT 0
32159: ST_TO_ADDR
// exit ;
32160: GO 32232
// end ; ComChangeProfession ( UnitsInside ( factory ) , class_mechanic ) ;
32162: LD_VAR 0 2
32166: PPUSH
32167: CALL_OW 313
32171: PPUSH
32172: LD_INT 3
32174: PPUSH
32175: CALL_OW 123
// ComConstruct ( factory , vehicle [ 1 ] , vehicle [ 2 ] , vehicle [ 3 ] , vehicle [ 4 ] ) ;
32179: LD_VAR 0 2
32183: PPUSH
32184: LD_VAR 0 3
32188: PUSH
32189: LD_INT 1
32191: ARRAY
32192: PPUSH
32193: LD_VAR 0 3
32197: PUSH
32198: LD_INT 2
32200: ARRAY
32201: PPUSH
32202: LD_VAR 0 3
32206: PUSH
32207: LD_INT 3
32209: ARRAY
32210: PPUSH
32211: LD_VAR 0 3
32215: PUSH
32216: LD_INT 4
32218: ARRAY
32219: PPUSH
32220: CALL_OW 125
// result = true ;
32224: LD_ADDR_VAR 0 4
32228: PUSH
32229: LD_INT 1
32231: ST_TO_ADDR
// end ;
32232: LD_VAR 0 4
32236: RET
// function ApemanInFactory ( factory ) ; var un , list , vysledek ; begin
32237: LD_INT 0
32239: PPUSH
32240: PPUSH
32241: PPUSH
32242: PPUSH
// vysledek := false ;
32243: LD_ADDR_VAR 0 5
32247: PUSH
32248: LD_INT 0
32250: ST_TO_ADDR
// list := UnitsInside ( factory ) ;
32251: LD_ADDR_VAR 0 4
32255: PUSH
32256: LD_VAR 0 1
32260: PPUSH
32261: CALL_OW 313
32265: ST_TO_ADDR
// for un in list do
32266: LD_ADDR_VAR 0 3
32270: PUSH
32271: LD_VAR 0 4
32275: PUSH
32276: FOR_IN
32277: IFFALSE 32306
// if GetClass ( un ) = class_apeman then
32279: LD_VAR 0 3
32283: PPUSH
32284: CALL_OW 257
32288: PUSH
32289: LD_INT 12
32291: EQUAL
32292: IFFALSE 32304
// begin vysledek := true ;
32294: LD_ADDR_VAR 0 5
32298: PUSH
32299: LD_INT 1
32301: ST_TO_ADDR
// break ;
32302: GO 32306
// end ;
32304: GO 32276
32306: POP
32307: POP
// result := vysledek ;
32308: LD_ADDR_VAR 0 2
32312: PUSH
32313: LD_VAR 0 5
32317: ST_TO_ADDR
// end ;
32318: LD_VAR 0 2
32322: RET
// function cleanup_extensions ( side , nation , factory ) ; var un , list , crane , cargo_bay , nation_crane , nation_cargo ; begin
32323: LD_INT 0
32325: PPUSH
32326: PPUSH
32327: PPUSH
32328: PPUSH
32329: PPUSH
32330: PPUSH
32331: PPUSH
// case nation of 1 :
32332: LD_VAR 0 2
32336: PUSH
32337: LD_INT 1
32339: DOUBLE
32340: EQUAL
32341: IFTRUE 32345
32343: GO 32364
32345: POP
// begin nation_cargo := us_cargo_bay ;
32346: LD_ADDR_VAR 0 10
32350: PUSH
32351: LD_INT 12
32353: ST_TO_ADDR
// nation_crane := us_crane ;
32354: LD_ADDR_VAR 0 9
32358: PUSH
32359: LD_INT 13
32361: ST_TO_ADDR
// end ; 2 :
32362: GO 32419
32364: LD_INT 2
32366: DOUBLE
32367: EQUAL
32368: IFTRUE 32372
32370: GO 32391
32372: POP
// begin nation_cargo := ar_cargo_bay ;
32373: LD_ADDR_VAR 0 10
32377: PUSH
32378: LD_INT 32
32380: ST_TO_ADDR
// nation_crane := 0 ;
32381: LD_ADDR_VAR 0 9
32385: PUSH
32386: LD_INT 0
32388: ST_TO_ADDR
// end ; 3 :
32389: GO 32419
32391: LD_INT 3
32393: DOUBLE
32394: EQUAL
32395: IFTRUE 32399
32397: GO 32418
32399: POP
// begin nation_cargo := ru_cargo_bay ;
32400: LD_ADDR_VAR 0 10
32404: PUSH
32405: LD_INT 51
32407: ST_TO_ADDR
// nation_crane := ru_crane ;
32408: LD_ADDR_VAR 0 9
32412: PUSH
32413: LD_INT 52
32415: ST_TO_ADDR
// end ; end ;
32416: GO 32419
32418: POP
// cargo_bay := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_weapon , nation_cargo ] ] ) ;
32419: LD_ADDR_VAR 0 8
32423: PUSH
32424: LD_INT 22
32426: PUSH
32427: LD_VAR 0 1
32431: PUSH
32432: EMPTY
32433: LIST
32434: LIST
32435: PUSH
32436: LD_INT 21
32438: PUSH
32439: LD_INT 2
32441: PUSH
32442: EMPTY
32443: LIST
32444: LIST
32445: PUSH
32446: LD_INT 34
32448: PUSH
32449: LD_VAR 0 10
32453: PUSH
32454: EMPTY
32455: LIST
32456: LIST
32457: PUSH
32458: EMPTY
32459: LIST
32460: LIST
32461: LIST
32462: PPUSH
32463: CALL_OW 69
32467: ST_TO_ADDR
// crane := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_weapon , nation_crane ] ] ) ;
32468: LD_ADDR_VAR 0 7
32472: PUSH
32473: LD_INT 22
32475: PUSH
32476: LD_VAR 0 1
32480: PUSH
32481: EMPTY
32482: LIST
32483: LIST
32484: PUSH
32485: LD_INT 21
32487: PUSH
32488: LD_INT 2
32490: PUSH
32491: EMPTY
32492: LIST
32493: LIST
32494: PUSH
32495: LD_INT 34
32497: PUSH
32498: LD_VAR 0 9
32502: PUSH
32503: EMPTY
32504: LIST
32505: LIST
32506: PUSH
32507: EMPTY
32508: LIST
32509: LIST
32510: LIST
32511: PPUSH
32512: CALL_OW 69
32516: ST_TO_ADDR
// if ( nation_crane in extension_wanted ) and crane then
32517: LD_VAR 0 9
32521: PUSH
32522: LD_EXP 75
32526: IN
32527: PUSH
32528: LD_VAR 0 7
32532: AND
32533: IFFALSE 32551
// extension_wanted := extension_wanted diff nation_crane ;
32535: LD_ADDR_EXP 75
32539: PUSH
32540: LD_EXP 75
32544: PUSH
32545: LD_VAR 0 9
32549: DIFF
32550: ST_TO_ADDR
// if ( nation_cargo in extension_wanted ) and cargo_bay then
32551: LD_VAR 0 10
32555: PUSH
32556: LD_EXP 75
32560: IN
32561: PUSH
32562: LD_VAR 0 8
32566: AND
32567: IFFALSE 32585
// extension_wanted := extension_wanted diff nation_cargo ;
32569: LD_ADDR_EXP 75
32573: PUSH
32574: LD_EXP 75
32578: PUSH
32579: LD_VAR 0 10
32583: DIFF
32584: ST_TO_ADDR
// list := extension_wanted ;
32585: LD_ADDR_VAR 0 6
32589: PUSH
32590: LD_EXP 75
32594: ST_TO_ADDR
// for un in list do
32595: LD_ADDR_VAR 0 5
32599: PUSH
32600: LD_VAR 0 6
32604: PUSH
32605: FOR_IN
32606: IFFALSE 32639
// begin if not un in main_extensions then
32608: LD_VAR 0 5
32612: PUSH
32613: LD_LOC 58
32617: IN
32618: NOT
32619: IFFALSE 32637
// extension_wanted := extension_wanted diff un ;
32621: LD_ADDR_EXP 75
32625: PUSH
32626: LD_EXP 75
32630: PUSH
32631: LD_VAR 0 5
32635: DIFF
32636: ST_TO_ADDR
// end ;
32637: GO 32605
32639: POP
32640: POP
// end ; end_of_file
32641: LD_VAR 0 4
32645: RET
// var mc_list ; var b_list ; export function init_keep_base ; var un , build , side ; begin
32646: LD_INT 0
32648: PPUSH
32649: PPUSH
32650: PPUSH
32651: PPUSH
// b_list := [ ] ;
32652: LD_ADDR_LOC 62
32656: PUSH
32657: EMPTY
32658: ST_TO_ADDR
// mc_list := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
32659: LD_ADDR_LOC 61
32663: PUSH
32664: LD_INT 0
32666: PUSH
32667: LD_INT 0
32669: PUSH
32670: LD_INT 0
32672: PUSH
32673: LD_INT 0
32675: PUSH
32676: LD_INT 0
32678: PUSH
32679: LD_INT 0
32681: PUSH
32682: LD_INT 0
32684: PUSH
32685: LD_INT 0
32687: PUSH
32688: EMPTY
32689: LIST
32690: LIST
32691: LIST
32692: LIST
32693: LIST
32694: LIST
32695: LIST
32696: LIST
32697: ST_TO_ADDR
// for side = 1 to 8 do
32698: LD_ADDR_VAR 0 4
32702: PUSH
32703: DOUBLE
32704: LD_INT 1
32706: DEC
32707: ST_TO_ADDR
32708: LD_INT 8
32710: PUSH
32711: FOR_TO
32712: IFFALSE 32827
// if side in cpu_list then
32714: LD_VAR 0 4
32718: PUSH
32719: LD_EXP 8
32723: IN
32724: IFFALSE 32809
// begin un := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
32726: LD_ADDR_VAR 0 2
32730: PUSH
32731: LD_INT 22
32733: PUSH
32734: LD_VAR 0 4
32738: PUSH
32739: EMPTY
32740: LIST
32741: LIST
32742: PUSH
32743: LD_INT 21
32745: PUSH
32746: LD_INT 3
32748: PUSH
32749: EMPTY
32750: LIST
32751: LIST
32752: PUSH
32753: EMPTY
32754: LIST
32755: LIST
32756: PPUSH
32757: CALL_OW 69
32761: ST_TO_ADDR
// if un then
32762: LD_VAR 0 2
32766: IFFALSE 32807
// b_list := Insert ( b_list , side , GetBuildList ( GetBase ( un [ 1 ] ) ) ) ;
32768: LD_ADDR_LOC 62
32772: PUSH
32773: LD_LOC 62
32777: PPUSH
32778: LD_VAR 0 4
32782: PPUSH
32783: LD_VAR 0 2
32787: PUSH
32788: LD_INT 1
32790: ARRAY
32791: PPUSH
32792: CALL_OW 274
32796: PPUSH
32797: CALL_OW 417
32801: PPUSH
32802: CALL_OW 2
32806: ST_TO_ADDR
// end else
32807: GO 32825
// b_list := b_list ^ [ [ ] ] ;
32809: LD_ADDR_LOC 62
32813: PUSH
32814: LD_LOC 62
32818: PUSH
32819: EMPTY
32820: PUSH
32821: EMPTY
32822: LIST
32823: ADD
32824: ST_TO_ADDR
32825: GO 32711
32827: POP
32828: POP
// end ;
32829: LD_VAR 0 1
32833: RET
// every 0 0$5.2 trigger us in cpu_list do var side , list , engineers ;
32834: LD_EXP 3
32838: PUSH
32839: LD_EXP 8
32843: IN
32844: IFFALSE 33049
32846: GO 32848
32848: DISABLE
32849: LD_INT 0
32851: PPUSH
32852: PPUSH
32853: PPUSH
// begin list := [ ] ;
32854: LD_ADDR_VAR 0 2
32858: PUSH
32859: EMPTY
32860: ST_TO_ADDR
// for side = 1 to 8 do
32861: LD_ADDR_VAR 0 1
32865: PUSH
32866: DOUBLE
32867: LD_INT 1
32869: DEC
32870: ST_TO_ADDR
32871: LD_INT 8
32873: PUSH
32874: FOR_TO
32875: IFFALSE 33036
// if ( side in cpu_list ) then
32877: LD_VAR 0 1
32881: PUSH
32882: LD_EXP 8
32886: IN
32887: IFFALSE 33020
// begin if not ExistMc ( mc_list [ side ] ) then
32889: LD_LOC 61
32893: PUSH
32894: LD_VAR 0 1
32898: ARRAY
32899: PPUSH
32900: CALL_OW 386
32904: NOT
32905: IFFALSE 32996
// begin engineers := request_people ( side , class_engineer , 5 ) ;
32907: LD_ADDR_VAR 0 3
32911: PUSH
32912: LD_VAR 0 1
32916: PPUSH
32917: LD_INT 2
32919: PPUSH
32920: LD_INT 5
32922: PPUSH
32923: CALL 26825 0 3
32927: ST_TO_ADDR
// if engineers then
32928: LD_VAR 0 3
32932: IFFALSE 32980
// list := list ^ McBase ( 3 , engineers , b_list [ side ] , 0 , 0 , 0 ) else
32934: LD_ADDR_VAR 0 2
32938: PUSH
32939: LD_VAR 0 2
32943: PUSH
32944: LD_INT 3
32946: PPUSH
32947: LD_VAR 0 3
32951: PPUSH
32952: LD_LOC 62
32956: PUSH
32957: LD_VAR 0 1
32961: ARRAY
32962: PPUSH
32963: LD_INT 0
32965: PPUSH
32966: LD_INT 0
32968: PPUSH
32969: LD_INT 0
32971: PPUSH
32972: CALL_OW 397
32976: ADD
32977: ST_TO_ADDR
32978: GO 32994
// list := list ^ 0 end else
32980: LD_ADDR_VAR 0 2
32984: PUSH
32985: LD_VAR 0 2
32989: PUSH
32990: LD_INT 0
32992: ADD
32993: ST_TO_ADDR
32994: GO 33018
// list := list ^ mc_list [ side ] ;
32996: LD_ADDR_VAR 0 2
33000: PUSH
33001: LD_VAR 0 2
33005: PUSH
33006: LD_LOC 61
33010: PUSH
33011: LD_VAR 0 1
33015: ARRAY
33016: ADD
33017: ST_TO_ADDR
// end else
33018: GO 33034
// list := list ^ 0 ;
33020: LD_ADDR_VAR 0 2
33024: PUSH
33025: LD_VAR 0 2
33029: PUSH
33030: LD_INT 0
33032: ADD
33033: ST_TO_ADDR
33034: GO 32874
33036: POP
33037: POP
// mc_list := list ;
33038: LD_ADDR_LOC 61
33042: PUSH
33043: LD_VAR 0 2
33047: ST_TO_ADDR
// enable ;
33048: ENABLE
// end ; end_of_file
33049: PPOPN 3
33051: END
// var load_global , load_local_cpu , load_local_you ; var global_delay , cpu_delay , you_delay ; var crates_loading_area ; export function init_crates_loading ; begin
33052: LD_INT 0
33054: PPUSH
// global_delay := 10 10$0 ;
33055: LD_ADDR_LOC 66
33059: PUSH
33060: LD_INT 21000
33062: ST_TO_ADDR
// cpu_delay := 0 0$90 ;
33063: LD_ADDR_LOC 67
33067: PUSH
33068: LD_INT 3150
33070: ST_TO_ADDR
// you_delay := 3 3$30 ;
33071: LD_ADDR_LOC 68
33075: PUSH
33076: LD_INT 7350
33078: ST_TO_ADDR
// load_global := TICK + Rand ( global_delay - 0 0$40 , global_delay + 0 0$60 ) ;
33079: LD_ADDR_LOC 63
33083: PUSH
33084: LD_OWVAR 1
33088: PUSH
33089: LD_LOC 66
33093: PUSH
33094: LD_INT 1400
33096: MINUS
33097: PPUSH
33098: LD_LOC 66
33102: PUSH
33103: LD_INT 2100
33105: PLUS
33106: PPUSH
33107: CALL_OW 12
33111: PLUS
33112: ST_TO_ADDR
// load_local_cpu := TICK + Rand ( cpu_delay - 0 0$20 , cpu_delay + 0 0$20 ) ;
33113: LD_ADDR_LOC 64
33117: PUSH
33118: LD_OWVAR 1
33122: PUSH
33123: LD_LOC 67
33127: PUSH
33128: LD_INT 700
33130: MINUS
33131: PPUSH
33132: LD_LOC 67
33136: PUSH
33137: LD_INT 700
33139: PLUS
33140: PPUSH
33141: CALL_OW 12
33145: PLUS
33146: ST_TO_ADDR
// load_local_you := TICK + Rand ( you_delay - 0 0$20 , you_delay + 0 0$20 ) ;
33147: LD_ADDR_LOC 65
33151: PUSH
33152: LD_OWVAR 1
33156: PUSH
33157: LD_LOC 68
33161: PUSH
33162: LD_INT 700
33164: MINUS
33165: PPUSH
33166: LD_LOC 68
33170: PUSH
33171: LD_INT 700
33173: PLUS
33174: PPUSH
33175: CALL_OW 12
33179: PLUS
33180: ST_TO_ADDR
// crates_loading_area := [ us_crates , ar_crates , ru_crates ] ;
33181: LD_ADDR_LOC 69
33185: PUSH
33186: LD_INT 1
33188: PUSH
33189: LD_INT 3
33191: PUSH
33192: LD_INT 2
33194: PUSH
33195: EMPTY
33196: LIST
33197: LIST
33198: LIST
33199: ST_TO_ADDR
// end ;
33200: LD_VAR 0 1
33204: RET
// every 0 0$5.1 trigger TICK > load_global do var c , sur , i ;
33205: LD_OWVAR 1
33209: PUSH
33210: LD_LOC 63
33214: GREATER
33215: IFFALSE 33388
33217: GO 33219
33219: DISABLE
33220: LD_INT 0
33222: PPUSH
33223: PPUSH
33224: PPUSH
// begin c := RandHex ( false ) ;
33225: LD_ADDR_VAR 0 1
33229: PUSH
33230: LD_INT 0
33232: PPUSH
33233: CALL_OW 15
33237: ST_TO_ADDR
// sur := [ ] ;
33238: LD_ADDR_VAR 0 2
33242: PUSH
33243: EMPTY
33244: ST_TO_ADDR
// for i = 1 to 4 do
33245: LD_ADDR_VAR 0 3
33249: PUSH
33250: DOUBLE
33251: LD_INT 1
33253: DEC
33254: ST_TO_ADDR
33255: LD_INT 4
33257: PUSH
33258: FOR_TO
33259: IFFALSE 33306
// sur := sur ^ [ RandHexXYR ( c [ 1 ] , c [ 2 ] , 1 , false ) ] ;
33261: LD_ADDR_VAR 0 2
33265: PUSH
33266: LD_VAR 0 2
33270: PUSH
33271: LD_VAR 0 1
33275: PUSH
33276: LD_INT 1
33278: ARRAY
33279: PPUSH
33280: LD_VAR 0 1
33284: PUSH
33285: LD_INT 2
33287: ARRAY
33288: PPUSH
33289: LD_INT 1
33291: PPUSH
33292: LD_INT 0
33294: PPUSH
33295: CALL_OW 17
33299: PUSH
33300: EMPTY
33301: LIST
33302: ADD
33303: ST_TO_ADDR
33304: GO 33258
33306: POP
33307: POP
// for i in sur do
33308: LD_ADDR_VAR 0 3
33312: PUSH
33313: LD_VAR 0 2
33317: PUSH
33318: FOR_IN
33319: IFFALSE 33351
// CreateCratesXY ( 5 , i [ 1 ] , i [ 2 ] , true ) ;
33321: LD_INT 5
33323: PPUSH
33324: LD_VAR 0 3
33328: PUSH
33329: LD_INT 1
33331: ARRAY
33332: PPUSH
33333: LD_VAR 0 3
33337: PUSH
33338: LD_INT 2
33340: ARRAY
33341: PPUSH
33342: LD_INT 1
33344: PPUSH
33345: CALL_OW 54
33349: GO 33318
33351: POP
33352: POP
// load_global := TICK + Rand ( global_delay - 0 0$40 , global_delay + 0 0$60 ) ;
33353: LD_ADDR_LOC 63
33357: PUSH
33358: LD_OWVAR 1
33362: PUSH
33363: LD_LOC 66
33367: PUSH
33368: LD_INT 1400
33370: MINUS
33371: PPUSH
33372: LD_LOC 66
33376: PUSH
33377: LD_INT 2100
33379: PLUS
33380: PPUSH
33381: CALL_OW 12
33385: PLUS
33386: ST_TO_ADDR
// enable ;
33387: ENABLE
// end ;
33388: PPOPN 3
33390: END
// every 0 0$5.4 trigger TICK > load_local_cpu do var un ;
33391: LD_OWVAR 1
33395: PUSH
33396: LD_LOC 64
33400: GREATER
33401: IFFALSE 33518
33403: GO 33405
33405: DISABLE
33406: LD_INT 0
33408: PPUSH
// begin if GetResourceArea ( us_crates , mat_cans ) < 250 then
33409: LD_INT 1
33411: PPUSH
33412: LD_INT 1
33414: PPUSH
33415: CALL_OW 287
33419: PUSH
33420: LD_INT 250
33422: LESS
33423: IFFALSE 33446
// CreateCratesArea ( Rand ( 3 , 5 ) , us_crates , true ) ;
33425: LD_INT 3
33427: PPUSH
33428: LD_INT 5
33430: PPUSH
33431: CALL_OW 12
33435: PPUSH
33436: LD_INT 1
33438: PPUSH
33439: LD_INT 1
33441: PPUSH
33442: CALL_OW 55
// if GetResourceArea ( ru_crates , mat_cans ) < 250 then
33446: LD_INT 2
33448: PPUSH
33449: LD_INT 1
33451: PPUSH
33452: CALL_OW 287
33456: PUSH
33457: LD_INT 250
33459: LESS
33460: IFFALSE 33483
// CreateCratesArea ( Rand ( 3 , 5 ) , ru_crates , true ) ;
33462: LD_INT 3
33464: PPUSH
33465: LD_INT 5
33467: PPUSH
33468: CALL_OW 12
33472: PPUSH
33473: LD_INT 2
33475: PPUSH
33476: LD_INT 1
33478: PPUSH
33479: CALL_OW 55
// load_local_cpu := TICK + Rand ( cpu_delay - 0 0$20 , cpu_delay + 0 0$20 ) ;
33483: LD_ADDR_LOC 64
33487: PUSH
33488: LD_OWVAR 1
33492: PUSH
33493: LD_LOC 67
33497: PUSH
33498: LD_INT 700
33500: MINUS
33501: PPUSH
33502: LD_LOC 67
33506: PUSH
33507: LD_INT 700
33509: PLUS
33510: PPUSH
33511: CALL_OW 12
33515: PLUS
33516: ST_TO_ADDR
// enable ;
33517: ENABLE
// end ;
33518: PPOPN 1
33520: END
// every 0 0$5.3 trigger TICK > load_local_you do
33521: LD_OWVAR 1
33525: PUSH
33526: LD_LOC 65
33530: GREATER
33531: IFFALSE 33608
33533: GO 33535
33535: DISABLE
// begin if GetResourceArea ( ar_crates , mat_cans ) < 250 then
33536: LD_INT 3
33538: PPUSH
33539: LD_INT 1
33541: PPUSH
33542: CALL_OW 287
33546: PUSH
33547: LD_INT 250
33549: LESS
33550: IFFALSE 33573
// CreateCratesArea ( Rand ( 1 , 5 ) , ar_crates , true ) ;
33552: LD_INT 1
33554: PPUSH
33555: LD_INT 5
33557: PPUSH
33558: CALL_OW 12
33562: PPUSH
33563: LD_INT 3
33565: PPUSH
33566: LD_INT 1
33568: PPUSH
33569: CALL_OW 55
// load_local_you := TICK + Rand ( you_delay - 0 0$20 , you_delay + 0 0$20 ) ;
33573: LD_ADDR_LOC 65
33577: PUSH
33578: LD_OWVAR 1
33582: PUSH
33583: LD_LOC 68
33587: PUSH
33588: LD_INT 700
33590: MINUS
33591: PPUSH
33592: LD_LOC 68
33596: PUSH
33597: LD_INT 700
33599: PLUS
33600: PPUSH
33601: CALL_OW 12
33605: PLUS
33606: ST_TO_ADDR
// enable ;
33607: ENABLE
// end ;
33608: END
// every 0 0$30.1 do var list , side , un , base ;
33609: GO 33611
33611: DISABLE
33612: LD_INT 0
33614: PPUSH
33615: PPUSH
33616: PPUSH
33617: PPUSH
// begin for side in cpu_list do
33618: LD_ADDR_VAR 0 2
33622: PUSH
33623: LD_EXP 8
33627: PUSH
33628: FOR_IN
33629: IFFALSE 33783
// begin list := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
33631: LD_ADDR_VAR 0 1
33635: PUSH
33636: LD_INT 22
33638: PUSH
33639: LD_VAR 0 2
33643: PUSH
33644: EMPTY
33645: LIST
33646: LIST
33647: PUSH
33648: LD_INT 21
33650: PUSH
33651: LD_INT 3
33653: PUSH
33654: EMPTY
33655: LIST
33656: LIST
33657: PUSH
33658: LD_INT 2
33660: PUSH
33661: LD_INT 30
33663: PUSH
33664: LD_INT 0
33666: PUSH
33667: EMPTY
33668: LIST
33669: LIST
33670: PUSH
33671: LD_INT 30
33673: PUSH
33674: LD_INT 1
33676: PUSH
33677: EMPTY
33678: LIST
33679: LIST
33680: PUSH
33681: EMPTY
33682: LIST
33683: LIST
33684: LIST
33685: PUSH
33686: EMPTY
33687: LIST
33688: LIST
33689: LIST
33690: PPUSH
33691: CALL_OW 69
33695: ST_TO_ADDR
// for un in list do
33696: LD_ADDR_VAR 0 3
33700: PUSH
33701: LD_VAR 0 1
33705: PUSH
33706: FOR_IN
33707: IFFALSE 33779
// begin base := GetBase ( un ) ;
33709: LD_ADDR_VAR 0 4
33713: PUSH
33714: LD_VAR 0 3
33718: PPUSH
33719: CALL_OW 274
33723: ST_TO_ADDR
// if GetResourceType ( base , mat_cans ) < 300 then
33724: LD_VAR 0 4
33728: PPUSH
33729: LD_INT 1
33731: PPUSH
33732: CALL_OW 275
33736: PUSH
33737: LD_INT 300
33739: LESS
33740: IFFALSE 33777
// SetResourceType ( base , mat_cans , GetResourceType ( base , mat_cans ) + ( difficulty * 30 ) ) ;
33742: LD_VAR 0 4
33746: PPUSH
33747: LD_INT 1
33749: PPUSH
33750: LD_VAR 0 4
33754: PPUSH
33755: LD_INT 1
33757: PPUSH
33758: CALL_OW 275
33762: PUSH
33763: LD_OWVAR 67
33767: PUSH
33768: LD_INT 30
33770: MUL
33771: PLUS
33772: PPUSH
33773: CALL_OW 277
// end ;
33777: GO 33706
33779: POP
33780: POP
// end ;
33781: GO 33628
33783: POP
33784: POP
// enable ;
33785: ENABLE
// end ; end_of_file
33786: PPOPN 4
33788: END
// var outside_list , inside_list ; var base_areas , create_areas ; var us_bay , ru_bay , ar_bay ; var us_bad , ru_bad , ar_bad ; export function init_crates_collecting ; begin
33789: LD_INT 0
33791: PPUSH
// outside_list := [ us_crates , ar_crates , ru_crates ] ;
33792: LD_ADDR_LOC 70
33796: PUSH
33797: LD_INT 1
33799: PUSH
33800: LD_INT 3
33802: PUSH
33803: LD_INT 2
33805: PUSH
33806: EMPTY
33807: LIST
33808: LIST
33809: LIST
33810: ST_TO_ADDR
// inside_list := [ us_inner_base , ar_base , ru_inner_base ] ;
33811: LD_ADDR_LOC 71
33815: PUSH
33816: LD_INT 38
33818: PUSH
33819: LD_INT 13
33821: PUSH
33822: LD_INT 39
33824: PUSH
33825: EMPTY
33826: LIST
33827: LIST
33828: LIST
33829: ST_TO_ADDR
// base_areas := [ us_base , ar_base , ru_base ] ;
33830: LD_ADDR_LOC 72
33834: PUSH
33835: LD_INT 11
33837: PUSH
33838: LD_INT 13
33840: PUSH
33841: LD_INT 12
33843: PUSH
33844: EMPTY
33845: LIST
33846: LIST
33847: LIST
33848: ST_TO_ADDR
// create_areas := [ us_create , ar_create , ru_create ] ;
33849: LD_ADDR_LOC 73
33853: PUSH
33854: LD_INT 18
33856: PUSH
33857: LD_INT 19
33859: PUSH
33860: LD_INT 17
33862: PUSH
33863: EMPTY
33864: LIST
33865: LIST
33866: LIST
33867: ST_TO_ADDR
// us_bad := [ ] ;
33868: LD_ADDR_LOC 77
33872: PUSH
33873: EMPTY
33874: ST_TO_ADDR
// ru_bad := [ ] ;
33875: LD_ADDR_LOC 78
33879: PUSH
33880: EMPTY
33881: ST_TO_ADDR
// ar_bad := [ ] ;
33882: LD_ADDR_LOC 79
33886: PUSH
33887: EMPTY
33888: ST_TO_ADDR
// end ;
33889: LD_VAR 0 1
33893: RET
// every 0 0$5.4 do var un , side , list , cargo , n_cargo , engineers ;
33894: GO 33896
33896: DISABLE
33897: LD_INT 0
33899: PPUSH
33900: PPUSH
33901: PPUSH
33902: PPUSH
33903: PPUSH
33904: PPUSH
// begin for side in cpu_list do
33905: LD_ADDR_VAR 0 2
33909: PUSH
33910: LD_EXP 8
33914: PUSH
33915: FOR_IN
33916: IFFALSE 34443
// begin list := GetListOfCratesInArea ( outside_list [ side ] ) ;
33918: LD_ADDR_VAR 0 3
33922: PUSH
33923: LD_LOC 70
33927: PUSH
33928: LD_VAR 0 2
33932: ARRAY
33933: PPUSH
33934: CALL_OW 435
33938: ST_TO_ADDR
// if list then
33939: LD_VAR 0 3
33943: IFFALSE 34311
// begin case side of 1 :
33945: LD_VAR 0 2
33949: PUSH
33950: LD_INT 1
33952: DOUBLE
33953: EQUAL
33954: IFTRUE 33958
33956: GO 33969
33958: POP
// n_cargo := us_cargo_bay ; 2 :
33959: LD_ADDR_VAR 0 5
33963: PUSH
33964: LD_INT 12
33966: ST_TO_ADDR
33967: GO 34008
33969: LD_INT 2
33971: DOUBLE
33972: EQUAL
33973: IFTRUE 33977
33975: GO 33988
33977: POP
// n_cargo := ar_cargo_bay ; 3 :
33978: LD_ADDR_VAR 0 5
33982: PUSH
33983: LD_INT 32
33985: ST_TO_ADDR
33986: GO 34008
33988: LD_INT 3
33990: DOUBLE
33991: EQUAL
33992: IFTRUE 33996
33994: GO 34007
33996: POP
// n_cargo := ru_cargo_bay ; end ;
33997: LD_ADDR_VAR 0 5
34001: PUSH
34002: LD_INT 51
34004: ST_TO_ADDR
34005: GO 34008
34007: POP
// cargo := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_weapon , n_cargo ] ] ) ;
34008: LD_ADDR_VAR 0 4
34012: PUSH
34013: LD_INT 22
34015: PUSH
34016: LD_VAR 0 2
34020: PUSH
34021: EMPTY
34022: LIST
34023: LIST
34024: PUSH
34025: LD_INT 21
34027: PUSH
34028: LD_INT 2
34030: PUSH
34031: EMPTY
34032: LIST
34033: LIST
34034: PUSH
34035: LD_INT 34
34037: PUSH
34038: LD_VAR 0 5
34042: PUSH
34043: EMPTY
34044: LIST
34045: LIST
34046: PUSH
34047: EMPTY
34048: LIST
34049: LIST
34050: LIST
34051: PPUSH
34052: CALL_OW 69
34056: ST_TO_ADDR
// if cargo then
34057: LD_VAR 0 4
34061: IFFALSE 34311
// begin cargo := cargo [ 1 ] ;
34063: LD_ADDR_VAR 0 4
34067: PUSH
34068: LD_VAR 0 4
34072: PUSH
34073: LD_INT 1
34075: ARRAY
34076: ST_TO_ADDR
// if ( not HasTask ( cargo ) ) and ( not ( [ list [ 1 ] , list [ 2 ] ] in ( us_bad ^ ru_bad ^ ar_bad ) ) ) then
34077: LD_VAR 0 4
34081: PPUSH
34082: CALL_OW 314
34086: NOT
34087: PUSH
34088: LD_VAR 0 3
34092: PUSH
34093: LD_INT 1
34095: ARRAY
34096: PUSH
34097: LD_VAR 0 3
34101: PUSH
34102: LD_INT 2
34104: ARRAY
34105: PUSH
34106: EMPTY
34107: LIST
34108: LIST
34109: PUSH
34110: LD_LOC 77
34114: PUSH
34115: LD_LOC 78
34119: ADD
34120: PUSH
34121: LD_LOC 79
34125: ADD
34126: IN
34127: NOT
34128: AND
34129: IFFALSE 34311
// begin ComCollect ( cargo , list [ 1 ] , list [ 2 ] ) ;
34131: LD_VAR 0 4
34135: PPUSH
34136: LD_VAR 0 3
34140: PUSH
34141: LD_INT 1
34143: ARRAY
34144: PPUSH
34145: LD_VAR 0 3
34149: PUSH
34150: LD_INT 2
34152: ARRAY
34153: PPUSH
34154: CALL_OW 117
// case side of us :
34158: LD_VAR 0 2
34162: PUSH
34163: LD_EXP 3
34167: DOUBLE
34168: EQUAL
34169: IFTRUE 34173
34171: GO 34212
34173: POP
// us_bay := us_bay ^ [ [ list [ 1 ] , list [ 2 ] ] ] ; ru :
34174: LD_ADDR_LOC 74
34178: PUSH
34179: LD_LOC 74
34183: PUSH
34184: LD_VAR 0 3
34188: PUSH
34189: LD_INT 1
34191: ARRAY
34192: PUSH
34193: LD_VAR 0 3
34197: PUSH
34198: LD_INT 2
34200: ARRAY
34201: PUSH
34202: EMPTY
34203: LIST
34204: LIST
34205: PUSH
34206: EMPTY
34207: LIST
34208: ADD
34209: ST_TO_ADDR
34210: GO 34311
34212: LD_EXP 2
34216: DOUBLE
34217: EQUAL
34218: IFTRUE 34222
34220: GO 34261
34222: POP
// ru_bay := ru_bay ^ [ [ list [ 1 ] , list [ 2 ] ] ] ; ar :
34223: LD_ADDR_LOC 75
34227: PUSH
34228: LD_LOC 75
34232: PUSH
34233: LD_VAR 0 3
34237: PUSH
34238: LD_INT 1
34240: ARRAY
34241: PUSH
34242: LD_VAR 0 3
34246: PUSH
34247: LD_INT 2
34249: ARRAY
34250: PUSH
34251: EMPTY
34252: LIST
34253: LIST
34254: PUSH
34255: EMPTY
34256: LIST
34257: ADD
34258: ST_TO_ADDR
34259: GO 34311
34261: LD_EXP 4
34265: DOUBLE
34266: EQUAL
34267: IFTRUE 34271
34269: GO 34310
34271: POP
// ar_bay := ar_bay ^ [ [ list [ 1 ] , list [ 2 ] ] ] ; end ;
34272: LD_ADDR_LOC 76
34276: PUSH
34277: LD_LOC 76
34281: PUSH
34282: LD_VAR 0 3
34286: PUSH
34287: LD_INT 1
34289: ARRAY
34290: PUSH
34291: LD_VAR 0 3
34295: PUSH
34296: LD_INT 2
34298: ARRAY
34299: PUSH
34300: EMPTY
34301: LIST
34302: LIST
34303: PUSH
34304: EMPTY
34305: LIST
34306: ADD
34307: ST_TO_ADDR
34308: GO 34311
34310: POP
// end ; end ; end ; list := GetListOfCratesInArea ( inside_list [ side ] ) ;
34311: LD_ADDR_VAR 0 3
34315: PUSH
34316: LD_LOC 71
34320: PUSH
34321: LD_VAR 0 2
34325: ARRAY
34326: PPUSH
34327: CALL_OW 435
34331: ST_TO_ADDR
// if list then
34332: LD_VAR 0 3
34336: IFFALSE 34441
// begin engineers := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_class , class_engineer ] ] ) ;
34338: LD_ADDR_VAR 0 6
34342: PUSH
34343: LD_INT 22
34345: PUSH
34346: LD_VAR 0 2
34350: PUSH
34351: EMPTY
34352: LIST
34353: LIST
34354: PUSH
34355: LD_INT 21
34357: PUSH
34358: LD_INT 1
34360: PUSH
34361: EMPTY
34362: LIST
34363: LIST
34364: PUSH
34365: LD_INT 25
34367: PUSH
34368: LD_INT 2
34370: PUSH
34371: EMPTY
34372: LIST
34373: LIST
34374: PUSH
34375: EMPTY
34376: LIST
34377: LIST
34378: LIST
34379: PPUSH
34380: CALL_OW 69
34384: ST_TO_ADDR
// for un in engineers do
34385: LD_ADDR_VAR 0 1
34389: PUSH
34390: LD_VAR 0 6
34394: PUSH
34395: FOR_IN
34396: IFFALSE 34439
// if not GetUnitMc ( un ) then
34398: LD_VAR 0 1
34402: PPUSH
34403: CALL_OW 388
34407: NOT
34408: IFFALSE 34437
// ComCollect ( un , list [ 1 ] , list [ 2 ] ) ;
34410: LD_VAR 0 1
34414: PPUSH
34415: LD_VAR 0 3
34419: PUSH
34420: LD_INT 1
34422: ARRAY
34423: PPUSH
34424: LD_VAR 0 3
34428: PUSH
34429: LD_INT 2
34431: ARRAY
34432: PPUSH
34433: CALL_OW 117
34437: GO 34395
34439: POP
34440: POP
// end ; end ;
34441: GO 33915
34443: POP
34444: POP
// enable ;
34445: ENABLE
// end ;
34446: PPOPN 6
34448: END
// every 1 1$0.6 do var un , n_cargo , cargo , side ;
34449: GO 34451
34451: DISABLE
34452: LD_INT 0
34454: PPUSH
34455: PPUSH
34456: PPUSH
34457: PPUSH
// begin for side in cpu_list do
34458: LD_ADDR_VAR 0 4
34462: PUSH
34463: LD_EXP 8
34467: PUSH
34468: FOR_IN
34469: IFFALSE 34908
// begin case side of 1 :
34471: LD_VAR 0 4
34475: PUSH
34476: LD_INT 1
34478: DOUBLE
34479: EQUAL
34480: IFTRUE 34484
34482: GO 34495
34484: POP
// n_cargo := us_cargo_bay ; 2 :
34485: LD_ADDR_VAR 0 2
34489: PUSH
34490: LD_INT 12
34492: ST_TO_ADDR
34493: GO 34534
34495: LD_INT 2
34497: DOUBLE
34498: EQUAL
34499: IFTRUE 34503
34501: GO 34514
34503: POP
// n_cargo := ar_cargo_bay ; 3 :
34504: LD_ADDR_VAR 0 2
34508: PUSH
34509: LD_INT 32
34511: ST_TO_ADDR
34512: GO 34534
34514: LD_INT 3
34516: DOUBLE
34517: EQUAL
34518: IFTRUE 34522
34520: GO 34533
34522: POP
// n_cargo := ru_cargo_bay ; end ;
34523: LD_ADDR_VAR 0 2
34527: PUSH
34528: LD_INT 51
34530: ST_TO_ADDR
34531: GO 34534
34533: POP
// cargo := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_weapon , n_cargo ] ] ) ;
34534: LD_ADDR_VAR 0 3
34538: PUSH
34539: LD_INT 22
34541: PUSH
34542: LD_VAR 0 4
34546: PUSH
34547: EMPTY
34548: LIST
34549: LIST
34550: PUSH
34551: LD_INT 21
34553: PUSH
34554: LD_INT 2
34556: PUSH
34557: EMPTY
34558: LIST
34559: LIST
34560: PUSH
34561: LD_INT 34
34563: PUSH
34564: LD_VAR 0 2
34568: PUSH
34569: EMPTY
34570: LIST
34571: LIST
34572: PUSH
34573: EMPTY
34574: LIST
34575: LIST
34576: LIST
34577: PPUSH
34578: CALL_OW 69
34582: ST_TO_ADDR
// if not ( cargo or FilterUnitsInArea ( base_areas [ side ] , [ [ f_side , you ] ] ) ) then
34583: LD_VAR 0 3
34587: PUSH
34588: LD_LOC 72
34592: PUSH
34593: LD_VAR 0 4
34597: ARRAY
34598: PPUSH
34599: LD_INT 22
34601: PUSH
34602: LD_EXP 1
34606: PUSH
34607: EMPTY
34608: LIST
34609: LIST
34610: PUSH
34611: EMPTY
34612: LIST
34613: PPUSH
34614: CALL_OW 70
34618: OR
34619: NOT
34620: IFFALSE 34906
// begin uc_side := side ;
34622: LD_ADDR_OWVAR 20
34626: PUSH
34627: LD_VAR 0 4
34631: ST_TO_ADDR
// case side of 1 :
34632: LD_VAR 0 4
34636: PUSH
34637: LD_INT 1
34639: DOUBLE
34640: EQUAL
34641: IFTRUE 34645
34643: GO 34656
34645: POP
// uc_nation := nation_american ; 2 :
34646: LD_ADDR_OWVAR 21
34650: PUSH
34651: LD_INT 1
34653: ST_TO_ADDR
34654: GO 34695
34656: LD_INT 2
34658: DOUBLE
34659: EQUAL
34660: IFTRUE 34664
34662: GO 34675
34664: POP
// uc_nation := nation_arabian ; 3 :
34665: LD_ADDR_OWVAR 21
34669: PUSH
34670: LD_INT 2
34672: ST_TO_ADDR
34673: GO 34695
34675: LD_INT 3
34677: DOUBLE
34678: EQUAL
34679: IFTRUE 34683
34681: GO 34694
34683: POP
// uc_nation := nation_russian ; end ;
34684: LD_ADDR_OWVAR 21
34688: PUSH
34689: LD_INT 3
34691: ST_TO_ADDR
34692: GO 34695
34694: POP
// uc_direction := Rand ( 0 , 5 ) ;
34695: LD_ADDR_OWVAR 24
34699: PUSH
34700: LD_INT 0
34702: PPUSH
34703: LD_INT 5
34705: PPUSH
34706: CALL_OW 12
34710: ST_TO_ADDR
// case side of 1 :
34711: LD_VAR 0 4
34715: PUSH
34716: LD_INT 1
34718: DOUBLE
34719: EQUAL
34720: IFTRUE 34724
34722: GO 34735
34724: POP
// vc_chassis := us_medium_tracked ; 2 :
34725: LD_ADDR_OWVAR 37
34729: PUSH
34730: LD_INT 3
34732: ST_TO_ADDR
34733: GO 34774
34735: LD_INT 2
34737: DOUBLE
34738: EQUAL
34739: IFTRUE 34743
34741: GO 34754
34743: POP
// vc_chassis := ar_half_tracked ; 3 :
34744: LD_ADDR_OWVAR 37
34748: PUSH
34749: LD_INT 14
34751: ST_TO_ADDR
34752: GO 34774
34754: LD_INT 3
34756: DOUBLE
34757: EQUAL
34758: IFTRUE 34762
34760: GO 34773
34762: POP
// vc_chassis := ru_medium_tracked ; end ;
34763: LD_ADDR_OWVAR 37
34767: PUSH
34768: LD_INT 22
34770: ST_TO_ADDR
34771: GO 34774
34773: POP
// vc_engine := engine_siberite ;
34774: LD_ADDR_OWVAR 39
34778: PUSH
34779: LD_INT 3
34781: ST_TO_ADDR
// case side of 1 :
34782: LD_VAR 0 4
34786: PUSH
34787: LD_INT 1
34789: DOUBLE
34790: EQUAL
34791: IFTRUE 34795
34793: GO 34806
34795: POP
// vc_control := control_computer ; 2 :
34796: LD_ADDR_OWVAR 38
34800: PUSH
34801: LD_INT 3
34803: ST_TO_ADDR
34804: GO 34845
34806: LD_INT 2
34808: DOUBLE
34809: EQUAL
34810: IFTRUE 34814
34812: GO 34825
34814: POP
// vc_control := control_apeman ; 3 :
34815: LD_ADDR_OWVAR 38
34819: PUSH
34820: LD_INT 5
34822: ST_TO_ADDR
34823: GO 34845
34825: LD_INT 3
34827: DOUBLE
34828: EQUAL
34829: IFTRUE 34833
34831: GO 34844
34833: POP
// vc_control := control_computer ; end ;
34834: LD_ADDR_OWVAR 38
34838: PUSH
34839: LD_INT 3
34841: ST_TO_ADDR
34842: GO 34845
34844: POP
// vc_weapon := n_cargo ;
34845: LD_ADDR_OWVAR 40
34849: PUSH
34850: LD_VAR 0 2
34854: ST_TO_ADDR
// un := CreateVehicle ;
34855: LD_ADDR_VAR 0 1
34859: PUSH
34860: CALL_OW 45
34864: ST_TO_ADDR
// while GetTag ( 83 ) do
34865: LD_INT 83
34867: PPUSH
34868: CALL_OW 110
34872: IFFALSE 34883
// wait ( 0 0$1 ) ;
34874: LD_INT 35
34876: PPUSH
34877: CALL_OW 67
34881: GO 34865
// PlaceUnitArea ( un , create_areas [ side ] , false ) ;
34883: LD_VAR 0 1
34887: PPUSH
34888: LD_LOC 73
34892: PUSH
34893: LD_VAR 0 4
34897: ARRAY
34898: PPUSH
34899: LD_INT 0
34901: PPUSH
34902: CALL_OW 49
// end ; end ;
34906: GO 34468
34908: POP
34909: POP
// enable ;
34910: ENABLE
// end ;
34911: PPOPN 4
34913: END
// export function remove_bad_crates ( side ) ; var list , un , x , y ; begin
34914: LD_INT 0
34916: PPUSH
34917: PPUSH
34918: PPUSH
34919: PPUSH
34920: PPUSH
// case side of us :
34921: LD_VAR 0 1
34925: PUSH
34926: LD_EXP 3
34930: DOUBLE
34931: EQUAL
34932: IFTRUE 34936
34934: GO 35007
34936: POP
// begin x := us_bay [ us_bad ] [ 1 ] ;
34937: LD_ADDR_VAR 0 5
34941: PUSH
34942: LD_LOC 74
34946: PUSH
34947: LD_LOC 77
34951: ARRAY
34952: PUSH
34953: LD_INT 1
34955: ARRAY
34956: ST_TO_ADDR
// y := us_bay [ us_bad ] [ 2 ] ;
34957: LD_ADDR_VAR 0 6
34961: PUSH
34962: LD_LOC 74
34966: PUSH
34967: LD_LOC 77
34971: ARRAY
34972: PUSH
34973: LD_INT 2
34975: ARRAY
34976: ST_TO_ADDR
// us_bad := us_bad ^ [ [ x , y ] ] ;
34977: LD_ADDR_LOC 77
34981: PUSH
34982: LD_LOC 77
34986: PUSH
34987: LD_VAR 0 5
34991: PUSH
34992: LD_VAR 0 6
34996: PUSH
34997: EMPTY
34998: LIST
34999: LIST
35000: PUSH
35001: EMPTY
35002: LIST
35003: ADD
35004: ST_TO_ADDR
// end ; ru :
35005: GO 35170
35007: LD_EXP 2
35011: DOUBLE
35012: EQUAL
35013: IFTRUE 35017
35015: GO 35088
35017: POP
// begin x := ru_bay [ us_bad ] [ 1 ] ;
35018: LD_ADDR_VAR 0 5
35022: PUSH
35023: LD_LOC 75
35027: PUSH
35028: LD_LOC 77
35032: ARRAY
35033: PUSH
35034: LD_INT 1
35036: ARRAY
35037: ST_TO_ADDR
// y := ru_bay [ us_bad ] [ 2 ] ;
35038: LD_ADDR_VAR 0 6
35042: PUSH
35043: LD_LOC 75
35047: PUSH
35048: LD_LOC 77
35052: ARRAY
35053: PUSH
35054: LD_INT 2
35056: ARRAY
35057: ST_TO_ADDR
// ru_bad := ru_bad ^ [ [ x , y ] ] ;
35058: LD_ADDR_LOC 78
35062: PUSH
35063: LD_LOC 78
35067: PUSH
35068: LD_VAR 0 5
35072: PUSH
35073: LD_VAR 0 6
35077: PUSH
35078: EMPTY
35079: LIST
35080: LIST
35081: PUSH
35082: EMPTY
35083: LIST
35084: ADD
35085: ST_TO_ADDR
// end ; ar :
35086: GO 35170
35088: LD_EXP 4
35092: DOUBLE
35093: EQUAL
35094: IFTRUE 35098
35096: GO 35169
35098: POP
// begin x := ar_bay [ us_bad ] [ 1 ] ;
35099: LD_ADDR_VAR 0 5
35103: PUSH
35104: LD_LOC 76
35108: PUSH
35109: LD_LOC 77
35113: ARRAY
35114: PUSH
35115: LD_INT 1
35117: ARRAY
35118: ST_TO_ADDR
// y := ar_bay [ us_bad ] [ 2 ] ;
35119: LD_ADDR_VAR 0 6
35123: PUSH
35124: LD_LOC 76
35128: PUSH
35129: LD_LOC 77
35133: ARRAY
35134: PUSH
35135: LD_INT 2
35137: ARRAY
35138: ST_TO_ADDR
// ru_bad := ru_bad ^ [ [ x , y ] ] ;
35139: LD_ADDR_LOC 78
35143: PUSH
35144: LD_LOC 78
35148: PUSH
35149: LD_VAR 0 5
35153: PUSH
35154: LD_VAR 0 6
35158: PUSH
35159: EMPTY
35160: LIST
35161: LIST
35162: PUSH
35163: EMPTY
35164: LIST
35165: ADD
35166: ST_TO_ADDR
// end ; end ;
35167: GO 35170
35169: POP
// list := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_class , class_engineer ] , [ f_ok ] ] ) ;
35170: LD_ADDR_VAR 0 3
35174: PUSH
35175: LD_INT 22
35177: PUSH
35178: LD_VAR 0 1
35182: PUSH
35183: EMPTY
35184: LIST
35185: LIST
35186: PUSH
35187: LD_INT 21
35189: PUSH
35190: LD_INT 1
35192: PUSH
35193: EMPTY
35194: LIST
35195: LIST
35196: PUSH
35197: LD_INT 25
35199: PUSH
35200: LD_INT 2
35202: PUSH
35203: EMPTY
35204: LIST
35205: LIST
35206: PUSH
35207: LD_INT 50
35209: PUSH
35210: EMPTY
35211: LIST
35212: PUSH
35213: EMPTY
35214: LIST
35215: LIST
35216: LIST
35217: LIST
35218: PPUSH
35219: CALL_OW 69
35223: ST_TO_ADDR
// for un in list do
35224: LD_ADDR_VAR 0 4
35228: PUSH
35229: LD_VAR 0 3
35233: PUSH
35234: FOR_IN
35235: IFFALSE 35288
// if not GetUnitMc ( un ) then
35237: LD_VAR 0 4
35241: PPUSH
35242: CALL_OW 388
35246: NOT
35247: IFFALSE 35286
// begin ComRemember ( un ) ;
35249: LD_VAR 0 4
35253: PPUSH
35254: CALL_OW 143
// AddComCollect ( un , x , y ) ;
35258: LD_VAR 0 4
35262: PPUSH
35263: LD_VAR 0 5
35267: PPUSH
35268: LD_VAR 0 6
35272: PPUSH
35273: CALL_OW 177
// AddComReturn ( un ) ;
35277: LD_VAR 0 4
35281: PPUSH
35282: CALL_OW 204
// end ;
35286: GO 35234
35288: POP
35289: POP
// end ;
35290: LD_VAR 0 2
35294: RET
// every 0 0$7.9 trigger us_bad do var un , list ;
35295: LD_LOC 77
35299: IFFALSE 35396
35301: GO 35303
35303: DISABLE
35304: LD_INT 0
35306: PPUSH
35307: PPUSH
// begin list := [ ] ;
35308: LD_ADDR_VAR 0 2
35312: PUSH
35313: EMPTY
35314: ST_TO_ADDR
// for un in us_bad do
35315: LD_ADDR_VAR 0 1
35319: PUSH
35320: LD_LOC 77
35324: PUSH
35325: FOR_IN
35326: IFFALSE 35383
// begin MoveAreaXY ( crates_check , un [ 1 ] , un [ 2 ] ) ;
35328: LD_INT 35
35330: PPUSH
35331: LD_VAR 0 1
35335: PUSH
35336: LD_INT 1
35338: ARRAY
35339: PPUSH
35340: LD_VAR 0 1
35344: PUSH
35345: LD_INT 2
35347: ARRAY
35348: PPUSH
35349: CALL_OW 425
// if GetListOfCratesInArea ( crates_check ) then
35353: LD_INT 35
35355: PPUSH
35356: CALL_OW 435
35360: IFFALSE 35381
// list := list ^ [ un ] ;
35362: LD_ADDR_VAR 0 2
35366: PUSH
35367: LD_VAR 0 2
35371: PUSH
35372: LD_VAR 0 1
35376: PUSH
35377: EMPTY
35378: LIST
35379: ADD
35380: ST_TO_ADDR
// end ;
35381: GO 35325
35383: POP
35384: POP
// us_bad := list ;
35385: LD_ADDR_LOC 77
35389: PUSH
35390: LD_VAR 0 2
35394: ST_TO_ADDR
// enable ;
35395: ENABLE
// end ;
35396: PPOPN 2
35398: END
// every 0 0$7.8 trigger ru_bad do var un , list ;
35399: LD_LOC 78
35403: IFFALSE 35500
35405: GO 35407
35407: DISABLE
35408: LD_INT 0
35410: PPUSH
35411: PPUSH
// begin list := [ ] ;
35412: LD_ADDR_VAR 0 2
35416: PUSH
35417: EMPTY
35418: ST_TO_ADDR
// for un in ru_bad do
35419: LD_ADDR_VAR 0 1
35423: PUSH
35424: LD_LOC 78
35428: PUSH
35429: FOR_IN
35430: IFFALSE 35487
// begin MoveAreaXY ( crates_check , un [ 1 ] , un [ 2 ] ) ;
35432: LD_INT 35
35434: PPUSH
35435: LD_VAR 0 1
35439: PUSH
35440: LD_INT 1
35442: ARRAY
35443: PPUSH
35444: LD_VAR 0 1
35448: PUSH
35449: LD_INT 2
35451: ARRAY
35452: PPUSH
35453: CALL_OW 425
// if GetListOfCratesInArea ( crates_check ) then
35457: LD_INT 35
35459: PPUSH
35460: CALL_OW 435
35464: IFFALSE 35485
// list := list ^ [ un ] ;
35466: LD_ADDR_VAR 0 2
35470: PUSH
35471: LD_VAR 0 2
35475: PUSH
35476: LD_VAR 0 1
35480: PUSH
35481: EMPTY
35482: LIST
35483: ADD
35484: ST_TO_ADDR
// end ;
35485: GO 35429
35487: POP
35488: POP
// ru_bad := list ;
35489: LD_ADDR_LOC 78
35493: PUSH
35494: LD_VAR 0 2
35498: ST_TO_ADDR
// enable ;
35499: ENABLE
// end ;
35500: PPOPN 2
35502: END
// every 0 0$7.7 trigger ar_bad do var un , list ;
35503: LD_LOC 79
35507: IFFALSE 35604
35509: GO 35511
35511: DISABLE
35512: LD_INT 0
35514: PPUSH
35515: PPUSH
// begin list := [ ] ;
35516: LD_ADDR_VAR 0 2
35520: PUSH
35521: EMPTY
35522: ST_TO_ADDR
// for un in ar_bad do
35523: LD_ADDR_VAR 0 1
35527: PUSH
35528: LD_LOC 79
35532: PUSH
35533: FOR_IN
35534: IFFALSE 35591
// begin MoveAreaXY ( crates_check , un [ 1 ] , un [ 2 ] ) ;
35536: LD_INT 35
35538: PPUSH
35539: LD_VAR 0 1
35543: PUSH
35544: LD_INT 1
35546: ARRAY
35547: PPUSH
35548: LD_VAR 0 1
35552: PUSH
35553: LD_INT 2
35555: ARRAY
35556: PPUSH
35557: CALL_OW 425
// if GetListOfCratesInArea ( crates_check ) then
35561: LD_INT 35
35563: PPUSH
35564: CALL_OW 435
35568: IFFALSE 35589
// list := list ^ [ un ] ;
35570: LD_ADDR_VAR 0 2
35574: PUSH
35575: LD_VAR 0 2
35579: PUSH
35580: LD_VAR 0 1
35584: PUSH
35585: EMPTY
35586: LIST
35587: ADD
35588: ST_TO_ADDR
// end ;
35589: GO 35533
35591: POP
35592: POP
// ar_bad := list ;
35593: LD_ADDR_LOC 79
35597: PUSH
35598: LD_VAR 0 2
35602: ST_TO_ADDR
// enable ;
35603: ENABLE
// end ; end_of_file
35604: PPOPN 2
35606: END
// export function check_remote ( veh ) ; var un , towers , list , all_in , veh_n , veh_l , mech ; begin
35607: LD_INT 0
35609: PPUSH
35610: PPUSH
35611: PPUSH
35612: PPUSH
35613: PPUSH
35614: PPUSH
35615: PPUSH
35616: PPUSH
// list := [ ] ;
35617: LD_ADDR_VAR 0 5
35621: PUSH
35622: EMPTY
35623: ST_TO_ADDR
// veh_l := FilterAllUnits ( [ [ f_side , us ] , [ f_control , control_remote ] , [ f_ok ] ] ) union veh diff 0 ;
35624: LD_ADDR_VAR 0 8
35628: PUSH
35629: LD_INT 22
35631: PUSH
35632: LD_EXP 3
35636: PUSH
35637: EMPTY
35638: LIST
35639: LIST
35640: PUSH
35641: LD_INT 33
35643: PUSH
35644: LD_INT 2
35646: PUSH
35647: EMPTY
35648: LIST
35649: LIST
35650: PUSH
35651: LD_INT 50
35653: PUSH
35654: EMPTY
35655: LIST
35656: PUSH
35657: EMPTY
35658: LIST
35659: LIST
35660: LIST
35661: PPUSH
35662: CALL_OW 69
35666: PUSH
35667: LD_VAR 0 1
35671: UNION
35672: PUSH
35673: LD_INT 0
35675: DIFF
35676: ST_TO_ADDR
// towers := FilterAllUnits ( [ [ f_side , us ] , [ f_btype , b_control_tower ] , [ f_ok ] ] ) ;
35677: LD_ADDR_VAR 0 4
35681: PUSH
35682: LD_INT 22
35684: PUSH
35685: LD_EXP 3
35689: PUSH
35690: EMPTY
35691: LIST
35692: LIST
35693: PUSH
35694: LD_INT 30
35696: PUSH
35697: LD_INT 36
35699: PUSH
35700: EMPTY
35701: LIST
35702: LIST
35703: PUSH
35704: LD_INT 50
35706: PUSH
35707: EMPTY
35708: LIST
35709: PUSH
35710: EMPTY
35711: LIST
35712: LIST
35713: LIST
35714: PPUSH
35715: CALL_OW 69
35719: ST_TO_ADDR
// if not towers then
35720: LD_VAR 0 4
35724: NOT
35725: IFFALSE 35729
// exit ;
35727: GO 36324
// towers := towers [ 1 ] ;
35729: LD_ADDR_VAR 0 4
35733: PUSH
35734: LD_VAR 0 4
35738: PUSH
35739: LD_INT 1
35741: ARRAY
35742: ST_TO_ADDR
// all_in := UnitsInside ( towers ) ;
35743: LD_ADDR_VAR 0 6
35747: PUSH
35748: LD_VAR 0 4
35752: PPUSH
35753: CALL_OW 313
35757: ST_TO_ADDR
// mech := all_in ^ ( FilterAllUnits ( [ [ f_side , us ] , [ f_type , unit_human ] , [ f_class , class_mechanic ] , [ f_ok ] ] ) diff reserved_people [ us ] ) ;
35758: LD_ADDR_VAR 0 9
35762: PUSH
35763: LD_VAR 0 6
35767: PUSH
35768: LD_INT 22
35770: PUSH
35771: LD_EXP 3
35775: PUSH
35776: EMPTY
35777: LIST
35778: LIST
35779: PUSH
35780: LD_INT 21
35782: PUSH
35783: LD_INT 1
35785: PUSH
35786: EMPTY
35787: LIST
35788: LIST
35789: PUSH
35790: LD_INT 25
35792: PUSH
35793: LD_INT 3
35795: PUSH
35796: EMPTY
35797: LIST
35798: LIST
35799: PUSH
35800: LD_INT 50
35802: PUSH
35803: EMPTY
35804: LIST
35805: PUSH
35806: EMPTY
35807: LIST
35808: LIST
35809: LIST
35810: LIST
35811: PPUSH
35812: CALL_OW 69
35816: PUSH
35817: LD_EXP 73
35821: PUSH
35822: LD_EXP 3
35826: ARRAY
35827: DIFF
35828: ADD
35829: ST_TO_ADDR
// for un in mech do
35830: LD_ADDR_VAR 0 3
35834: PUSH
35835: LD_VAR 0 9
35839: PUSH
35840: FOR_IN
35841: IFFALSE 35875
// list := list ^ FindMaxSkill ( mech diff list , skill_mechanical ) ;
35843: LD_ADDR_VAR 0 5
35847: PUSH
35848: LD_VAR 0 5
35852: PUSH
35853: LD_VAR 0 9
35857: PUSH
35858: LD_VAR 0 5
35862: DIFF
35863: PPUSH
35864: LD_INT 3
35866: PPUSH
35867: CALL_OW 433
35871: ADD
35872: ST_TO_ADDR
35873: GO 35840
35875: POP
35876: POP
// mech := [ ] ;
35877: LD_ADDR_VAR 0 9
35881: PUSH
35882: EMPTY
35883: ST_TO_ADDR
// veh_n := 0 + veh_l ;
35884: LD_ADDR_VAR 0 7
35888: PUSH
35889: LD_INT 0
35891: PUSH
35892: LD_VAR 0 8
35896: PLUS
35897: ST_TO_ADDR
// for un in list do
35898: LD_ADDR_VAR 0 3
35902: PUSH
35903: LD_VAR 0 5
35907: PUSH
35908: FOR_IN
35909: IFFALSE 35979
// if ( veh_n > 0 ) or ( ( list diff mech ) > 6 ) then
35911: LD_VAR 0 7
35915: PUSH
35916: LD_INT 0
35918: GREATER
35919: PUSH
35920: LD_VAR 0 5
35924: PUSH
35925: LD_VAR 0 9
35929: DIFF
35930: PUSH
35931: LD_INT 6
35933: GREATER
35934: OR
35935: IFFALSE 35977
// begin mech := mech ^ un ;
35937: LD_ADDR_VAR 0 9
35941: PUSH
35942: LD_VAR 0 9
35946: PUSH
35947: LD_VAR 0 3
35951: ADD
35952: ST_TO_ADDR
// veh_n := veh_n - GetSkill ( un , skill_mechanical ) ;
35953: LD_ADDR_VAR 0 7
35957: PUSH
35958: LD_VAR 0 7
35962: PUSH
35963: LD_VAR 0 3
35967: PPUSH
35968: LD_INT 3
35970: PPUSH
35971: CALL_OW 259
35975: MINUS
35976: ST_TO_ADDR
// end ;
35977: GO 35908
35979: POP
35980: POP
// un := reserved_people [ us ] ^ mech ;
35981: LD_ADDR_VAR 0 3
35985: PUSH
35986: LD_EXP 73
35990: PUSH
35991: LD_EXP 3
35995: ARRAY
35996: PUSH
35997: LD_VAR 0 9
36001: ADD
36002: ST_TO_ADDR
// reserved_people := Delete ( reserved_people , us ) ;
36003: LD_ADDR_EXP 73
36007: PUSH
36008: LD_EXP 73
36012: PPUSH
36013: LD_EXP 3
36017: PPUSH
36018: CALL_OW 3
36022: ST_TO_ADDR
// reserved_people := Insert ( reserved_people , us , un ) ;
36023: LD_ADDR_EXP 73
36027: PUSH
36028: LD_EXP 73
36032: PPUSH
36033: LD_EXP 3
36037: PPUSH
36038: LD_VAR 0 3
36042: PPUSH
36043: CALL_OW 2
36047: ST_TO_ADDR
// list := UnitsInside ( towers ) diff mech ;
36048: LD_ADDR_VAR 0 5
36052: PUSH
36053: LD_VAR 0 4
36057: PPUSH
36058: CALL_OW 313
36062: PUSH
36063: LD_VAR 0 9
36067: DIFF
36068: ST_TO_ADDR
// if list then
36069: LD_VAR 0 5
36073: IFFALSE 36229
// begin un := reserved_people [ us ] diff list ;
36075: LD_ADDR_VAR 0 3
36079: PUSH
36080: LD_EXP 73
36084: PUSH
36085: LD_EXP 3
36089: ARRAY
36090: PUSH
36091: LD_VAR 0 5
36095: DIFF
36096: ST_TO_ADDR
// reserved_people := Delete ( reserved_people , us ) ;
36097: LD_ADDR_EXP 73
36101: PUSH
36102: LD_EXP 73
36106: PPUSH
36107: LD_EXP 3
36111: PPUSH
36112: CALL_OW 3
36116: ST_TO_ADDR
// reserved_people := Insert ( reserved_people , us , un ) ;
36117: LD_ADDR_EXP 73
36121: PUSH
36122: LD_EXP 73
36126: PPUSH
36127: LD_EXP 3
36131: PPUSH
36132: LD_VAR 0 3
36136: PPUSH
36137: CALL_OW 2
36141: ST_TO_ADDR
// ComExitBuilding ( list ) ;
36142: LD_VAR 0 5
36146: PPUSH
36147: CALL_OW 122
// un := FilterAllUnits ( [ [ f_side , us ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ;
36151: LD_ADDR_VAR 0 3
36155: PUSH
36156: LD_INT 22
36158: PUSH
36159: LD_EXP 3
36163: PUSH
36164: EMPTY
36165: LIST
36166: LIST
36167: PUSH
36168: LD_INT 2
36170: PUSH
36171: LD_INT 30
36173: PUSH
36174: LD_INT 2
36176: PUSH
36177: EMPTY
36178: LIST
36179: LIST
36180: PUSH
36181: LD_INT 30
36183: PUSH
36184: LD_INT 3
36186: PUSH
36187: EMPTY
36188: LIST
36189: LIST
36190: PUSH
36191: EMPTY
36192: LIST
36193: LIST
36194: LIST
36195: PUSH
36196: EMPTY
36197: LIST
36198: LIST
36199: PPUSH
36200: CALL_OW 69
36204: ST_TO_ADDR
// if un then
36205: LD_VAR 0 3
36209: IFFALSE 36229
// AddComMoveUnit ( list , un [ 1 ] ) ;
36211: LD_VAR 0 5
36215: PPUSH
36216: LD_VAR 0 3
36220: PUSH
36221: LD_INT 1
36223: ARRAY
36224: PPUSH
36225: CALL_OW 172
// end ; repeat ComMoveUnit ( mech , towers ) ;
36229: LD_VAR 0 9
36233: PPUSH
36234: LD_VAR 0 4
36238: PPUSH
36239: CALL_OW 112
// all_in := true ;
36243: LD_ADDR_VAR 0 6
36247: PUSH
36248: LD_INT 1
36250: ST_TO_ADDR
// for un in mech do
36251: LD_ADDR_VAR 0 3
36255: PUSH
36256: LD_VAR 0 9
36260: PUSH
36261: FOR_IN
36262: IFFALSE 36294
// if not ( IsInUnit ( un ) = towers ) then
36264: LD_VAR 0 3
36268: PPUSH
36269: CALL_OW 310
36273: PUSH
36274: LD_VAR 0 4
36278: EQUAL
36279: NOT
36280: IFFALSE 36292
// begin all_in := false ;
36282: LD_ADDR_VAR 0 6
36286: PUSH
36287: LD_INT 0
36289: ST_TO_ADDR
// break ;
36290: GO 36294
// end ;
36292: GO 36261
36294: POP
36295: POP
// wait ( 0 0$1 ) ;
36296: LD_INT 35
36298: PPUSH
36299: CALL_OW 67
// until all_in ;
36303: LD_VAR 0 6
36307: IFFALSE 36229
// ComLinkTo ( veh_l , towers ) ;
36309: LD_VAR 0 8
36313: PPUSH
36314: LD_VAR 0 4
36318: PPUSH
36319: CALL_OW 135
// enable ;
36323: ENABLE
// end ;
36324: LD_VAR 0 2
36328: RET
// every 0 0$10 do var list , tower ;
36329: GO 36331
36331: DISABLE
36332: LD_INT 0
36334: PPUSH
36335: PPUSH
// begin list := FilterAllUnits ( [ [ f_side , us ] , [ f_ok ] , [ f_control , control_remote ] , f_not , [ f_linked ] ] ) ;
36336: LD_ADDR_VAR 0 1
36340: PUSH
36341: LD_INT 22
36343: PUSH
36344: LD_EXP 3
36348: PUSH
36349: EMPTY
36350: LIST
36351: LIST
36352: PUSH
36353: LD_INT 50
36355: PUSH
36356: EMPTY
36357: LIST
36358: PUSH
36359: LD_INT 33
36361: PUSH
36362: LD_INT 2
36364: PUSH
36365: EMPTY
36366: LIST
36367: LIST
36368: PUSH
36369: LD_INT 3
36371: PUSH
36372: LD_INT 61
36374: PUSH
36375: EMPTY
36376: LIST
36377: PUSH
36378: EMPTY
36379: LIST
36380: LIST
36381: LIST
36382: LIST
36383: LIST
36384: PPUSH
36385: CALL_OW 69
36389: ST_TO_ADDR
// if list then
36390: LD_VAR 0 1
36394: IFFALSE 36478
// begin tower := FilterAllUnits ( [ [ f_side , us ] , [ f_btype , b_control_tower ] , [ f_ok ] ] ) ;
36396: LD_ADDR_VAR 0 2
36400: PUSH
36401: LD_INT 22
36403: PUSH
36404: LD_EXP 3
36408: PUSH
36409: EMPTY
36410: LIST
36411: LIST
36412: PUSH
36413: LD_INT 30
36415: PUSH
36416: LD_INT 36
36418: PUSH
36419: EMPTY
36420: LIST
36421: LIST
36422: PUSH
36423: LD_INT 50
36425: PUSH
36426: EMPTY
36427: LIST
36428: PUSH
36429: EMPTY
36430: LIST
36431: LIST
36432: LIST
36433: PPUSH
36434: CALL_OW 69
36438: ST_TO_ADDR
// if tower then
36439: LD_VAR 0 2
36443: IFFALSE 36461
// tower := tower [ 1 ] else
36445: LD_ADDR_VAR 0 2
36449: PUSH
36450: LD_VAR 0 2
36454: PUSH
36455: LD_INT 1
36457: ARRAY
36458: ST_TO_ADDR
36459: GO 36464
// begin enable ;
36461: ENABLE
// exit ;
36462: GO 36479
// end ; ComLinkTo ( list , tower ) ;
36464: LD_VAR 0 1
36468: PPUSH
36469: LD_VAR 0 2
36473: PPUSH
36474: CALL_OW 135
// end ; enable ;
36478: ENABLE
// end ; end_of_file
36479: PPOPN 2
36481: END
// export us_sib_wait , ru_sib_wait ; var time_to_end ; export function init_sib_rocket ; begin
36482: LD_INT 0
36484: PPUSH
// us_sib_wait := false ;
36485: LD_ADDR_EXP 76
36489: PUSH
36490: LD_INT 0
36492: ST_TO_ADDR
// ru_sib_wait := false ;
36493: LD_ADDR_EXP 77
36497: PUSH
36498: LD_INT 0
36500: ST_TO_ADDR
// time_to_end := [ 85 85$0 , 65 65$0 , 45 45$0 ] [ difficulty ] ;
36501: LD_ADDR_LOC 80
36505: PUSH
36506: LD_INT 178500
36508: PUSH
36509: LD_INT 136500
36511: PUSH
36512: LD_INT 94500
36514: PUSH
36515: EMPTY
36516: LIST
36517: LIST
36518: LIST
36519: PUSH
36520: LD_OWVAR 67
36524: ARRAY
36525: ST_TO_ADDR
// end ;
36526: LD_VAR 0 1
36530: RET
// every 0 0$1.5 trigger TICK > time_to_end marked 4 do var factory , zdroje ;
36531: LD_OWVAR 1
36535: PUSH
36536: LD_LOC 80
36540: GREATER
36541: IFFALSE 36774
36543: GO 36545
36545: DISABLE
36546: LD_INT 0
36548: PPUSH
36549: PPUSH
// begin factory := FilterAllUnits ( [ [ f_side , us ] , [ f_btype , b_factory ] ] ) ;
36550: LD_ADDR_VAR 0 1
36554: PUSH
36555: LD_INT 22
36557: PUSH
36558: LD_EXP 3
36562: PUSH
36563: EMPTY
36564: LIST
36565: LIST
36566: PUSH
36567: LD_INT 30
36569: PUSH
36570: LD_INT 3
36572: PUSH
36573: EMPTY
36574: LIST
36575: LIST
36576: PUSH
36577: EMPTY
36578: LIST
36579: LIST
36580: PPUSH
36581: CALL_OW 69
36585: ST_TO_ADDR
// if factory then
36586: LD_VAR 0 1
36590: IFFALSE 36773
// begin factory := factory [ 1 ] ;
36592: LD_ADDR_VAR 0 1
36596: PUSH
36597: LD_VAR 0 1
36601: PUSH
36602: LD_INT 1
36604: ARRAY
36605: ST_TO_ADDR
// if us_siberium_rocket in AvailableWeaponList ( factory ) then
36606: LD_INT 8
36608: PUSH
36609: LD_VAR 0 1
36613: PPUSH
36614: CALL_OW 478
36618: IN
36619: IFFALSE 36773
// begin zdroje := GetResources ( GetBase ( factory ) ) ;
36621: LD_ADDR_VAR 0 2
36625: PUSH
36626: LD_VAR 0 1
36630: PPUSH
36631: CALL_OW 274
36635: PPUSH
36636: CALL_OW 279
36640: ST_TO_ADDR
// if ( zdroje [ 1 ] >= 75 ) and ( ( zdroje [ 2 ] >= 30 ) or ( zdroje [ 3 ] >= 70 ) ) and ( zdroje [ 3 ] >= 60 ) then
36641: LD_VAR 0 2
36645: PUSH
36646: LD_INT 1
36648: ARRAY
36649: PUSH
36650: LD_INT 75
36652: GREATEREQUAL
36653: PUSH
36654: LD_VAR 0 2
36658: PUSH
36659: LD_INT 2
36661: ARRAY
36662: PUSH
36663: LD_INT 30
36665: GREATEREQUAL
36666: PUSH
36667: LD_VAR 0 2
36671: PUSH
36672: LD_INT 3
36674: ARRAY
36675: PUSH
36676: LD_INT 70
36678: GREATEREQUAL
36679: OR
36680: AND
36681: PUSH
36682: LD_VAR 0 2
36686: PUSH
36687: LD_INT 3
36689: ARRAY
36690: PUSH
36691: LD_INT 60
36693: GREATEREQUAL
36694: AND
36695: IFFALSE 36765
// begin if zdroje [ 3 ] >= 70 then
36697: LD_VAR 0 2
36701: PUSH
36702: LD_INT 3
36704: ARRAY
36705: PUSH
36706: LD_INT 70
36708: GREATEREQUAL
36709: IFFALSE 36734
// ComConstruct ( factory , us_morphling , engine_siberite , control_remote , us_siberium_rocket ) else
36711: LD_VAR 0 1
36715: PPUSH
36716: LD_INT 5
36718: PPUSH
36719: LD_INT 3
36721: PPUSH
36722: LD_INT 2
36724: PPUSH
36725: LD_INT 8
36727: PPUSH
36728: CALL_OW 125
36732: GO 36755
// ComConstruct ( factory , us_morphling , engine_combustion , control_remote , us_siberium_rocket ) ;
36734: LD_VAR 0 1
36738: PPUSH
36739: LD_INT 5
36741: PPUSH
36742: LD_INT 1
36744: PPUSH
36745: LD_INT 2
36747: PPUSH
36748: LD_INT 8
36750: PPUSH
36751: CALL_OW 125
// us_sib_wait := false ;
36755: LD_ADDR_EXP 76
36759: PUSH
36760: LD_INT 0
36762: ST_TO_ADDR
// end else
36763: GO 36773
// us_sib_wait := true ;
36765: LD_ADDR_EXP 76
36769: PUSH
36770: LD_INT 1
36772: ST_TO_ADDR
// end ; end ; enable ;
36773: ENABLE
// end ;
36774: PPOPN 2
36776: END
// every 0 0$1.5 trigger TICK > time_to_end marked 5 do var factory , zdroje ;
36777: LD_OWVAR 1
36781: PUSH
36782: LD_LOC 80
36786: GREATER
36787: IFFALSE 37020
36789: GO 36791
36791: DISABLE
36792: LD_INT 0
36794: PPUSH
36795: PPUSH
// begin factory := FilterAllUnits ( [ [ f_side , ru ] , [ f_btype , b_factory ] ] ) ;
36796: LD_ADDR_VAR 0 1
36800: PUSH
36801: LD_INT 22
36803: PUSH
36804: LD_EXP 2
36808: PUSH
36809: EMPTY
36810: LIST
36811: LIST
36812: PUSH
36813: LD_INT 30
36815: PUSH
36816: LD_INT 3
36818: PUSH
36819: EMPTY
36820: LIST
36821: LIST
36822: PUSH
36823: EMPTY
36824: LIST
36825: LIST
36826: PPUSH
36827: CALL_OW 69
36831: ST_TO_ADDR
// if factory then
36832: LD_VAR 0 1
36836: IFFALSE 37019
// begin factory := factory [ 1 ] ;
36838: LD_ADDR_VAR 0 1
36842: PUSH
36843: LD_VAR 0 1
36847: PUSH
36848: LD_INT 1
36850: ARRAY
36851: ST_TO_ADDR
// if ru_siberium_rocket in AvailableWeaponList ( factory ) then
36852: LD_INT 48
36854: PUSH
36855: LD_VAR 0 1
36859: PPUSH
36860: CALL_OW 478
36864: IN
36865: IFFALSE 37019
// begin zdroje := GetResources ( GetBase ( factory ) ) ;
36867: LD_ADDR_VAR 0 2
36871: PUSH
36872: LD_VAR 0 1
36876: PPUSH
36877: CALL_OW 274
36881: PPUSH
36882: CALL_OW 279
36886: ST_TO_ADDR
// if ( zdroje [ 1 ] >= 75 ) and ( ( zdroje [ 2 ] >= 30 ) or ( zdroje [ 3 ] >= 70 ) ) and ( zdroje [ 3 ] >= 60 ) then
36887: LD_VAR 0 2
36891: PUSH
36892: LD_INT 1
36894: ARRAY
36895: PUSH
36896: LD_INT 75
36898: GREATEREQUAL
36899: PUSH
36900: LD_VAR 0 2
36904: PUSH
36905: LD_INT 2
36907: ARRAY
36908: PUSH
36909: LD_INT 30
36911: GREATEREQUAL
36912: PUSH
36913: LD_VAR 0 2
36917: PUSH
36918: LD_INT 3
36920: ARRAY
36921: PUSH
36922: LD_INT 70
36924: GREATEREQUAL
36925: OR
36926: AND
36927: PUSH
36928: LD_VAR 0 2
36932: PUSH
36933: LD_INT 3
36935: ARRAY
36936: PUSH
36937: LD_INT 60
36939: GREATEREQUAL
36940: AND
36941: IFFALSE 37011
// begin if zdroje [ 3 ] >= 70 then
36943: LD_VAR 0 2
36947: PUSH
36948: LD_INT 3
36950: ARRAY
36951: PUSH
36952: LD_INT 70
36954: GREATEREQUAL
36955: IFFALSE 36980
// ComConstruct ( factory , ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ) else
36957: LD_VAR 0 1
36961: PPUSH
36962: LD_INT 23
36964: PPUSH
36965: LD_INT 3
36967: PPUSH
36968: LD_INT 3
36970: PPUSH
36971: LD_INT 48
36973: PPUSH
36974: CALL_OW 125
36978: GO 37001
// ComConstruct ( factory , ru_heavy_wheeled , engine_combustion , control_computer , ru_siberium_rocket ) ;
36980: LD_VAR 0 1
36984: PPUSH
36985: LD_INT 23
36987: PPUSH
36988: LD_INT 1
36990: PPUSH
36991: LD_INT 3
36993: PPUSH
36994: LD_INT 48
36996: PPUSH
36997: CALL_OW 125
// ru_sib_wait := false ;
37001: LD_ADDR_EXP 77
37005: PUSH
37006: LD_INT 0
37008: ST_TO_ADDR
// end else
37009: GO 37019
// ru_sib_wait := true ;
37011: LD_ADDR_EXP 77
37015: PUSH
37016: LD_INT 1
37018: ST_TO_ADDR
// end ; end ; enable ;
37019: ENABLE
// end ;
37020: PPOPN 2
37022: END
// export function send_sib_to_US ( veh ) ; var n_check , s_check , send ; begin
37023: LD_INT 0
37025: PPUSH
37026: PPUSH
37027: PPUSH
37028: PPUSH
// repeat n_check := FilterUnitsInArea ( north_check , [ [ f_type , unit_vehicle ] , f_not , [ f_side , ru ] ] ) ;
37029: LD_ADDR_VAR 0 3
37033: PUSH
37034: LD_INT 25
37036: PPUSH
37037: LD_INT 21
37039: PUSH
37040: LD_INT 2
37042: PUSH
37043: EMPTY
37044: LIST
37045: LIST
37046: PUSH
37047: LD_INT 3
37049: PUSH
37050: LD_INT 22
37052: PUSH
37053: LD_EXP 2
37057: PUSH
37058: EMPTY
37059: LIST
37060: LIST
37061: PUSH
37062: EMPTY
37063: LIST
37064: LIST
37065: LIST
37066: PPUSH
37067: CALL_OW 70
37071: ST_TO_ADDR
// s_check := FilterUnitsInArea ( south_check , [ [ f_type , unit_vehicle ] , f_not , [ f_side , ru ] ] ) ;
37072: LD_ADDR_VAR 0 4
37076: PUSH
37077: LD_INT 26
37079: PPUSH
37080: LD_INT 21
37082: PUSH
37083: LD_INT 2
37085: PUSH
37086: EMPTY
37087: LIST
37088: LIST
37089: PUSH
37090: LD_INT 3
37092: PUSH
37093: LD_INT 22
37095: PUSH
37096: LD_EXP 2
37100: PUSH
37101: EMPTY
37102: LIST
37103: LIST
37104: PUSH
37105: EMPTY
37106: LIST
37107: LIST
37108: LIST
37109: PPUSH
37110: CALL_OW 70
37114: ST_TO_ADDR
// wait ( 0 0$2 ) ;
37115: LD_INT 70
37117: PPUSH
37118: CALL_OW 67
// until ( n_check < 3 ) and ( s_check < 3 ) ;
37122: LD_VAR 0 3
37126: PUSH
37127: LD_INT 3
37129: LESS
37130: PUSH
37131: LD_VAR 0 4
37135: PUSH
37136: LD_INT 3
37138: LESS
37139: AND
37140: IFFALSE 37029
// ComMoveXY ( veh , 144 , 65 ) ;
37142: LD_VAR 0 1
37146: PPUSH
37147: LD_INT 144
37149: PPUSH
37150: LD_INT 65
37152: PPUSH
37153: CALL_OW 111
// if n_check < s_check then
37157: LD_VAR 0 3
37161: PUSH
37162: LD_VAR 0 4
37166: LESS
37167: IFFALSE 37216
// begin AddComMoveXY ( veh , 87 , 35 ) ;
37169: LD_VAR 0 1
37173: PPUSH
37174: LD_INT 87
37176: PPUSH
37177: LD_INT 35
37179: PPUSH
37180: CALL_OW 171
// AddComMoveXY ( veh , 42 , 16 ) ;
37184: LD_VAR 0 1
37188: PPUSH
37189: LD_INT 42
37191: PPUSH
37192: LD_INT 16
37194: PPUSH
37195: CALL_OW 171
// AddComAttackPlace ( veh , 41 , 56 ) ;
37199: LD_VAR 0 1
37203: PPUSH
37204: LD_INT 41
37206: PPUSH
37207: LD_INT 56
37209: PPUSH
37210: CALL_OW 176
// end else
37214: GO 37308
// begin AddComMoveXY ( veh , 141 , 116 ) ;
37216: LD_VAR 0 1
37220: PPUSH
37221: LD_INT 141
37223: PPUSH
37224: LD_INT 116
37226: PPUSH
37227: CALL_OW 171
// AddComMoveXY ( veh , 109 , 110 ) ;
37231: LD_VAR 0 1
37235: PPUSH
37236: LD_INT 109
37238: PPUSH
37239: LD_INT 110
37241: PPUSH
37242: CALL_OW 171
// if GetChassis ( veh ) = ru_heavy_tracked then
37246: LD_VAR 0 1
37250: PPUSH
37251: CALL_OW 265
37255: PUSH
37256: LD_INT 24
37258: EQUAL
37259: IFFALSE 37278
// AddComMoveXY ( veh , 86 , 106 ) else
37261: LD_VAR 0 1
37265: PPUSH
37266: LD_INT 86
37268: PPUSH
37269: LD_INT 106
37271: PPUSH
37272: CALL_OW 171
37276: GO 37293
// AddComMoveXY ( veh , 85 , 75 ) ;
37278: LD_VAR 0 1
37282: PPUSH
37283: LD_INT 85
37285: PPUSH
37286: LD_INT 75
37288: PPUSH
37289: CALL_OW 171
// AddComAttackPlace ( veh , 41 , 66 ) ;
37293: LD_VAR 0 1
37297: PPUSH
37298: LD_INT 41
37300: PPUSH
37301: LD_INT 66
37303: PPUSH
37304: CALL_OW 176
// end ; end ; end_of_file
37308: LD_VAR 0 2
37312: RET
// export artefact_number , artefact_num , artefact_size ; export labs_in_use ; export function init_alien_research ; var art_icons , art_events , art_difficulty , art_cost , art_recharge ; begin
37313: LD_INT 0
37315: PPUSH
37316: PPUSH
37317: PPUSH
37318: PPUSH
37319: PPUSH
37320: PPUSH
// artefact_number := 3 ;
37321: LD_ADDR_EXP 78
37325: PUSH
37326: LD_INT 3
37328: ST_TO_ADDR
// artefact_num := [ 0 , 0 , 1 , 2 , 3 ] ;
37329: LD_ADDR_EXP 79
37333: PUSH
37334: LD_INT 0
37336: PUSH
37337: LD_INT 0
37339: PUSH
37340: LD_INT 1
37342: PUSH
37343: LD_INT 2
37345: PUSH
37346: LD_INT 3
37348: PUSH
37349: EMPTY
37350: LIST
37351: LIST
37352: LIST
37353: LIST
37354: LIST
37355: ST_TO_ADDR
// artefact_size := [ 3 , 4 , 5 ] ;
37356: LD_ADDR_EXP 80
37360: PUSH
37361: LD_INT 3
37363: PUSH
37364: LD_INT 4
37366: PUSH
37367: LD_INT 5
37369: PUSH
37370: EMPTY
37371: LIST
37372: LIST
37373: LIST
37374: ST_TO_ADDR
// art_icons := [ [ art_exp_left , art_use_eye ] , [ art_exp_mid , art_use_sibexplosion ] , [ art_exp_right , art_use_power ] ] ;
37375: LD_ADDR_VAR 0 2
37379: PUSH
37380: LD_INT 1
37382: PUSH
37383: LD_INT 4
37385: PUSH
37386: EMPTY
37387: LIST
37388: LIST
37389: PUSH
37390: LD_INT 2
37392: PUSH
37393: LD_INT 5
37395: PUSH
37396: EMPTY
37397: LIST
37398: LIST
37399: PUSH
37400: LD_INT 3
37402: PUSH
37403: LD_INT 9
37405: PUSH
37406: EMPTY
37407: LIST
37408: LIST
37409: PUSH
37410: EMPTY
37411: LIST
37412: LIST
37413: LIST
37414: ST_TO_ADDR
// art_events := [ art_place , art_unit , art_place ] ;
37415: LD_ADDR_VAR 0 3
37419: PUSH
37420: LD_INT 3
37422: PUSH
37423: LD_INT 4
37425: PUSH
37426: LD_INT 3
37428: PUSH
37429: EMPTY
37430: LIST
37431: LIST
37432: LIST
37433: ST_TO_ADDR
// art_difficulty := [ 150 , 250 , 400 ] ;
37434: LD_ADDR_VAR 0 4
37438: PUSH
37439: LD_INT 150
37441: PUSH
37442: LD_INT 250
37444: PUSH
37445: LD_INT 400
37447: PUSH
37448: EMPTY
37449: LIST
37450: LIST
37451: LIST
37452: ST_TO_ADDR
// art_cost := [ 1 + difficulty , 2 + ( 3 * difficulty ) , 30 + ( 10 * difficulty ) ] ;
37453: LD_ADDR_VAR 0 5
37457: PUSH
37458: LD_INT 1
37460: PUSH
37461: LD_OWVAR 67
37465: PLUS
37466: PUSH
37467: LD_INT 2
37469: PUSH
37470: LD_INT 3
37472: PUSH
37473: LD_OWVAR 67
37477: MUL
37478: PLUS
37479: PUSH
37480: LD_INT 30
37482: PUSH
37483: LD_INT 10
37485: PUSH
37486: LD_OWVAR 67
37490: MUL
37491: PLUS
37492: PUSH
37493: EMPTY
37494: LIST
37495: LIST
37496: LIST
37497: ST_TO_ADDR
// art_recharge := [ 6 * difficulty , 12 * difficulty , 10000 ] ;
37498: LD_ADDR_VAR 0 6
37502: PUSH
37503: LD_INT 6
37505: PUSH
37506: LD_OWVAR 67
37510: MUL
37511: PUSH
37512: LD_INT 12
37514: PUSH
37515: LD_OWVAR 67
37519: MUL
37520: PUSH
37521: LD_INT 10000
37523: PUSH
37524: EMPTY
37525: LIST
37526: LIST
37527: LIST
37528: ST_TO_ADDR
// Get_Init_Artefacts ( art_icons , art_events , art_difficulty , art_cost , art_recharge ) ;
37529: LD_VAR 0 2
37533: PPUSH
37534: LD_VAR 0 3
37538: PPUSH
37539: LD_VAR 0 4
37543: PPUSH
37544: LD_VAR 0 5
37548: PPUSH
37549: LD_VAR 0 6
37553: PPUSH
37554: CALL 37563 0 5
// end ;
37558: LD_VAR 0 1
37562: RET
// function Get_Init_Artefacts ( art_icons , art_events , art_difficulty , art_cost , art_recharge ) ; var un , i , side , base ; begin
37563: LD_INT 0
37565: PPUSH
37566: PPUSH
37567: PPUSH
37568: PPUSH
37569: PPUSH
// disable ( 1 ) ;
37570: LD_INT 1
37572: DISABLE_MARKED
// disable ( 5 ) ;
37573: LD_INT 5
37575: DISABLE_MARKED
// disable ( 6 ) ;
37576: LD_INT 6
37578: DISABLE_MARKED
// disable ( 7 ) ;
37579: LD_INT 7
37581: DISABLE_MARKED
// for side = 1 to 8 do
37582: LD_ADDR_VAR 0 9
37586: PUSH
37587: DOUBLE
37588: LD_INT 1
37590: DEC
37591: ST_TO_ADDR
37592: LD_INT 8
37594: PUSH
37595: FOR_TO
37596: IFFALSE 37612
// SetArtifactRes ( side , state_enabled ) ;
37598: LD_VAR 0 9
37602: PPUSH
37603: LD_INT 1
37605: PPUSH
37606: CALL_OW 467
37610: GO 37595
37612: POP
37613: POP
// for un = 0 to ( artefact_number - 1 ) do
37614: LD_ADDR_VAR 0 7
37618: PUSH
37619: DOUBLE
37620: LD_INT 0
37622: DEC
37623: ST_TO_ADDR
37624: LD_EXP 78
37628: PUSH
37629: LD_INT 1
37631: MINUS
37632: PUSH
37633: FOR_TO
37634: IFFALSE 38032
// begin base := un * 100 ;
37636: LD_ADDR_VAR 0 10
37640: PUSH
37641: LD_VAR 0 7
37645: PUSH
37646: LD_INT 100
37648: MUL
37649: ST_TO_ADDR
// SetTag ( base + 01 , art_icons [ un + 1 ] [ 1 ] ) ;
37650: LD_VAR 0 10
37654: PUSH
37655: LD_INT 1
37657: PLUS
37658: PPUSH
37659: LD_VAR 0 1
37663: PUSH
37664: LD_VAR 0 7
37668: PUSH
37669: LD_INT 1
37671: PLUS
37672: ARRAY
37673: PUSH
37674: LD_INT 1
37676: ARRAY
37677: PPUSH
37678: CALL_OW 109
// SetTag ( base + 02 , art_icons [ un + 1 ] [ 2 ] ) ;
37682: LD_VAR 0 10
37686: PUSH
37687: LD_INT 2
37689: PLUS
37690: PPUSH
37691: LD_VAR 0 1
37695: PUSH
37696: LD_VAR 0 7
37700: PUSH
37701: LD_INT 1
37703: PLUS
37704: ARRAY
37705: PUSH
37706: LD_INT 2
37708: ARRAY
37709: PPUSH
37710: CALL_OW 109
// SetTag ( base + 03 , art_events [ un + 1 ] ) ;
37714: LD_VAR 0 10
37718: PUSH
37719: LD_INT 3
37721: PLUS
37722: PPUSH
37723: LD_VAR 0 2
37727: PUSH
37728: LD_VAR 0 7
37732: PUSH
37733: LD_INT 1
37735: PLUS
37736: ARRAY
37737: PPUSH
37738: CALL_OW 109
// SetTag ( base + 05 , art_difficulty [ un + 1 ] ) ;
37742: LD_VAR 0 10
37746: PUSH
37747: LD_INT 5
37749: PLUS
37750: PPUSH
37751: LD_VAR 0 3
37755: PUSH
37756: LD_VAR 0 7
37760: PUSH
37761: LD_INT 1
37763: PLUS
37764: ARRAY
37765: PPUSH
37766: CALL_OW 109
// SetTag ( base + 06 , art_cost [ un + 1 ] ) ;
37770: LD_VAR 0 10
37774: PUSH
37775: LD_INT 6
37777: PLUS
37778: PPUSH
37779: LD_VAR 0 4
37783: PUSH
37784: LD_VAR 0 7
37788: PUSH
37789: LD_INT 1
37791: PLUS
37792: ARRAY
37793: PPUSH
37794: CALL_OW 109
// SetTag ( base + 07 , art_recharge [ un + 1 ] ) ;
37798: LD_VAR 0 10
37802: PUSH
37803: LD_INT 7
37805: PLUS
37806: PPUSH
37807: LD_VAR 0 5
37811: PUSH
37812: LD_VAR 0 7
37816: PUSH
37817: LD_INT 1
37819: PLUS
37820: ARRAY
37821: PPUSH
37822: CALL_OW 109
// SetTag ( base + 08 , false ) ;
37826: LD_VAR 0 10
37830: PUSH
37831: LD_INT 8
37833: PLUS
37834: PPUSH
37835: LD_INT 0
37837: PPUSH
37838: CALL_OW 109
// SetTag ( base + 09 , false ) ;
37842: LD_VAR 0 10
37846: PUSH
37847: LD_INT 9
37849: PLUS
37850: PPUSH
37851: LD_INT 0
37853: PPUSH
37854: CALL_OW 109
// SetTag ( base + 11 , 0 ) ;
37858: LD_VAR 0 10
37862: PUSH
37863: LD_INT 11
37865: PLUS
37866: PPUSH
37867: LD_INT 0
37869: PPUSH
37870: CALL_OW 109
// SetTag ( base + 12 , false ) ;
37874: LD_VAR 0 10
37878: PUSH
37879: LD_INT 12
37881: PLUS
37882: PPUSH
37883: LD_INT 0
37885: PPUSH
37886: CALL_OW 109
// SetTag ( base + 13 , false ) ;
37890: LD_VAR 0 10
37894: PUSH
37895: LD_INT 13
37897: PLUS
37898: PPUSH
37899: LD_INT 0
37901: PPUSH
37902: CALL_OW 109
// for i = 0 to 7 do
37906: LD_ADDR_VAR 0 8
37910: PUSH
37911: DOUBLE
37912: LD_INT 0
37914: DEC
37915: ST_TO_ADDR
37916: LD_INT 7
37918: PUSH
37919: FOR_TO
37920: IFFALSE 38028
// begin SetTag ( base + i * 10 + 21 , false ) ;
37922: LD_VAR 0 10
37926: PUSH
37927: LD_VAR 0 8
37931: PUSH
37932: LD_INT 10
37934: MUL
37935: PLUS
37936: PUSH
37937: LD_INT 21
37939: PLUS
37940: PPUSH
37941: LD_INT 0
37943: PPUSH
37944: CALL_OW 109
// SetTag ( base + i * 10 + 22 , 0 ) ;
37948: LD_VAR 0 10
37952: PUSH
37953: LD_VAR 0 8
37957: PUSH
37958: LD_INT 10
37960: MUL
37961: PLUS
37962: PUSH
37963: LD_INT 22
37965: PLUS
37966: PPUSH
37967: LD_INT 0
37969: PPUSH
37970: CALL_OW 109
// SetTag ( base + i * 10 + 23 , 0 ) ;
37974: LD_VAR 0 10
37978: PUSH
37979: LD_VAR 0 8
37983: PUSH
37984: LD_INT 10
37986: MUL
37987: PLUS
37988: PUSH
37989: LD_INT 23
37991: PLUS
37992: PPUSH
37993: LD_INT 0
37995: PPUSH
37996: CALL_OW 109
// SetTag ( base + i * 10 + 25 , 0 ) ;
38000: LD_VAR 0 10
38004: PUSH
38005: LD_VAR 0 8
38009: PUSH
38010: LD_INT 10
38012: MUL
38013: PLUS
38014: PUSH
38015: LD_INT 25
38017: PLUS
38018: PPUSH
38019: LD_INT 0
38021: PPUSH
38022: CALL_OW 109
// end ;
38026: GO 37919
38028: POP
38029: POP
// end ;
38030: GO 37633
38032: POP
38033: POP
// enable ( 20 ) ;
38034: LD_INT 20
38036: ENABLE_MARKED
// labs_in_use := [ ] ;
38037: LD_ADDR_EXP 81
38041: PUSH
38042: EMPTY
38043: ST_TO_ADDR
// end ;
38044: LD_VAR 0 6
38048: RET
// on ArtifactUnloaded ( un , size ) do var art , base ;
38049: LD_INT 0
38051: PPUSH
38052: PPUSH
// begin art := artefact_num [ size ] ;
38053: LD_ADDR_VAR 0 3
38057: PUSH
38058: LD_EXP 79
38062: PUSH
38063: LD_VAR 0 2
38067: ARRAY
38068: ST_TO_ADDR
// base := ( art - 1 ) * 100 ;
38069: LD_ADDR_VAR 0 4
38073: PUSH
38074: LD_VAR 0 3
38078: PUSH
38079: LD_INT 1
38081: MINUS
38082: PUSH
38083: LD_INT 100
38085: MUL
38086: ST_TO_ADDR
// SetTag ( base + 09 , false ) ;
38087: LD_VAR 0 4
38091: PUSH
38092: LD_INT 9
38094: PLUS
38095: PPUSH
38096: LD_INT 0
38098: PPUSH
38099: CALL_OW 109
// SetTag ( base + 13 , false ) ;
38103: LD_VAR 0 4
38107: PUSH
38108: LD_INT 13
38110: PLUS
38111: PPUSH
38112: LD_INT 0
38114: PPUSH
38115: CALL_OW 109
// Init_Lab ( art ) ;
38119: LD_VAR 0 3
38123: PPUSH
38124: CALL 39660 0 1
// end ;
38128: PPOPN 4
38130: END
// on ArtifactLoaded ( un , size ) do var art , base , side ;
38131: LD_INT 0
38133: PPUSH
38134: PPUSH
38135: PPUSH
// begin art := artefact_num [ size ] ;
38136: LD_ADDR_VAR 0 3
38140: PUSH
38141: LD_EXP 79
38145: PUSH
38146: LD_VAR 0 2
38150: ARRAY
38151: ST_TO_ADDR
// base := ( art - 1 ) * 100 ;
38152: LD_ADDR_VAR 0 4
38156: PUSH
38157: LD_VAR 0 3
38161: PUSH
38162: LD_INT 1
38164: MINUS
38165: PUSH
38166: LD_INT 100
38168: MUL
38169: ST_TO_ADDR
// SetTag ( base + 09 , true ) ;
38170: LD_VAR 0 4
38174: PUSH
38175: LD_INT 9
38177: PLUS
38178: PPUSH
38179: LD_INT 1
38181: PPUSH
38182: CALL_OW 109
// SetTag ( base + 13 , un ) ;
38186: LD_VAR 0 4
38190: PUSH
38191: LD_INT 13
38193: PLUS
38194: PPUSH
38195: LD_VAR 0 1
38199: PPUSH
38200: CALL_OW 109
// if GetTag ( base + 11 ) then
38204: LD_VAR 0 4
38208: PUSH
38209: LD_INT 11
38211: PLUS
38212: PPUSH
38213: CALL_OW 110
38217: IFFALSE 38380
// begin side := GetSide ( GetTag ( base + 11 ) ) ;
38219: LD_ADDR_VAR 0 5
38223: PUSH
38224: LD_VAR 0 4
38228: PUSH
38229: LD_INT 11
38231: PLUS
38232: PPUSH
38233: CALL_OW 110
38237: PPUSH
38238: CALL_OW 255
38242: ST_TO_ADDR
// if GetTag ( base + 12 ) then
38243: LD_VAR 0 4
38247: PUSH
38248: LD_INT 12
38250: PLUS
38251: PPUSH
38252: CALL_OW 110
38256: IFFALSE 38324
// begin ComCancel ( GetTag ( base + 11 ) ) ;
38258: LD_VAR 0 4
38262: PUSH
38263: LD_INT 11
38265: PLUS
38266: PPUSH
38267: CALL_OW 110
38271: PPUSH
38272: CALL_OW 127
// wait ( 5 ) ;
38276: LD_INT 5
38278: PPUSH
38279: CALL_OW 67
// labs_in_use := labs_in_use diff GetTag ( base + 11 ) ;
38283: LD_ADDR_EXP 81
38287: PUSH
38288: LD_EXP 81
38292: PUSH
38293: LD_VAR 0 4
38297: PUSH
38298: LD_INT 11
38300: PLUS
38301: PPUSH
38302: CALL_OW 110
38306: DIFF
38307: ST_TO_ADDR
// SetTag ( base + 12 , false ) ;
38308: LD_VAR 0 4
38312: PUSH
38313: LD_INT 12
38315: PLUS
38316: PPUSH
38317: LD_INT 0
38319: PPUSH
38320: CALL_OW 109
// end ; if not GetTag ( base + side * 10 + 11 ) then
38324: LD_VAR 0 4
38328: PUSH
38329: LD_VAR 0 5
38333: PUSH
38334: LD_INT 10
38336: MUL
38337: PLUS
38338: PUSH
38339: LD_INT 11
38341: PLUS
38342: PPUSH
38343: CALL_OW 110
38347: NOT
38348: IFFALSE 38364
// DeInit_Lab ( side , art ) ;
38350: LD_VAR 0 5
38354: PPUSH
38355: LD_VAR 0 3
38359: PPUSH
38360: CALL 40354 0 2
// SetTag ( base + 11 , 0 ) ;
38364: LD_VAR 0 4
38368: PUSH
38369: LD_INT 11
38371: PLUS
38372: PPUSH
38373: LD_INT 0
38375: PPUSH
38376: CALL_OW 109
// end ; end ;
38380: PPOPN 5
38382: END
// on ArtifactResearchComplete ( lab ) do var un , side ;
38383: LD_INT 0
38385: PPUSH
38386: PPUSH
// begin side := GetSide ( lab ) - 1 ;
38387: LD_ADDR_VAR 0 3
38391: PUSH
38392: LD_VAR 0 1
38396: PPUSH
38397: CALL_OW 255
38401: PUSH
38402: LD_INT 1
38404: MINUS
38405: ST_TO_ADDR
// for un = 0 to ( artefact_number - 1 ) do
38406: LD_ADDR_VAR 0 2
38410: PUSH
38411: DOUBLE
38412: LD_INT 0
38414: DEC
38415: ST_TO_ADDR
38416: LD_EXP 78
38420: PUSH
38421: LD_INT 1
38423: MINUS
38424: PUSH
38425: FOR_TO
38426: IFFALSE 38468
// if lab = GetTag ( un * 100 + 11 ) then
38428: LD_VAR 0 1
38432: PUSH
38433: LD_VAR 0 2
38437: PUSH
38438: LD_INT 100
38440: MUL
38441: PUSH
38442: LD_INT 11
38444: PLUS
38445: PPUSH
38446: CALL_OW 110
38450: EQUAL
38451: IFFALSE 38466
// Init_Lab ( un + 1 ) ;
38453: LD_VAR 0 2
38457: PUSH
38458: LD_INT 1
38460: PLUS
38461: PPUSH
38462: CALL 39660 0 1
38466: GO 38425
38468: POP
38469: POP
// end ;
38470: PPOPN 3
38472: END
// on SpecResearchCancel ( lab , progress ) do var un , side ;
38473: LD_INT 0
38475: PPUSH
38476: PPUSH
// begin side := GetSide ( lab ) - 1 ;
38477: LD_ADDR_VAR 0 4
38481: PUSH
38482: LD_VAR 0 1
38486: PPUSH
38487: CALL_OW 255
38491: PUSH
38492: LD_INT 1
38494: MINUS
38495: ST_TO_ADDR
// for un = 0 to ( artefact_number - 1 ) do
38496: LD_ADDR_VAR 0 3
38500: PUSH
38501: DOUBLE
38502: LD_INT 0
38504: DEC
38505: ST_TO_ADDR
38506: LD_EXP 78
38510: PUSH
38511: LD_INT 1
38513: MINUS
38514: PUSH
38515: FOR_TO
38516: IFFALSE 38634
// if ( GetTag ( un * 100 + 11 ) = lab ) and GetTag ( un * 100 + 12 ) then
38518: LD_VAR 0 3
38522: PUSH
38523: LD_INT 100
38525: MUL
38526: PUSH
38527: LD_INT 11
38529: PLUS
38530: PPUSH
38531: CALL_OW 110
38535: PUSH
38536: LD_VAR 0 1
38540: EQUAL
38541: PUSH
38542: LD_VAR 0 3
38546: PUSH
38547: LD_INT 100
38549: MUL
38550: PUSH
38551: LD_INT 12
38553: PLUS
38554: PPUSH
38555: CALL_OW 110
38559: AND
38560: IFFALSE 38632
// begin SetTag ( un * 100 + side * 10 + 22 , progress ) ;
38562: LD_VAR 0 3
38566: PUSH
38567: LD_INT 100
38569: MUL
38570: PUSH
38571: LD_VAR 0 4
38575: PUSH
38576: LD_INT 10
38578: MUL
38579: PLUS
38580: PUSH
38581: LD_INT 22
38583: PLUS
38584: PPUSH
38585: LD_VAR 0 2
38589: PPUSH
38590: CALL_OW 109
// SetTag ( un * 100 + 12 , false ) ;
38594: LD_VAR 0 3
38598: PUSH
38599: LD_INT 100
38601: MUL
38602: PUSH
38603: LD_INT 12
38605: PLUS
38606: PPUSH
38607: LD_INT 0
38609: PPUSH
38610: CALL_OW 109
// labs_in_use := labs_in_use diff lab ;
38614: LD_ADDR_EXP 81
38618: PUSH
38619: LD_EXP 81
38623: PUSH
38624: LD_VAR 0 1
38628: DIFF
38629: ST_TO_ADDR
// break ;
38630: GO 38634
// end ;
38632: GO 38515
38634: POP
38635: POP
// Update_Artefact ( lab ) ;
38636: LD_VAR 0 1
38640: PPUSH
38641: CALL 40493 0 1
// end ;
38645: PPOPN 4
38647: END
// on SpecResearchComplete ( lab ) do var un , side ;
38648: LD_INT 0
38650: PPUSH
38651: PPUSH
// begin side := GetSide ( lab ) - 1 ;
38652: LD_ADDR_VAR 0 3
38656: PUSH
38657: LD_VAR 0 1
38661: PPUSH
38662: CALL_OW 255
38666: PUSH
38667: LD_INT 1
38669: MINUS
38670: ST_TO_ADDR
// for un = 0 to ( artefact_number - 1 ) do
38671: LD_ADDR_VAR 0 2
38675: PUSH
38676: DOUBLE
38677: LD_INT 0
38679: DEC
38680: ST_TO_ADDR
38681: LD_EXP 78
38685: PUSH
38686: LD_INT 1
38688: MINUS
38689: PUSH
38690: FOR_TO
38691: IFFALSE 38897
// if ( GetTag ( un * 100 + 11 ) = lab ) and GetTag ( un * 100 + 12 ) then
38693: LD_VAR 0 2
38697: PUSH
38698: LD_INT 100
38700: MUL
38701: PUSH
38702: LD_INT 11
38704: PLUS
38705: PPUSH
38706: CALL_OW 110
38710: PUSH
38711: LD_VAR 0 1
38715: EQUAL
38716: PUSH
38717: LD_VAR 0 2
38721: PUSH
38722: LD_INT 100
38724: MUL
38725: PUSH
38726: LD_INT 12
38728: PLUS
38729: PPUSH
38730: CALL_OW 110
38734: AND
38735: IFFALSE 38895
// begin SetTag ( un * 100 + 12 , false ) ;
38737: LD_VAR 0 2
38741: PUSH
38742: LD_INT 100
38744: MUL
38745: PUSH
38746: LD_INT 12
38748: PLUS
38749: PPUSH
38750: LD_INT 0
38752: PPUSH
38753: CALL_OW 109
// SetTag ( un * 100 + side * 10 + 21 , true ) ;
38757: LD_VAR 0 2
38761: PUSH
38762: LD_INT 100
38764: MUL
38765: PUSH
38766: LD_VAR 0 3
38770: PUSH
38771: LD_INT 10
38773: MUL
38774: PLUS
38775: PUSH
38776: LD_INT 21
38778: PLUS
38779: PPUSH
38780: LD_INT 1
38782: PPUSH
38783: CALL_OW 109
// SetTag ( un * 100 + side * 10 + 25 , lab ) ;
38787: LD_VAR 0 2
38791: PUSH
38792: LD_INT 100
38794: MUL
38795: PUSH
38796: LD_VAR 0 3
38800: PUSH
38801: LD_INT 10
38803: MUL
38804: PLUS
38805: PUSH
38806: LD_INT 25
38808: PLUS
38809: PPUSH
38810: LD_VAR 0 1
38814: PPUSH
38815: CALL_OW 109
// labs_in_use := labs_in_use diff lab ;
38819: LD_ADDR_EXP 81
38823: PUSH
38824: LD_EXP 81
38828: PUSH
38829: LD_VAR 0 1
38833: DIFF
38834: ST_TO_ADDR
// case un of 0 :
38835: LD_VAR 0 2
38839: PUSH
38840: LD_INT 0
38842: DOUBLE
38843: EQUAL
38844: IFTRUE 38848
38846: GO 38858
38848: POP
// Hint ( ATSpy ) ; 1 :
38849: LD_STRING ATSpy
38851: PPUSH
38852: CALL_OW 339
38856: GO 38895
38858: LD_INT 1
38860: DOUBLE
38861: EQUAL
38862: IFTRUE 38866
38864: GO 38876
38866: POP
// Hint ( ATDetonated ) ; 2 :
38867: LD_STRING ATDetonated
38869: PPUSH
38870: CALL_OW 339
38874: GO 38895
38876: LD_INT 2
38878: DOUBLE
38879: EQUAL
38880: IFTRUE 38884
38882: GO 38894
38884: POP
// Hint ( ArterfactTeleport ) ; end ;
38885: LD_STRING ArterfactTeleport
38887: PPUSH
38888: CALL_OW 339
38892: GO 38895
38894: POP
// end ;
38895: GO 38690
38897: POP
38898: POP
// Update_Artefact ( lab ) ;
38899: LD_VAR 0 1
38903: PPUSH
38904: CALL 40493 0 1
// end ;
38908: PPOPN 3
38910: END
// on ArtifactUsed ( side , number , p1 , p2 ) do var un , succes , art , base ;
38911: LD_INT 0
38913: PPUSH
38914: PPUSH
38915: PPUSH
38916: PPUSH
// begin art := ( ( number - 1 ) mod 3 ) + 1 ;
38917: LD_ADDR_VAR 0 7
38921: PUSH
38922: LD_VAR 0 2
38926: PUSH
38927: LD_INT 1
38929: MINUS
38930: PUSH
38931: LD_INT 3
38933: MOD
38934: PUSH
38935: LD_INT 1
38937: PLUS
38938: ST_TO_ADDR
// base := ( art - 1 ) * 100 ;
38939: LD_ADDR_VAR 0 8
38943: PUSH
38944: LD_VAR 0 7
38948: PUSH
38949: LD_INT 1
38951: MINUS
38952: PUSH
38953: LD_INT 100
38955: MUL
38956: ST_TO_ADDR
// if number <= 3 then
38957: LD_VAR 0 2
38961: PUSH
38962: LD_INT 3
38964: LESSEQUAL
38965: IFFALSE 39197
// begin SetSpecResearch ( GetTag ( base + 11 ) , GetTag ( base + 05 ) , true ) ;
38967: LD_VAR 0 8
38971: PUSH
38972: LD_INT 11
38974: PLUS
38975: PPUSH
38976: CALL_OW 110
38980: PPUSH
38981: LD_VAR 0 8
38985: PUSH
38986: LD_INT 5
38988: PLUS
38989: PPUSH
38990: CALL_OW 110
38994: PPUSH
38995: LD_INT 1
38997: PPUSH
38998: CALL_OW 486
// SetWorkingProgress ( GetTag ( base + 11 ) , GetTag ( base + side * 10 + 12 ) ) ;
39002: LD_VAR 0 8
39006: PUSH
39007: LD_INT 11
39009: PLUS
39010: PPUSH
39011: CALL_OW 110
39015: PPUSH
39016: LD_VAR 0 8
39020: PUSH
39021: LD_VAR 0 1
39025: PUSH
39026: LD_INT 10
39028: MUL
39029: PLUS
39030: PUSH
39031: LD_INT 12
39033: PLUS
39034: PPUSH
39035: CALL_OW 110
39039: PPUSH
39040: CALL_OW 329
// SetTag ( base + 12 , true ) ;
39044: LD_VAR 0 8
39048: PUSH
39049: LD_INT 12
39051: PLUS
39052: PPUSH
39053: LD_INT 1
39055: PPUSH
39056: CALL_OW 109
// labs_in_use := labs_in_use ^ GetTag ( base + 11 ) ;
39060: LD_ADDR_EXP 81
39064: PUSH
39065: LD_EXP 81
39069: PUSH
39070: LD_VAR 0 8
39074: PUSH
39075: LD_INT 11
39077: PLUS
39078: PPUSH
39079: CALL_OW 110
39083: ADD
39084: ST_TO_ADDR
// for un = 0 to ( artefact_number - 1 ) do
39085: LD_ADDR_VAR 0 5
39089: PUSH
39090: DOUBLE
39091: LD_INT 0
39093: DEC
39094: ST_TO_ADDR
39095: LD_EXP 78
39099: PUSH
39100: LD_INT 1
39102: MINUS
39103: PUSH
39104: FOR_TO
39105: IFFALSE 39193
// if GetTag ( base + 11 ) in [ GetTag ( un * 100 + 11 ) , GetTag ( un * 100 + side * 10 + 15 ) ] then
39107: LD_VAR 0 8
39111: PUSH
39112: LD_INT 11
39114: PLUS
39115: PPUSH
39116: CALL_OW 110
39120: PUSH
39121: LD_VAR 0 5
39125: PUSH
39126: LD_INT 100
39128: MUL
39129: PUSH
39130: LD_INT 11
39132: PLUS
39133: PPUSH
39134: CALL_OW 110
39138: PUSH
39139: LD_VAR 0 5
39143: PUSH
39144: LD_INT 100
39146: MUL
39147: PUSH
39148: LD_VAR 0 1
39152: PUSH
39153: LD_INT 10
39155: MUL
39156: PLUS
39157: PUSH
39158: LD_INT 15
39160: PLUS
39161: PPUSH
39162: CALL_OW 110
39166: PUSH
39167: EMPTY
39168: LIST
39169: LIST
39170: IN
39171: IFFALSE 39191
// DeInit_Lab ( side , un + 1 ) ;
39173: LD_VAR 0 1
39177: PPUSH
39178: LD_VAR 0 5
39182: PUSH
39183: LD_INT 1
39185: PLUS
39186: PPUSH
39187: CALL 40354 0 2
39191: GO 39104
39193: POP
39194: POP
// end else
39195: GO 39371
// begin succes := false ;
39197: LD_ADDR_VAR 0 6
39201: PUSH
39202: LD_INT 0
39204: ST_TO_ADDR
// case art of 1 :
39205: LD_VAR 0 7
39209: PUSH
39210: LD_INT 1
39212: DOUBLE
39213: EQUAL
39214: IFTRUE 39218
39216: GO 39246
39218: POP
// succes := Show_me_map ( side , p1 , p2 ) ; 2 :
39219: LD_ADDR_VAR 0 6
39223: PUSH
39224: LD_VAR 0 1
39228: PPUSH
39229: LD_VAR 0 3
39233: PPUSH
39234: LD_VAR 0 4
39238: PPUSH
39239: CALL 40793 0 3
39243: ST_TO_ADDR
39244: GO 39314
39246: LD_INT 2
39248: DOUBLE
39249: EQUAL
39250: IFTRUE 39254
39252: GO 39277
39254: POP
// succes := Destroy_siberite ( side , p1 ) ; 3 :
39255: LD_ADDR_VAR 0 6
39259: PUSH
39260: LD_VAR 0 1
39264: PPUSH
39265: LD_VAR 0 3
39269: PPUSH
39270: CALL 41031 0 2
39274: ST_TO_ADDR
39275: GO 39314
39277: LD_INT 3
39279: DOUBLE
39280: EQUAL
39281: IFTRUE 39285
39283: GO 39313
39285: POP
// succes := Mass_Teleport ( side , p1 , p2 ) ; end ;
39286: LD_ADDR_VAR 0 6
39290: PUSH
39291: LD_VAR 0 1
39295: PPUSH
39296: LD_VAR 0 3
39300: PPUSH
39301: LD_VAR 0 4
39305: PPUSH
39306: CALL 41356 0 3
39310: ST_TO_ADDR
39311: GO 39314
39313: POP
// if succes then
39314: LD_VAR 0 6
39318: IFFALSE 39371
// begin SetTag ( base + side * 10 + 13 , GetTag ( base + 07 ) ) ;
39320: LD_VAR 0 8
39324: PUSH
39325: LD_VAR 0 1
39329: PUSH
39330: LD_INT 10
39332: MUL
39333: PLUS
39334: PUSH
39335: LD_INT 13
39337: PLUS
39338: PPUSH
39339: LD_VAR 0 8
39343: PUSH
39344: LD_INT 7
39346: PLUS
39347: PPUSH
39348: CALL_OW 110
39352: PPUSH
39353: CALL_OW 109
// Shadow_Artefact ( side , art ) ;
39357: LD_VAR 0 1
39361: PPUSH
39362: LD_VAR 0 7
39366: PPUSH
39367: CALL 39374 0 2
// end ; end ; end ;
39371: PPOPN 8
39373: END
// export function Shadow_Artefact ( side , art ) ; var base , lab ; begin
39374: LD_INT 0
39376: PPUSH
39377: PPUSH
39378: PPUSH
// base := ( art - 1 ) * 100 ;
39379: LD_ADDR_VAR 0 4
39383: PUSH
39384: LD_VAR 0 2
39388: PUSH
39389: LD_INT 1
39391: MINUS
39392: PUSH
39393: LD_INT 100
39395: MUL
39396: ST_TO_ADDR
// lab := GetTag ( base + side * 10 + 15 ) ;
39397: LD_ADDR_VAR 0 5
39401: PUSH
39402: LD_VAR 0 4
39406: PUSH
39407: LD_VAR 0 1
39411: PUSH
39412: LD_INT 10
39414: MUL
39415: PLUS
39416: PUSH
39417: LD_INT 15
39419: PLUS
39420: PPUSH
39421: CALL_OW 110
39425: ST_TO_ADDR
// if lab and ( not lab in labs_in_use ) then
39426: LD_VAR 0 5
39430: PUSH
39431: LD_VAR 0 5
39435: PUSH
39436: LD_EXP 81
39440: IN
39441: NOT
39442: AND
39443: IFFALSE 39501
// SetArtifactUse ( side , GetTag ( base + 01 + GetTag ( base + side * 10 + 11 ) ) , art_gray , lab ) ;
39445: LD_VAR 0 1
39449: PPUSH
39450: LD_VAR 0 4
39454: PUSH
39455: LD_INT 1
39457: PLUS
39458: PUSH
39459: LD_VAR 0 4
39463: PUSH
39464: LD_VAR 0 1
39468: PUSH
39469: LD_INT 10
39471: MUL
39472: PLUS
39473: PUSH
39474: LD_INT 11
39476: PLUS
39477: PPUSH
39478: CALL_OW 110
39482: PLUS
39483: PPUSH
39484: CALL_OW 110
39488: PPUSH
39489: LD_INT 1
39491: PPUSH
39492: LD_VAR 0 5
39496: PPUSH
39497: CALL_OW 468
// end ;
39501: LD_VAR 0 3
39505: RET
// export function Highlight_Artefact ( side , art ) ; var base , lab ; begin
39506: LD_INT 0
39508: PPUSH
39509: PPUSH
39510: PPUSH
// base := ( art - 1 ) * 100 ;
39511: LD_ADDR_VAR 0 4
39515: PUSH
39516: LD_VAR 0 2
39520: PUSH
39521: LD_INT 1
39523: MINUS
39524: PUSH
39525: LD_INT 100
39527: MUL
39528: ST_TO_ADDR
// lab := GetTag ( base + side * 10 + 15 ) ;
39529: LD_ADDR_VAR 0 5
39533: PUSH
39534: LD_VAR 0 4
39538: PUSH
39539: LD_VAR 0 1
39543: PUSH
39544: LD_INT 10
39546: MUL
39547: PLUS
39548: PUSH
39549: LD_INT 15
39551: PLUS
39552: PPUSH
39553: CALL_OW 110
39557: ST_TO_ADDR
// if lab and ( not lab in labs_in_use ) and UnitsInside ( lab ) then
39558: LD_VAR 0 5
39562: PUSH
39563: LD_VAR 0 5
39567: PUSH
39568: LD_EXP 81
39572: IN
39573: NOT
39574: AND
39575: PUSH
39576: LD_VAR 0 5
39580: PPUSH
39581: CALL_OW 313
39585: AND
39586: IFFALSE 39655
// SetArtifactUse ( side , GetTag ( base + 01 + GetTag ( base + side * 10 + 11 ) ) , GetTag ( base + 03 ) , lab ) ;
39588: LD_VAR 0 1
39592: PPUSH
39593: LD_VAR 0 4
39597: PUSH
39598: LD_INT 1
39600: PLUS
39601: PUSH
39602: LD_VAR 0 4
39606: PUSH
39607: LD_VAR 0 1
39611: PUSH
39612: LD_INT 10
39614: MUL
39615: PLUS
39616: PUSH
39617: LD_INT 11
39619: PLUS
39620: PPUSH
39621: CALL_OW 110
39625: PLUS
39626: PPUSH
39627: CALL_OW 110
39631: PPUSH
39632: LD_VAR 0 4
39636: PUSH
39637: LD_INT 3
39639: PLUS
39640: PPUSH
39641: CALL_OW 110
39645: PPUSH
39646: LD_VAR 0 5
39650: PPUSH
39651: CALL_OW 468
// end ;
39655: LD_VAR 0 3
39659: RET
// export function Init_Lab ( art ) ; var list , side , base , dist , state , art_hex , nearest_lab ; begin
39660: LD_INT 0
39662: PPUSH
39663: PPUSH
39664: PPUSH
39665: PPUSH
39666: PPUSH
39667: PPUSH
39668: PPUSH
39669: PPUSH
// art_hex := FindArtifact ( artefact_size [ art ] ) ;
39670: LD_ADDR_VAR 0 8
39674: PUSH
39675: LD_EXP 80
39679: PUSH
39680: LD_VAR 0 1
39684: ARRAY
39685: PPUSH
39686: CALL_OW 469
39690: ST_TO_ADDR
// if not art_hex then
39691: LD_VAR 0 8
39695: NOT
39696: IFFALSE 39700
// exit ;
39698: GO 40349
// case art of 1 :
39700: LD_VAR 0 1
39704: PUSH
39705: LD_INT 1
39707: DOUBLE
39708: EQUAL
39709: IFTRUE 39713
39711: GO 39790
39713: POP
// list := FilterAllUnits ( [ [ f_nation , nation_american ] , [ f_type , unit_building ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; 2 :
39714: LD_ADDR_VAR 0 3
39718: PUSH
39719: LD_INT 23
39721: PUSH
39722: LD_INT 1
39724: PUSH
39725: EMPTY
39726: LIST
39727: LIST
39728: PUSH
39729: LD_INT 21
39731: PUSH
39732: LD_INT 3
39734: PUSH
39735: EMPTY
39736: LIST
39737: LIST
39738: PUSH
39739: LD_INT 2
39741: PUSH
39742: LD_INT 30
39744: PUSH
39745: LD_INT 6
39747: PUSH
39748: EMPTY
39749: LIST
39750: LIST
39751: PUSH
39752: LD_INT 30
39754: PUSH
39755: LD_INT 7
39757: PUSH
39758: EMPTY
39759: LIST
39760: LIST
39761: PUSH
39762: LD_INT 30
39764: PUSH
39765: LD_INT 8
39767: PUSH
39768: EMPTY
39769: LIST
39770: LIST
39771: PUSH
39772: EMPTY
39773: LIST
39774: LIST
39775: LIST
39776: LIST
39777: PUSH
39778: EMPTY
39779: LIST
39780: LIST
39781: LIST
39782: PPUSH
39783: CALL_OW 69
39787: ST_TO_ADDR
39788: GO 39910
39790: LD_INT 2
39792: DOUBLE
39793: EQUAL
39794: IFTRUE 39798
39796: GO 39875
39798: POP
// list := FilterAllUnits ( [ [ f_nation , nation_russian ] , [ f_type , unit_building ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; 3 :
39799: LD_ADDR_VAR 0 3
39803: PUSH
39804: LD_INT 23
39806: PUSH
39807: LD_INT 3
39809: PUSH
39810: EMPTY
39811: LIST
39812: LIST
39813: PUSH
39814: LD_INT 21
39816: PUSH
39817: LD_INT 3
39819: PUSH
39820: EMPTY
39821: LIST
39822: LIST
39823: PUSH
39824: LD_INT 2
39826: PUSH
39827: LD_INT 30
39829: PUSH
39830: LD_INT 6
39832: PUSH
39833: EMPTY
39834: LIST
39835: LIST
39836: PUSH
39837: LD_INT 30
39839: PUSH
39840: LD_INT 7
39842: PUSH
39843: EMPTY
39844: LIST
39845: LIST
39846: PUSH
39847: LD_INT 30
39849: PUSH
39850: LD_INT 8
39852: PUSH
39853: EMPTY
39854: LIST
39855: LIST
39856: PUSH
39857: EMPTY
39858: LIST
39859: LIST
39860: LIST
39861: LIST
39862: PUSH
39863: EMPTY
39864: LIST
39865: LIST
39866: LIST
39867: PPUSH
39868: CALL_OW 69
39872: ST_TO_ADDR
39873: GO 39910
39875: LD_INT 3
39877: DOUBLE
39878: EQUAL
39879: IFTRUE 39883
39881: GO 39909
39883: POP
// list := FilterAllUnits ( [ [ f_btype , b_alien_tower ] ] ) ; end ;
39884: LD_ADDR_VAR 0 3
39888: PUSH
39889: LD_INT 30
39891: PUSH
39892: LD_INT 39
39894: PUSH
39895: EMPTY
39896: LIST
39897: LIST
39898: PUSH
39899: EMPTY
39900: LIST
39901: PPUSH
39902: CALL_OW 69
39906: ST_TO_ADDR
39907: GO 39910
39909: POP
// nearest_lab := NearestUnitToXY ( list , art_hex [ 1 ] , art_hex [ 2 ] ) ;
39910: LD_ADDR_VAR 0 9
39914: PUSH
39915: LD_VAR 0 3
39919: PPUSH
39920: LD_VAR 0 8
39924: PUSH
39925: LD_INT 1
39927: ARRAY
39928: PPUSH
39929: LD_VAR 0 8
39933: PUSH
39934: LD_INT 2
39936: ARRAY
39937: PPUSH
39938: CALL_OW 73
39942: ST_TO_ADDR
// dist := GetDistUnitXY ( nearest_lab , art_hex [ 1 ] , art_hex [ 2 ] ) ;
39943: LD_ADDR_VAR 0 6
39947: PUSH
39948: LD_VAR 0 9
39952: PPUSH
39953: LD_VAR 0 8
39957: PUSH
39958: LD_INT 1
39960: ARRAY
39961: PPUSH
39962: LD_VAR 0 8
39966: PUSH
39967: LD_INT 2
39969: ARRAY
39970: PPUSH
39971: CALL_OW 297
39975: ST_TO_ADDR
// if dist < 25 then
39976: LD_VAR 0 6
39980: PUSH
39981: LD_INT 25
39983: LESS
39984: IFFALSE 40349
// begin side := GetSide ( nearest_lab ) ;
39986: LD_ADDR_VAR 0 4
39990: PUSH
39991: LD_VAR 0 9
39995: PPUSH
39996: CALL_OW 255
40000: ST_TO_ADDR
// DeInit_Lab ( side , art ) ;
40001: LD_VAR 0 4
40005: PPUSH
40006: LD_VAR 0 1
40010: PPUSH
40011: CALL 40354 0 2
// base := ( art - 1 ) * 100 ;
40015: LD_ADDR_VAR 0 5
40019: PUSH
40020: LD_VAR 0 1
40024: PUSH
40025: LD_INT 1
40027: MINUS
40028: PUSH
40029: LD_INT 100
40031: MUL
40032: ST_TO_ADDR
// if ( GetTech ( tech_Artifact , side ) = state_researched ) then
40033: LD_INT 24
40035: PPUSH
40036: LD_VAR 0 4
40040: PPUSH
40041: CALL_OW 321
40045: PUSH
40046: LD_INT 2
40048: EQUAL
40049: IFFALSE 40252
// begin if GetTag ( base + side * 10 + 11 ) and UnitsInside ( nearest_lab ) then
40051: LD_VAR 0 5
40055: PUSH
40056: LD_VAR 0 4
40060: PUSH
40061: LD_INT 10
40063: MUL
40064: PLUS
40065: PUSH
40066: LD_INT 11
40068: PLUS
40069: PPUSH
40070: CALL_OW 110
40074: PUSH
40075: LD_VAR 0 9
40079: PPUSH
40080: CALL_OW 313
40084: AND
40085: IFFALSE 40242
// begin if not GetTag ( base + side * 10 + 13 ) then
40087: LD_VAR 0 5
40091: PUSH
40092: LD_VAR 0 4
40096: PUSH
40097: LD_INT 10
40099: MUL
40100: PLUS
40101: PUSH
40102: LD_INT 13
40104: PLUS
40105: PPUSH
40106: CALL_OW 110
40110: NOT
40111: IFFALSE 40134
// state := GetTag ( base + 03 ) else
40113: LD_ADDR_VAR 0 7
40117: PUSH
40118: LD_VAR 0 5
40122: PUSH
40123: LD_INT 3
40125: PLUS
40126: PPUSH
40127: CALL_OW 110
40131: ST_TO_ADDR
40132: GO 40142
// state := art_gray ;
40134: LD_ADDR_VAR 0 7
40138: PUSH
40139: LD_INT 1
40141: ST_TO_ADDR
// if GetTag ( base + side * 10 + 15 ) and ( GetTag ( base + side * 10 + 15 ) <> nearest_lab ) then
40142: LD_VAR 0 5
40146: PUSH
40147: LD_VAR 0 4
40151: PUSH
40152: LD_INT 10
40154: MUL
40155: PLUS
40156: PUSH
40157: LD_INT 15
40159: PLUS
40160: PPUSH
40161: CALL_OW 110
40165: PUSH
40166: LD_VAR 0 5
40170: PUSH
40171: LD_VAR 0 4
40175: PUSH
40176: LD_INT 10
40178: MUL
40179: PLUS
40180: PUSH
40181: LD_INT 15
40183: PLUS
40184: PPUSH
40185: CALL_OW 110
40189: PUSH
40190: LD_VAR 0 9
40194: NONEQUAL
40195: AND
40196: IFFALSE 40212
// DeInit_Lab ( side , art ) ;
40198: LD_VAR 0 4
40202: PPUSH
40203: LD_VAR 0 1
40207: PPUSH
40208: CALL 40354 0 2
// SetTag ( base + side * 10 + 15 , nearest_lab ) ;
40212: LD_VAR 0 5
40216: PUSH
40217: LD_VAR 0 4
40221: PUSH
40222: LD_INT 10
40224: MUL
40225: PLUS
40226: PUSH
40227: LD_INT 15
40229: PLUS
40230: PPUSH
40231: LD_VAR 0 9
40235: PPUSH
40236: CALL_OW 109
// end else
40240: GO 40250
// state := art_instant ;
40242: LD_ADDR_VAR 0 7
40246: PUSH
40247: LD_INT 2
40249: ST_TO_ADDR
// end else
40250: GO 40260
// state := art_gray ;
40252: LD_ADDR_VAR 0 7
40256: PUSH
40257: LD_INT 1
40259: ST_TO_ADDR
// SetTag ( base + 11 , nearest_lab ) ;
40260: LD_VAR 0 5
40264: PUSH
40265: LD_INT 11
40267: PLUS
40268: PPUSH
40269: LD_VAR 0 9
40273: PPUSH
40274: CALL_OW 109
// if not ( nearest_lab in labs_in_use ) then
40278: LD_VAR 0 9
40282: PUSH
40283: LD_EXP 81
40287: IN
40288: NOT
40289: IFFALSE 40349
// SetArtifactUse ( side , GetTag ( base + 01 + GetTag ( base + side * 10 + 11 ) ) , state , nearest_lab ) ;
40291: LD_VAR 0 4
40295: PPUSH
40296: LD_VAR 0 5
40300: PUSH
40301: LD_INT 1
40303: PLUS
40304: PUSH
40305: LD_VAR 0 5
40309: PUSH
40310: LD_VAR 0 4
40314: PUSH
40315: LD_INT 10
40317: MUL
40318: PLUS
40319: PUSH
40320: LD_INT 11
40322: PLUS
40323: PPUSH
40324: CALL_OW 110
40328: PLUS
40329: PPUSH
40330: CALL_OW 110
40334: PPUSH
40335: LD_VAR 0 7
40339: PPUSH
40340: LD_VAR 0 9
40344: PPUSH
40345: CALL_OW 468
// end ; end ;
40349: LD_VAR 0 2
40353: RET
// export function DeInit_Lab ( side , art ) ; var base , lab ; begin
40354: LD_INT 0
40356: PPUSH
40357: PPUSH
40358: PPUSH
// base := ( art - 1 ) * 100 ;
40359: LD_ADDR_VAR 0 4
40363: PUSH
40364: LD_VAR 0 2
40368: PUSH
40369: LD_INT 1
40371: MINUS
40372: PUSH
40373: LD_INT 100
40375: MUL
40376: ST_TO_ADDR
// lab := GetTag ( base + side * 10 + 15 ) ;
40377: LD_ADDR_VAR 0 5
40381: PUSH
40382: LD_VAR 0 4
40386: PUSH
40387: LD_VAR 0 1
40391: PUSH
40392: LD_INT 10
40394: MUL
40395: PLUS
40396: PUSH
40397: LD_INT 15
40399: PLUS
40400: PPUSH
40401: CALL_OW 110
40405: ST_TO_ADDR
// if not lab then
40406: LD_VAR 0 5
40410: NOT
40411: IFFALSE 40432
// lab := GetTag ( base + 11 ) ;
40413: LD_ADDR_VAR 0 5
40417: PUSH
40418: LD_VAR 0 4
40422: PUSH
40423: LD_INT 11
40425: PLUS
40426: PPUSH
40427: CALL_OW 110
40431: ST_TO_ADDR
// SetArtifactUse ( side , GetTag ( base + 01 + GetTag ( base + side * 10 + 11 ) ) , art_no , lab ) ;
40432: LD_VAR 0 1
40436: PPUSH
40437: LD_VAR 0 4
40441: PUSH
40442: LD_INT 1
40444: PLUS
40445: PUSH
40446: LD_VAR 0 4
40450: PUSH
40451: LD_VAR 0 1
40455: PUSH
40456: LD_INT 10
40458: MUL
40459: PLUS
40460: PUSH
40461: LD_INT 11
40463: PLUS
40464: PPUSH
40465: CALL_OW 110
40469: PLUS
40470: PPUSH
40471: CALL_OW 110
40475: PPUSH
40476: LD_INT 0
40478: PPUSH
40479: LD_VAR 0 5
40483: PPUSH
40484: CALL_OW 468
// end ;
40488: LD_VAR 0 3
40492: RET
// export function Update_Artefact ( lab ) ; var art , side , base ; begin
40493: LD_INT 0
40495: PPUSH
40496: PPUSH
40497: PPUSH
40498: PPUSH
// side := GetSide ( lab ) ;
40499: LD_ADDR_VAR 0 4
40503: PUSH
40504: LD_VAR 0 1
40508: PPUSH
40509: CALL_OW 255
40513: ST_TO_ADDR
// for art = 1 to artefact_number do
40514: LD_ADDR_VAR 0 3
40518: PUSH
40519: DOUBLE
40520: LD_INT 1
40522: DEC
40523: ST_TO_ADDR
40524: LD_EXP 78
40528: PUSH
40529: FOR_TO
40530: IFFALSE 40686
// begin base := ( art - 1 ) * 100 ;
40532: LD_ADDR_VAR 0 5
40536: PUSH
40537: LD_VAR 0 3
40541: PUSH
40542: LD_INT 1
40544: MINUS
40545: PUSH
40546: LD_INT 100
40548: MUL
40549: ST_TO_ADDR
// if GetTag ( base + 11 ) = lab then
40550: LD_VAR 0 5
40554: PUSH
40555: LD_INT 11
40557: PLUS
40558: PPUSH
40559: CALL_OW 110
40563: PUSH
40564: LD_VAR 0 1
40568: EQUAL
40569: IFFALSE 40582
// Init_Lab ( art ) else
40571: LD_VAR 0 3
40575: PPUSH
40576: CALL 39660 0 1
40580: GO 40684
// begin if lab = GetTag ( base + side * 10 + 15 ) then
40582: LD_VAR 0 1
40586: PUSH
40587: LD_VAR 0 5
40591: PUSH
40592: LD_VAR 0 4
40596: PUSH
40597: LD_INT 10
40599: MUL
40600: PLUS
40601: PUSH
40602: LD_INT 15
40604: PLUS
40605: PPUSH
40606: CALL_OW 110
40610: EQUAL
40611: IFFALSE 40684
// begin if ( GetTag ( base + side * 10 + 13 ) > 0 ) or ( not UnitsInside ( lab ) ) then
40613: LD_VAR 0 5
40617: PUSH
40618: LD_VAR 0 4
40622: PUSH
40623: LD_INT 10
40625: MUL
40626: PLUS
40627: PUSH
40628: LD_INT 13
40630: PLUS
40631: PPUSH
40632: CALL_OW 110
40636: PUSH
40637: LD_INT 0
40639: GREATER
40640: PUSH
40641: LD_VAR 0 1
40645: PPUSH
40646: CALL_OW 313
40650: NOT
40651: OR
40652: IFFALSE 40670
// Shadow_Artefact ( side , art ) else
40654: LD_VAR 0 4
40658: PPUSH
40659: LD_VAR 0 3
40663: PPUSH
40664: CALL 39374 0 2
40668: GO 40684
// Highlight_Artefact ( side , art ) ;
40670: LD_VAR 0 4
40674: PPUSH
40675: LD_VAR 0 3
40679: PPUSH
40680: CALL 39506 0 2
// end ; end ; end ;
40684: GO 40529
40686: POP
40687: POP
// end ;
40688: LD_VAR 0 2
40692: RET
// every 0 0$2 marked 20 do var list , lab ;
40693: GO 40695
40695: DISABLE
40696: LD_INT 0
40698: PPUSH
40699: PPUSH
// begin list := FilterAllUnits ( [ [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_alien_tower ] ] ] ) ;
40700: LD_ADDR_VAR 0 1
40704: PUSH
40705: LD_INT 2
40707: PUSH
40708: LD_INT 30
40710: PUSH
40711: LD_INT 6
40713: PUSH
40714: EMPTY
40715: LIST
40716: LIST
40717: PUSH
40718: LD_INT 30
40720: PUSH
40721: LD_INT 7
40723: PUSH
40724: EMPTY
40725: LIST
40726: LIST
40727: PUSH
40728: LD_INT 30
40730: PUSH
40731: LD_INT 8
40733: PUSH
40734: EMPTY
40735: LIST
40736: LIST
40737: PUSH
40738: LD_INT 30
40740: PUSH
40741: LD_INT 39
40743: PUSH
40744: EMPTY
40745: LIST
40746: LIST
40747: PUSH
40748: EMPTY
40749: LIST
40750: LIST
40751: LIST
40752: LIST
40753: LIST
40754: PUSH
40755: EMPTY
40756: LIST
40757: PPUSH
40758: CALL_OW 69
40762: ST_TO_ADDR
// for lab in list do
40763: LD_ADDR_VAR 0 2
40767: PUSH
40768: LD_VAR 0 1
40772: PUSH
40773: FOR_IN
40774: IFFALSE 40787
// Update_Artefact ( lab ) ;
40776: LD_VAR 0 2
40780: PPUSH
40781: CALL 40493 0 1
40785: GO 40773
40787: POP
40788: POP
// enable ;
40789: ENABLE
// end ; end_of_file
40790: PPOPN 2
40792: END
// var view_data , human_changed ; export function Show_me_map ( side , x , y ) ; var vysledek , station ; begin
40793: LD_INT 0
40795: PPUSH
40796: PPUSH
40797: PPUSH
// vysledek := true ;
40798: LD_ADDR_VAR 0 5
40802: PUSH
40803: LD_INT 1
40805: ST_TO_ADDR
// station := GetBase ( GetTag ( side * 10 + 15 ) ) ;
40806: LD_ADDR_VAR 0 6
40810: PUSH
40811: LD_VAR 0 1
40815: PUSH
40816: LD_INT 10
40818: MUL
40819: PUSH
40820: LD_INT 15
40822: PLUS
40823: PPUSH
40824: CALL_OW 110
40828: PPUSH
40829: CALL_OW 274
40833: ST_TO_ADDR
// if station and ( GetResources ( station ) [ 3 ] >= GetTag ( 06 ) ) then
40834: LD_VAR 0 6
40838: PUSH
40839: LD_VAR 0 6
40843: PPUSH
40844: CALL_OW 279
40848: PUSH
40849: LD_INT 3
40851: ARRAY
40852: PUSH
40853: LD_INT 6
40855: PPUSH
40856: CALL_OW 110
40860: GREATEREQUAL
40861: AND
40862: IFFALSE 40952
// begin PlaceSeeing ( x , y , side , - 15 ) ;
40864: LD_VAR 0 2
40868: PPUSH
40869: LD_VAR 0 3
40873: PPUSH
40874: LD_VAR 0 1
40878: PPUSH
40879: LD_INT 15
40881: NEG
40882: PPUSH
40883: CALL_OW 330
// SetResourceType ( station , mat_siberit , GetResources ( station ) [ 3 ] - GetTag ( 06 ) ) ;
40887: LD_VAR 0 6
40891: PPUSH
40892: LD_INT 3
40894: PPUSH
40895: LD_VAR 0 6
40899: PPUSH
40900: CALL_OW 279
40904: PUSH
40905: LD_INT 3
40907: ARRAY
40908: PUSH
40909: LD_INT 6
40911: PPUSH
40912: CALL_OW 110
40916: MINUS
40917: PPUSH
40918: CALL_OW 277
// view_data := [ x , y , side ] ;
40922: LD_ADDR_LOC 81
40926: PUSH
40927: LD_VAR 0 2
40931: PUSH
40932: LD_VAR 0 3
40936: PUSH
40937: LD_VAR 0 1
40941: PUSH
40942: EMPTY
40943: LIST
40944: LIST
40945: LIST
40946: ST_TO_ADDR
// enable ( 111 ) ;
40947: LD_INT 111
40949: ENABLE_MARKED
// end else
40950: GO 40960
// vysledek := false ;
40952: LD_ADDR_VAR 0 5
40956: PUSH
40957: LD_INT 0
40959: ST_TO_ADDR
// result := vysledek ;
40960: LD_ADDR_VAR 0 4
40964: PUSH
40965: LD_VAR 0 5
40969: ST_TO_ADDR
// end ;
40970: LD_VAR 0 4
40974: RET
// every 0 0$2.8 trigger view_data marked 111 do
40975: LD_LOC 81
40979: IFFALSE 41030
40981: GO 40983
40983: DISABLE
// begin wait ( 0 0$30 ) ;
40984: LD_INT 1050
40986: PPUSH
40987: CALL_OW 67
// RemoveSeeing ( view_data [ 1 ] , view_data [ 2 ] , view_data [ 3 ] ) ;
40991: LD_LOC 81
40995: PUSH
40996: LD_INT 1
40998: ARRAY
40999: PPUSH
41000: LD_LOC 81
41004: PUSH
41005: LD_INT 2
41007: ARRAY
41008: PPUSH
41009: LD_LOC 81
41013: PUSH
41014: LD_INT 3
41016: ARRAY
41017: PPUSH
41018: CALL_OW 331
// view_data := 0 ;
41022: LD_ADDR_LOC 81
41026: PUSH
41027: LD_INT 0
41029: ST_TO_ADDR
// end ;
41030: END
// export function Destroy_siberite ( side , un ) ; var vysledek , station , v_can , b_can , it_can , building_list , vehicle_list ; begin
41031: LD_INT 0
41033: PPUSH
41034: PPUSH
41035: PPUSH
41036: PPUSH
41037: PPUSH
41038: PPUSH
41039: PPUSH
41040: PPUSH
// vysledek := true ;
41041: LD_ADDR_VAR 0 4
41045: PUSH
41046: LD_INT 1
41048: ST_TO_ADDR
// it_can := false ;
41049: LD_ADDR_VAR 0 8
41053: PUSH
41054: LD_INT 0
41056: ST_TO_ADDR
// building_list := [ b_siberite_mine , b_siberite_power ] ;
41057: LD_ADDR_VAR 0 9
41061: PUSH
41062: LD_INT 30
41064: PUSH
41065: LD_INT 28
41067: PUSH
41068: EMPTY
41069: LIST
41070: LIST
41071: ST_TO_ADDR
// vehicle_list := [ us_siberium_rocket , ru_siberium_rocket , ar_selfpropelled_bomb , ru_time_lapser , us_double_laser ] ;
41072: LD_ADDR_VAR 0 10
41076: PUSH
41077: LD_INT 8
41079: PUSH
41080: LD_INT 48
41082: PUSH
41083: LD_INT 29
41085: PUSH
41086: LD_INT 49
41088: PUSH
41089: LD_INT 10
41091: PUSH
41092: EMPTY
41093: LIST
41094: LIST
41095: LIST
41096: LIST
41097: LIST
41098: ST_TO_ADDR
// b_can := ( GetType ( un ) = unit_building ) and ( ( GetBType ( un ) in building_list ) or ( GetBWeapon ( un ) in vehicle_list ) ) ;
41099: LD_ADDR_VAR 0 7
41103: PUSH
41104: LD_VAR 0 2
41108: PPUSH
41109: CALL_OW 247
41113: PUSH
41114: LD_INT 3
41116: EQUAL
41117: PUSH
41118: LD_VAR 0 2
41122: PPUSH
41123: CALL_OW 266
41127: PUSH
41128: LD_VAR 0 9
41132: IN
41133: PUSH
41134: LD_VAR 0 2
41138: PPUSH
41139: CALL_OW 269
41143: PUSH
41144: LD_VAR 0 10
41148: IN
41149: OR
41150: AND
41151: ST_TO_ADDR
// v_can := ( GetType ( un ) = unit_vehicle ) and ( ( GetWeapon ( un ) in vehicle_list ) or ( GetEngine ( un ) = engine_siberite ) ) ;
41152: LD_ADDR_VAR 0 6
41156: PUSH
41157: LD_VAR 0 2
41161: PPUSH
41162: CALL_OW 247
41166: PUSH
41167: LD_INT 2
41169: EQUAL
41170: PUSH
41171: LD_VAR 0 2
41175: PPUSH
41176: CALL_OW 264
41180: PUSH
41181: LD_VAR 0 10
41185: IN
41186: PUSH
41187: LD_VAR 0 2
41191: PPUSH
41192: CALL_OW 262
41196: PUSH
41197: LD_INT 3
41199: EQUAL
41200: OR
41201: AND
41202: ST_TO_ADDR
// it_can := b_can or v_can ;
41203: LD_ADDR_VAR 0 8
41207: PUSH
41208: LD_VAR 0 7
41212: PUSH
41213: LD_VAR 0 6
41217: OR
41218: ST_TO_ADDR
// station := GetBase ( GetTag ( 100 + side * 10 + 15 ) ) ;
41219: LD_ADDR_VAR 0 5
41223: PUSH
41224: LD_INT 100
41226: PUSH
41227: LD_VAR 0 1
41231: PUSH
41232: LD_INT 10
41234: MUL
41235: PLUS
41236: PUSH
41237: LD_INT 15
41239: PLUS
41240: PPUSH
41241: CALL_OW 110
41245: PPUSH
41246: CALL_OW 274
41250: ST_TO_ADDR
// if station and it_can and ( GetResources ( station ) [ 3 ] >= GetTag ( 106 ) ) then
41251: LD_VAR 0 5
41255: PUSH
41256: LD_VAR 0 8
41260: AND
41261: PUSH
41262: LD_VAR 0 5
41266: PPUSH
41267: CALL_OW 279
41271: PUSH
41272: LD_INT 3
41274: ARRAY
41275: PUSH
41276: LD_INT 106
41278: PPUSH
41279: CALL_OW 110
41283: GREATEREQUAL
41284: AND
41285: IFFALSE 41333
// begin KillUnit ( un ) ;
41287: LD_VAR 0 2
41291: PPUSH
41292: CALL_OW 66
// SetResourceType ( station , mat_siberit , GetResources ( station ) [ 3 ] - GetTag ( 106 ) ) ;
41296: LD_VAR 0 5
41300: PPUSH
41301: LD_INT 3
41303: PPUSH
41304: LD_VAR 0 5
41308: PPUSH
41309: CALL_OW 279
41313: PUSH
41314: LD_INT 3
41316: ARRAY
41317: PUSH
41318: LD_INT 106
41320: PPUSH
41321: CALL_OW 110
41325: MINUS
41326: PPUSH
41327: CALL_OW 277
// end else
41331: GO 41341
// vysledek := false ;
41333: LD_ADDR_VAR 0 4
41337: PUSH
41338: LD_INT 0
41340: ST_TO_ADDR
// result := vysledek ;
41341: LD_ADDR_VAR 0 3
41345: PUSH
41346: LD_VAR 0 4
41350: ST_TO_ADDR
// end ;
41351: LD_VAR 0 3
41355: RET
// export function Mass_Teleport ( side , x , y ) ; var vysledek , station , list , un ; begin
41356: LD_INT 0
41358: PPUSH
41359: PPUSH
41360: PPUSH
41361: PPUSH
41362: PPUSH
// vysledek := true ;
41363: LD_ADDR_VAR 0 5
41367: PUSH
41368: LD_INT 1
41370: ST_TO_ADDR
// station := GetBase ( GetTag ( 200 + side * 10 + 15 ) ) ;
41371: LD_ADDR_VAR 0 6
41375: PUSH
41376: LD_INT 200
41378: PUSH
41379: LD_VAR 0 1
41383: PUSH
41384: LD_INT 10
41386: MUL
41387: PLUS
41388: PUSH
41389: LD_INT 15
41391: PLUS
41392: PPUSH
41393: CALL_OW 110
41397: PPUSH
41398: CALL_OW 274
41402: ST_TO_ADDR
// if station and ( GetResources ( station ) [ 3 ] >= GetTag ( 206 ) ) then
41403: LD_VAR 0 6
41407: PUSH
41408: LD_VAR 0 6
41412: PPUSH
41413: CALL_OW 279
41417: PUSH
41418: LD_INT 3
41420: ARRAY
41421: PUSH
41422: LD_INT 206
41424: PPUSH
41425: CALL_OW 110
41429: GREATEREQUAL
41430: AND
41431: IFFALSE 41614
// begin SetResourceType ( station , mat_siberit , GetResources ( station ) [ 3 ] - GetTag ( 206 ) ) ;
41433: LD_VAR 0 6
41437: PPUSH
41438: LD_INT 3
41440: PPUSH
41441: LD_VAR 0 6
41445: PPUSH
41446: CALL_OW 279
41450: PUSH
41451: LD_INT 3
41453: ARRAY
41454: PUSH
41455: LD_INT 206
41457: PPUSH
41458: CALL_OW 110
41462: MINUS
41463: PPUSH
41464: CALL_OW 277
// SetAreaMapShow ( teleport_area , 1 ) ;
41468: LD_INT 24
41470: PPUSH
41471: LD_INT 1
41473: PPUSH
41474: CALL_OW 424
// for un = 1 to 11 do
41478: LD_ADDR_VAR 0 8
41482: PUSH
41483: DOUBLE
41484: LD_INT 1
41486: DEC
41487: ST_TO_ADDR
41488: LD_INT 11
41490: PUSH
41491: FOR_TO
41492: IFFALSE 41520
// begin display_strings := [ ( 11 - un ) ] ;
41494: LD_ADDR_OWVAR 47
41498: PUSH
41499: LD_INT 11
41501: PUSH
41502: LD_VAR 0 8
41506: MINUS
41507: PUSH
41508: EMPTY
41509: LIST
41510: ST_TO_ADDR
// wait ( 0 0$1 ) ;
41511: LD_INT 35
41513: PPUSH
41514: CALL_OW 67
// end ;
41518: GO 41491
41520: POP
41521: POP
// display_strings :=  ;
41522: LD_ADDR_OWVAR 47
41526: PUSH
41527: LD_STRING 
41529: ST_TO_ADDR
// SetAreaMapShow ( teleport_area , 0 ) ;
41530: LD_INT 24
41532: PPUSH
41533: LD_INT 0
41535: PPUSH
41536: CALL_OW 424
// list := FilterUnitsInArea ( teleport_area , [ f_not , [ f_type , unit_building ] ] ) ;
41540: LD_ADDR_VAR 0 7
41544: PUSH
41545: LD_INT 24
41547: PPUSH
41548: LD_INT 3
41550: PUSH
41551: LD_INT 21
41553: PUSH
41554: LD_INT 3
41556: PUSH
41557: EMPTY
41558: LIST
41559: LIST
41560: PUSH
41561: EMPTY
41562: LIST
41563: LIST
41564: PPUSH
41565: CALL_OW 70
41569: ST_TO_ADDR
// for un in list do
41570: LD_ADDR_VAR 0 8
41574: PUSH
41575: LD_VAR 0 7
41579: PUSH
41580: FOR_IN
41581: IFFALSE 41610
// TeleportUnit ( un , x , y , 12 , true ) ;
41583: LD_VAR 0 8
41587: PPUSH
41588: LD_VAR 0 2
41592: PPUSH
41593: LD_VAR 0 3
41597: PPUSH
41598: LD_INT 12
41600: PPUSH
41601: LD_INT 1
41603: PPUSH
41604: CALL_OW 483
41608: GO 41580
41610: POP
41611: POP
// end else
41612: GO 41622
// vysledek := false ;
41614: LD_ADDR_VAR 0 5
41618: PUSH
41619: LD_INT 0
41621: ST_TO_ADDR
// result := vysledek ;
41622: LD_ADDR_VAR 0 4
41626: PUSH
41627: LD_VAR 0 5
41631: ST_TO_ADDR
// end ;
41632: LD_VAR 0 4
41636: RET
// every 0 0$5 marked 20 do var art , side , recharge ;
41637: GO 41639
41639: DISABLE
41640: LD_INT 0
41642: PPUSH
41643: PPUSH
41644: PPUSH
// begin side := you ;
41645: LD_ADDR_VAR 0 2
41649: PUSH
41650: LD_EXP 1
41654: ST_TO_ADDR
// for art = 0 to artefact_number do
41655: LD_ADDR_VAR 0 1
41659: PUSH
41660: DOUBLE
41661: LD_INT 0
41663: DEC
41664: ST_TO_ADDR
41665: LD_EXP 78
41669: PUSH
41670: FOR_TO
41671: IFFALSE 41771
// begin recharge := art * 100 + side * 10 + 13 ;
41673: LD_ADDR_VAR 0 3
41677: PUSH
41678: LD_VAR 0 1
41682: PUSH
41683: LD_INT 100
41685: MUL
41686: PUSH
41687: LD_VAR 0 2
41691: PUSH
41692: LD_INT 10
41694: MUL
41695: PLUS
41696: PUSH
41697: LD_INT 13
41699: PLUS
41700: ST_TO_ADDR
// if GetTag ( recharge ) > 0 then
41701: LD_VAR 0 3
41705: PPUSH
41706: CALL_OW 110
41710: PUSH
41711: LD_INT 0
41713: GREATER
41714: IFFALSE 41769
// begin SetTag ( recharge , GetTag ( recharge ) - 1 ) ;
41716: LD_VAR 0 3
41720: PPUSH
41721: LD_VAR 0 3
41725: PPUSH
41726: CALL_OW 110
41730: PUSH
41731: LD_INT 1
41733: MINUS
41734: PPUSH
41735: CALL_OW 109
// if not GetTag ( recharge ) then
41739: LD_VAR 0 3
41743: PPUSH
41744: CALL_OW 110
41748: NOT
41749: IFFALSE 41769
// Highlight_Artefact ( side , art + 1 ) ;
41751: LD_VAR 0 2
41755: PPUSH
41756: LD_VAR 0 1
41760: PUSH
41761: LD_INT 1
41763: PLUS
41764: PPUSH
41765: CALL 39506 0 2
// end ; end ;
41769: GO 41670
41771: POP
41772: POP
// enable ;
41773: ENABLE
// end ; end_of_file
41774: PPOPN 3
41776: END
// var us_fort , ru_fort ; var us_place , ru_place ; every 0 0$11 do var side , un , list ;
41777: GO 41779
41779: DISABLE
41780: LD_INT 0
41782: PPUSH
41783: PPUSH
41784: PPUSH
// begin us_fort := [ ] ;
41785: LD_ADDR_LOC 83
41789: PUSH
41790: EMPTY
41791: ST_TO_ADDR
// ru_fort := [ ] ;
41792: LD_ADDR_LOC 84
41796: PUSH
41797: EMPTY
41798: ST_TO_ADDR
// for side in ( cpu_list diff ar ) do
41799: LD_ADDR_VAR 0 1
41803: PUSH
41804: LD_EXP 8
41808: PUSH
41809: LD_EXP 4
41813: DIFF
41814: PUSH
41815: FOR_IN
41816: IFFALSE 42021
// begin list := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ] ) ;
41818: LD_ADDR_VAR 0 3
41822: PUSH
41823: LD_INT 22
41825: PUSH
41826: LD_VAR 0 1
41830: PUSH
41831: EMPTY
41832: LIST
41833: LIST
41834: PUSH
41835: LD_INT 2
41837: PUSH
41838: LD_INT 30
41840: PUSH
41841: LD_INT 32
41843: PUSH
41844: EMPTY
41845: LIST
41846: LIST
41847: PUSH
41848: LD_INT 30
41850: PUSH
41851: LD_INT 33
41853: PUSH
41854: EMPTY
41855: LIST
41856: LIST
41857: PUSH
41858: EMPTY
41859: LIST
41860: LIST
41861: LIST
41862: PUSH
41863: EMPTY
41864: LIST
41865: LIST
41866: PPUSH
41867: CALL_OW 69
41871: ST_TO_ADDR
// for un in list do
41872: LD_ADDR_VAR 0 2
41876: PUSH
41877: LD_VAR 0 3
41881: PUSH
41882: FOR_IN
41883: IFFALSE 42017
// case side of us :
41885: LD_VAR 0 1
41889: PUSH
41890: LD_EXP 3
41894: DOUBLE
41895: EQUAL
41896: IFTRUE 41900
41898: GO 41952
41900: POP
// us_fort := us_fort ^ [ [ GetX ( un ) , GetY ( un ) , GetBWeapon ( un ) ] ] ; ru :
41901: LD_ADDR_LOC 83
41905: PUSH
41906: LD_LOC 83
41910: PUSH
41911: LD_VAR 0 2
41915: PPUSH
41916: CALL_OW 250
41920: PUSH
41921: LD_VAR 0 2
41925: PPUSH
41926: CALL_OW 251
41930: PUSH
41931: LD_VAR 0 2
41935: PPUSH
41936: CALL_OW 269
41940: PUSH
41941: EMPTY
41942: LIST
41943: LIST
41944: LIST
41945: PUSH
41946: EMPTY
41947: LIST
41948: ADD
41949: ST_TO_ADDR
41950: GO 42015
41952: LD_EXP 2
41956: DOUBLE
41957: EQUAL
41958: IFTRUE 41962
41960: GO 42014
41962: POP
// ru_fort := ru_fort ^ [ [ GetX ( un ) , GetY ( un ) , GetBWeapon ( un ) ] ] ; end ;
41963: LD_ADDR_LOC 84
41967: PUSH
41968: LD_LOC 84
41972: PUSH
41973: LD_VAR 0 2
41977: PPUSH
41978: CALL_OW 250
41982: PUSH
41983: LD_VAR 0 2
41987: PPUSH
41988: CALL_OW 251
41992: PUSH
41993: LD_VAR 0 2
41997: PPUSH
41998: CALL_OW 269
42002: PUSH
42003: EMPTY
42004: LIST
42005: LIST
42006: LIST
42007: PUSH
42008: EMPTY
42009: LIST
42010: ADD
42011: ST_TO_ADDR
42012: GO 42015
42014: POP
42015: GO 41882
42017: POP
42018: POP
// end ;
42019: GO 41815
42021: POP
42022: POP
// end ;
42023: PPOPN 3
42025: END
// every 0 0$10.5 do var un , w , x , y , list ;
42026: GO 42028
42028: DISABLE
42029: LD_INT 0
42031: PPUSH
42032: PPUSH
42033: PPUSH
42034: PPUSH
42035: PPUSH
// begin list := FilterAllUnits ( [ [ f_side , us ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_constructed ] , f_not , [ f_or , [ f_bweapon , us_rocket_launcher ] , [ f_bweapon , us_heavy_gun ] , [ f_bweapon , us_radar ] , [ f_bweapon , us_double_laser ] ] ] ) ;
42036: LD_ADDR_VAR 0 5
42040: PUSH
42041: LD_INT 22
42043: PUSH
42044: LD_EXP 3
42048: PUSH
42049: EMPTY
42050: LIST
42051: LIST
42052: PUSH
42053: LD_INT 2
42055: PUSH
42056: LD_INT 30
42058: PUSH
42059: LD_INT 32
42061: PUSH
42062: EMPTY
42063: LIST
42064: LIST
42065: PUSH
42066: LD_INT 30
42068: PUSH
42069: LD_INT 33
42071: PUSH
42072: EMPTY
42073: LIST
42074: LIST
42075: PUSH
42076: EMPTY
42077: LIST
42078: LIST
42079: LIST
42080: PUSH
42081: LD_INT 57
42083: PUSH
42084: EMPTY
42085: LIST
42086: PUSH
42087: LD_INT 3
42089: PUSH
42090: LD_INT 2
42092: PUSH
42093: LD_INT 35
42095: PUSH
42096: LD_INT 7
42098: PUSH
42099: EMPTY
42100: LIST
42101: LIST
42102: PUSH
42103: LD_INT 35
42105: PUSH
42106: LD_INT 6
42108: PUSH
42109: EMPTY
42110: LIST
42111: LIST
42112: PUSH
42113: LD_INT 35
42115: PUSH
42116: LD_INT 11
42118: PUSH
42119: EMPTY
42120: LIST
42121: LIST
42122: PUSH
42123: LD_INT 35
42125: PUSH
42126: LD_INT 10
42128: PUSH
42129: EMPTY
42130: LIST
42131: LIST
42132: PUSH
42133: EMPTY
42134: LIST
42135: LIST
42136: LIST
42137: LIST
42138: LIST
42139: PUSH
42140: EMPTY
42141: LIST
42142: LIST
42143: LIST
42144: LIST
42145: LIST
42146: PPUSH
42147: CALL_OW 69
42151: ST_TO_ADDR
// for un in list do
42152: LD_ADDR_VAR 0 1
42156: PUSH
42157: LD_VAR 0 5
42161: PUSH
42162: FOR_IN
42163: IFFALSE 42278
// begin x := GetX ( un ) ;
42165: LD_ADDR_VAR 0 3
42169: PUSH
42170: LD_VAR 0 1
42174: PPUSH
42175: CALL_OW 250
42179: ST_TO_ADDR
// y := GetY ( un ) ;
42180: LD_ADDR_VAR 0 4
42184: PUSH
42185: LD_VAR 0 1
42189: PPUSH
42190: CALL_OW 251
42194: ST_TO_ADDR
// for w in us_fort do
42195: LD_ADDR_VAR 0 2
42199: PUSH
42200: LD_LOC 83
42204: PUSH
42205: FOR_IN
42206: IFFALSE 42267
// begin if ( x = w [ 1 ] ) and ( y = w [ 2 ] ) then
42208: LD_VAR 0 3
42212: PUSH
42213: LD_VAR 0 2
42217: PUSH
42218: LD_INT 1
42220: ARRAY
42221: EQUAL
42222: PUSH
42223: LD_VAR 0 4
42227: PUSH
42228: LD_VAR 0 2
42232: PUSH
42233: LD_INT 2
42235: ARRAY
42236: EQUAL
42237: AND
42238: IFFALSE 42258
// ComPlaceWeapon ( un , w [ 3 ] ) ;
42240: LD_VAR 0 1
42244: PPUSH
42245: LD_VAR 0 2
42249: PUSH
42250: LD_INT 3
42252: ARRAY
42253: PPUSH
42254: CALL_OW 148
// wait ( 8 ) ;
42258: LD_INT 8
42260: PPUSH
42261: CALL_OW 67
// end ;
42265: GO 42205
42267: POP
42268: POP
// wait ( 27 ) ;
42269: LD_INT 27
42271: PPUSH
42272: CALL_OW 67
// end ;
42276: GO 42162
42278: POP
42279: POP
// wait ( Rand ( 0 0$5 , 0 0$10 ) ) ;
42280: LD_INT 175
42282: PPUSH
42283: LD_INT 350
42285: PPUSH
42286: CALL_OW 12
42290: PPUSH
42291: CALL_OW 67
// enable ;
42295: ENABLE
// end ;
42296: PPOPN 5
42298: END
// every 0 0$10.7 do var un , w , x , y , list ;
42299: GO 42301
42301: DISABLE
42302: LD_INT 0
42304: PPUSH
42305: PPUSH
42306: PPUSH
42307: PPUSH
42308: PPUSH
// begin list := FilterAllUnits ( [ [ f_side , ru ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_constructed ] , f_not , [ f_or , [ f_bweapon , ru_rocket ] , [ f_bweapon , ru_heavy_gun ] , [ f_bweapon , ru_time_lapser ] , [ f_bweapon , ru_gatling_gun ] ] ] ) ;
42309: LD_ADDR_VAR 0 5
42313: PUSH
42314: LD_INT 22
42316: PUSH
42317: LD_EXP 2
42321: PUSH
42322: EMPTY
42323: LIST
42324: LIST
42325: PUSH
42326: LD_INT 2
42328: PUSH
42329: LD_INT 30
42331: PUSH
42332: LD_INT 32
42334: PUSH
42335: EMPTY
42336: LIST
42337: LIST
42338: PUSH
42339: LD_INT 30
42341: PUSH
42342: LD_INT 33
42344: PUSH
42345: EMPTY
42346: LIST
42347: LIST
42348: PUSH
42349: EMPTY
42350: LIST
42351: LIST
42352: LIST
42353: PUSH
42354: LD_INT 57
42356: PUSH
42357: EMPTY
42358: LIST
42359: PUSH
42360: LD_INT 3
42362: PUSH
42363: LD_INT 2
42365: PUSH
42366: LD_INT 35
42368: PUSH
42369: LD_INT 47
42371: PUSH
42372: EMPTY
42373: LIST
42374: LIST
42375: PUSH
42376: LD_INT 35
42378: PUSH
42379: LD_INT 46
42381: PUSH
42382: EMPTY
42383: LIST
42384: LIST
42385: PUSH
42386: LD_INT 35
42388: PUSH
42389: LD_INT 49
42391: PUSH
42392: EMPTY
42393: LIST
42394: LIST
42395: PUSH
42396: LD_INT 35
42398: PUSH
42399: LD_INT 43
42401: PUSH
42402: EMPTY
42403: LIST
42404: LIST
42405: PUSH
42406: EMPTY
42407: LIST
42408: LIST
42409: LIST
42410: LIST
42411: LIST
42412: PUSH
42413: EMPTY
42414: LIST
42415: LIST
42416: LIST
42417: LIST
42418: LIST
42419: PPUSH
42420: CALL_OW 69
42424: ST_TO_ADDR
// for un in list do
42425: LD_ADDR_VAR 0 1
42429: PUSH
42430: LD_VAR 0 5
42434: PUSH
42435: FOR_IN
42436: IFFALSE 42551
// begin x := GetX ( un ) ;
42438: LD_ADDR_VAR 0 3
42442: PUSH
42443: LD_VAR 0 1
42447: PPUSH
42448: CALL_OW 250
42452: ST_TO_ADDR
// y := GetY ( un ) ;
42453: LD_ADDR_VAR 0 4
42457: PUSH
42458: LD_VAR 0 1
42462: PPUSH
42463: CALL_OW 251
42467: ST_TO_ADDR
// for w in ru_fort do
42468: LD_ADDR_VAR 0 2
42472: PUSH
42473: LD_LOC 84
42477: PUSH
42478: FOR_IN
42479: IFFALSE 42540
// begin if ( x = w [ 1 ] ) and ( y = w [ 2 ] ) then
42481: LD_VAR 0 3
42485: PUSH
42486: LD_VAR 0 2
42490: PUSH
42491: LD_INT 1
42493: ARRAY
42494: EQUAL
42495: PUSH
42496: LD_VAR 0 4
42500: PUSH
42501: LD_VAR 0 2
42505: PUSH
42506: LD_INT 2
42508: ARRAY
42509: EQUAL
42510: AND
42511: IFFALSE 42531
// ComPlaceWeapon ( un , w [ 3 ] ) ;
42513: LD_VAR 0 1
42517: PPUSH
42518: LD_VAR 0 2
42522: PUSH
42523: LD_INT 3
42525: ARRAY
42526: PPUSH
42527: CALL_OW 148
// wait ( 8 ) ;
42531: LD_INT 8
42533: PPUSH
42534: CALL_OW 67
// end ;
42538: GO 42478
42540: POP
42541: POP
// wait ( 27 ) ;
42542: LD_INT 27
42544: PPUSH
42545: CALL_OW 67
// end ;
42549: GO 42435
42551: POP
42552: POP
// wait ( Rand ( 0 0$5 , 0 0$10 ) ) ;
42553: LD_INT 175
42555: PPUSH
42556: LD_INT 350
42558: PPUSH
42559: CALL_OW 12
42563: PPUSH
42564: CALL_OW 67
// enable ;
42568: ENABLE
// end ; end_of_file
42569: PPOPN 5
42571: END
// every 0 0$2 + 0 0$0.1 do
42572: GO 42574
42574: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
42575: LD_INT 22
42577: PUSH
42578: LD_INT 7
42580: PUSH
42581: EMPTY
42582: LIST
42583: LIST
42584: PUSH
42585: LD_INT 2
42587: PUSH
42588: LD_INT 25
42590: PUSH
42591: LD_INT 12
42593: PUSH
42594: EMPTY
42595: LIST
42596: LIST
42597: PUSH
42598: LD_INT 25
42600: PUSH
42601: LD_INT 16
42603: PUSH
42604: EMPTY
42605: LIST
42606: LIST
42607: PUSH
42608: LD_INT 25
42610: PUSH
42611: LD_INT 15
42613: PUSH
42614: EMPTY
42615: LIST
42616: LIST
42617: PUSH
42618: LD_INT 25
42620: PUSH
42621: LD_INT 17
42623: PUSH
42624: EMPTY
42625: LIST
42626: LIST
42627: PUSH
42628: EMPTY
42629: LIST
42630: LIST
42631: LIST
42632: LIST
42633: LIST
42634: PUSH
42635: EMPTY
42636: LIST
42637: LIST
42638: PPUSH
42639: CALL_OW 69
42643: PUSH
42644: LD_INT 22
42646: PUSH
42647: LD_INT 7
42649: PUSH
42650: EMPTY
42651: LIST
42652: LIST
42653: PUSH
42654: LD_INT 21
42656: PUSH
42657: LD_INT 1
42659: PUSH
42660: EMPTY
42661: LIST
42662: LIST
42663: PUSH
42664: LD_INT 3
42666: PUSH
42667: LD_INT 2
42669: PUSH
42670: LD_INT 25
42672: PUSH
42673: LD_INT 12
42675: PUSH
42676: EMPTY
42677: LIST
42678: LIST
42679: PUSH
42680: LD_INT 25
42682: PUSH
42683: LD_INT 16
42685: PUSH
42686: EMPTY
42687: LIST
42688: LIST
42689: PUSH
42690: LD_INT 25
42692: PUSH
42693: LD_INT 15
42695: PUSH
42696: EMPTY
42697: LIST
42698: LIST
42699: PUSH
42700: LD_INT 25
42702: PUSH
42703: LD_INT 17
42705: PUSH
42706: EMPTY
42707: LIST
42708: LIST
42709: PUSH
42710: EMPTY
42711: LIST
42712: LIST
42713: LIST
42714: LIST
42715: LIST
42716: PUSH
42717: EMPTY
42718: LIST
42719: LIST
42720: PUSH
42721: EMPTY
42722: LIST
42723: LIST
42724: LIST
42725: PPUSH
42726: CALL_OW 69
42730: GREATER
42731: IFFALSE 42742
// begin SetAchievement ( ACH_POTA ) ;
42733: LD_STRING ACH_POTA
42735: PPUSH
42736: CALL_OW 543
// exit ;
42740: GO 42743
// end ; enable ;
42742: ENABLE
// end ;
42743: END
// export function SA_OnMissionComplete ; begin
42744: LD_INT 0
42746: PPUSH
// SetAchievement ( ACH_FBF ) ;
42747: LD_STRING ACH_FBF
42749: PPUSH
42750: CALL_OW 543
// end ; end_of_file
42754: LD_VAR 0 1
42758: RET
// export function SA_EndMission ( campaignNumber , missionNumber , medal1 , medal2 , medal3 ) ; var achiv ; begin
42759: LD_INT 0
42761: PPUSH
42762: PPUSH
// if not missionNumber then
42763: LD_VAR 0 2
42767: NOT
42768: IFFALSE 42772
// exit ;
42770: GO 42902
// achiv := false ;
42772: LD_ADDR_VAR 0 7
42776: PUSH
42777: LD_INT 0
42779: ST_TO_ADDR
// case campaignNumber of 1 :
42780: LD_VAR 0 1
42784: PUSH
42785: LD_INT 1
42787: DOUBLE
42788: EQUAL
42789: IFTRUE 42793
42791: GO 42804
42793: POP
// achiv := ACH_GOTA ; 2 :
42794: LD_ADDR_VAR 0 7
42798: PUSH
42799: LD_STRING ACH_GOTA
42801: ST_TO_ADDR
42802: GO 42854
42804: LD_INT 2
42806: DOUBLE
42807: EQUAL
42808: IFTRUE 42812
42810: GO 42815
42812: POP
// ; 3 :
42813: GO 42854
42815: LD_INT 3
42817: DOUBLE
42818: EQUAL
42819: IFTRUE 42823
42821: GO 42834
42823: POP
// achiv := ACH_MOTSU ; 4 :
42824: LD_ADDR_VAR 0 7
42828: PUSH
42829: LD_STRING ACH_MOTSU
42831: ST_TO_ADDR
42832: GO 42854
42834: LD_INT 4
42836: DOUBLE
42837: EQUAL
42838: IFTRUE 42842
42840: GO 42853
42842: POP
// achiv := ACH_LOP ; end ;
42843: LD_ADDR_VAR 0 7
42847: PUSH
42848: LD_STRING ACH_LOP
42850: ST_TO_ADDR
42851: GO 42854
42853: POP
// if Difficulty = 3 and achiv and medal1 and medal2 and medal3 then
42854: LD_OWVAR 67
42858: PUSH
42859: LD_INT 3
42861: EQUAL
42862: PUSH
42863: LD_VAR 0 7
42867: AND
42868: PUSH
42869: LD_VAR 0 3
42873: AND
42874: PUSH
42875: LD_VAR 0 4
42879: AND
42880: PUSH
42881: LD_VAR 0 5
42885: AND
42886: IFFALSE 42902
// SetAchievementEX ( achiv , missionNumber ) ;
42888: LD_VAR 0 7
42892: PPUSH
42893: LD_VAR 0 2
42897: PPUSH
42898: CALL_OW 564
// end ;
42902: LD_VAR 0 6
42906: RET
// export function SA_BehemothConstructed ; begin
42907: LD_INT 0
42909: PPUSH
// SetAchievement ( ACH_SMC ) ;
42910: LD_STRING ACH_SMC
42912: PPUSH
42913: CALL_OW 543
// end ;
42917: LD_VAR 0 1
42921: RET
